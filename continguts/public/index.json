[
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/coleccions/1arraylist/",
	"title": "ArrayList",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que conté una col·lecció de dades del mateix tipus i és dinàmica.\n La definició de la classe ArrayList java.util.ArrayList i de totes les seves funcionalitats la trobareu a: Java Oracle Classe ArrayList\nPropietats\n Un arrayList funciona de forma similar a un array estàtic, conté elements del mateix tipus, poden ser repetits i aquests elements estan ordenats. A diferència d\u0026rsquo;un array estàtic, en els ArrayList no és necessari definir el tamany de l\u0026rsquo;array en la seva creació. Es tracta d\u0026rsquo;una llista d\u0026rsquo;elements en els que podrem iterar-los, afegir-ne, modificar-los o eliminar-los.  Les operacions d\u0026rsquo;afegir un element al final de l\u0026rsquo;array (add), i d\u0026rsquo;establir o obtenir l\u0026rsquo;element en una determinada posició (get/set) tenen un cost temporal constant. Les insercions i esborrats tenen un cost lineal O(n), on n és el nombre d\u0026rsquo;elements de l\u0026rsquo;array.\nHem de destacar que la implementació d' ArrayList no està sincronitzada, és a dir, si múltiples fils accedeixen a un mateix ArrayList concurrentment podríem tenir problemes en la consistència de les dades. Per tant, ho haurem de tenir en compte quan fem servir aquest tipus de dades que hem de controlar la concurrència d\u0026rsquo;accés, una altra opció és utilitzar la classe Vector, similar a ArrayList i que sí permet la sincronització.\nDeclaració\nEn la declaració indicarem de quin tipus és la llista entre \u0026lt;\u0026gt;. Per exemple per declarar un ArrayList d\u0026rsquo;enters:\nArrayList\u0026lt;Integer\u0026gt; arrayListEnters = new ArrayList();  Exemple\nEn el següent exemple es veuen diferents mètodes (tots ells explicats en la declaració de Java Oracle) que permeten actuar a un ArrayList de la mateixa manera que un Array (.add(), .size(), .get()), l\u0026rsquo;exemple és primer per un enter i després per una col·lecció d\u0026rsquo;objectes Alumne:\nimport java.util.ArrayList; import java.util.Collections; public class ExempleArrayList { public static void main(String[] args) { /* * ARRAYLIST AMB ENTERS */ System.out.println(\u0026quot;ARRAYLIST ENTERS\u0026quot;); ArrayList\u0026lt;Integer\u0026gt; aL = new ArrayList\u0026lt;Integer\u0026gt;(); // Afegir elements aL.add(23); aL.add(12); aL.add(46); aL.add(2); // Recorregut System.out.println(\u0026quot;Mostrem els elements tal qual s'han introduït, ArrayList és una llista d'elements:\u0026quot;); for (int i=0; i\u0026lt;aL.size(); i++){ System.out.print(aL.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); // Comprovar si conté un objecte i obtenir la posició System.out.println(\u0026quot;Comprovem si conté element 46 i diem la posició on es troba:\u0026quot;); if (aL.contains(46)) { System.out.println(\u0026quot;Existeix i es troba a la posició: \u0026quot; + aL.indexOf(46)); } System.out.println(); //Ordenem i recorregut Collections.sort(aL); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;aL.size(); i++){ System.out.print(aL.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Eliminem i recorregut System.out.println(\u0026quot;Eliminem l'element amb index 1:\u0026quot;); aL.remove(1); for (int i=0; i\u0026lt;aL.size(); i++){ System.out.print(aL.get(i) + \u0026quot; \u0026quot;); } System.out.println(); /* * ARRAYLIST AMB OBJECTES ALUMNE */ System.out.println(\u0026quot;ARRAYLIST ALUMNES\u0026quot;); ArrayList\u0026lt;Alumne\u0026gt; alumnes = new ArrayList\u0026lt;Alumne\u0026gt;(); // Afegir elements System.out.println(\u0026quot;Mostrem els elements tal qual s'han introduït:\u0026quot;); alumnes.add(new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;)); alumnes.add(new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;)); Alumne al = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); alumnes.add(al); alumnes.add(new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;)); alumnes.add(new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;)); // Recorregut for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i)); } System.out.println(); System.out.println(); // Comprovar si conté un objecte i obtenir la posició System.out.println(\u0026quot;Comprovem si conté un element Alumne \\\u0026quot;al\\\u0026quot; i diem la posició on es troba:\u0026quot;); if (alumnes.contains(al)) { System.out.println(\u0026quot;Existeix i es troba a la posició: \u0026quot; + alumnes.indexOf(al)); } System.out.println(); System.out.println(); //ORDENACIÓ D'OBJECTES //Ordenem per edat i mostrem en recorregut Collections.sort(alumnes, Alumne.alumnesCompararPerEdat); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Ordenem per nom i mostrem en recorregut Collections.sort(alumnes, Alumne.alumnesCompararPerNom); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Ordenem per cognoms i mostrem en recorregut Collections.sort(alumnes, Alumne.alumnesCompararPerCognom); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Eliminem i recorregut System.out.println(\u0026quot;Eliminem l'element amb index 1:\u0026quot;); alumnes.remove(1); System.out.println(); for (Alumne alumne : alumnes){ System.out.println(alumne); } } }  En aquesta pàgina trobareu uns quants exemples més d\u0026rsquo;ús d\u0026rsquo;ArrayList: ArrayList con ejemplos\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arrayunidimensional/",
	"title": "Arrays Unidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que conté una col·lecció de dades del mateix tipus.\n La biblioteca de classes de Java inclou una classe auxiliar que s\u0026rsquo;anomena java.util.Arrays i conté funcions molt útils per utilitzar amb arrays: Java Oracle Classe Arrays\nPropietats\n Els arrays s\u0026rsquo;utilitzen com a contenedors per guardar dades relacionades (enlloc de declarar variables per separat per cada un dels elements de l\u0026rsquo;array). Totes les dades incluïdes a l\u0026rsquo;array són del mateix tipus. Es poden crear arrays d\u0026rsquo;enters (int, long), de reals(float, double), però en un mateix array no es poden mesclar dades de tipus diferents. En els arrays estàtics el tamany s\u0026rsquo;estableix quan es crea l\u0026rsquo;array (amb l\u0026rsquo;operador new, igual que qualsevol altre objecte). Als elements de l\u0026rsquo;array si accedirà a través de la posició que ocupa dins el conjunt d\u0026rsquo;elements de l\u0026rsquo;array.  Exemple Per exemple podríem necessitar les edats d\u0026rsquo;una classe per efectuar-ne un tractament especial. Fins ara el que podíem fer és declarar tantes variables enteres com alumnes hi hagi per tal de guardar-ne l\u0026rsquo;edat:\nint edatAlumne1 = 29; int edatAlumne2 = 26; int edatAlumne3 = 18; ... int edatAlumne30 = 28;  Com podeu observar, si escaléssim el problema anterior i enlloc de 30 necessitéssim les edats dels 700 estudiants de l\u0026rsquo;institut, la declaració de variables seria una feina feixuga i amb un alt índex d\u0026rsquo;equivocar-nos, a més no permetria mantenir i modificar el programa de forma àgil. Per això hi ha les estructures de dades d\u0026rsquo;un mateix tipus. Una manera de guardar 700 edats dins una mateixa estructura seria aquesta:\n//Declarem una posició de memòria on hi ha una referència a un array int[] edatsAlumnes; //Aquest array és estàtic, per això abans d'usar-lo ens reservem en memòria el nombre d'enters que necessitem edatsAlumnes = new int[700]; //Omplim les edats dels alumnes for(int i = 0; i \u0026lt; edatsAlumnes.length; i++) edatsAlumnes[i] = sc.nextInt();  Declaració array En les línies anteriors hem observat que per crear un objecte array, és necessari fer servir la paraula reservada new, amb això el que fem és reservar en memòria l\u0026rsquo;espai necessari per allotjar la informació. En el següent exemple creem un array estàtic que l\u0026rsquo;anomeno arrayEstatic de 12 posicions.\nint[] arrayEstatic = new int[12]; //També es podria fer de la següent manera: int arrayEstatic[] = new int[12];  Fixeu-vos que en el primer exemple he fet la declaració i la reserva d\u0026rsquo;espais dels enters en instruccions separades, en canvi en aquest últim exemple ho he fet tot junt en una única línia.\nPer accedir a la posició enèssima de l\u0026rsquo;array ho puc fer de la següent manera arrayEstatic[n].\nEls Indexs d\u0026rsquo;un array comencen en la posició 0, no en la 1. L\u0026rsquo;últim element de l\u0026rsquo;array es troba a la posició llargària de l\u0026rsquo;array - 1. Així doncs en l\u0026rsquo;exemple anterior el primer enter de l\u0026rsquo;arrayEstatic es troba en la posició arrayEstatic[0] mentre que l\u0026rsquo;últim en la posició arrayEstatic[11]. Hem de tenir en compte que l'índex no pot ser un valor negatiu, i que per exemple podria ser un càlcul numèric o fent ús de variables arrayEstatic[i + 1]\n És important entendre que un cop declaro un arrayEstatic, es reserva en memòria espai per guardar el tipus de dades * Tamany de l'array. En l\u0026rsquo;exemple anterior es demana al programa que ens reservi espai per a 12 enters consecutius. Aquests enters no tenen un valor definit (al ser enters Java els hi posa un 0, si fossin booleans el valor per defecte seria false), per tant cal que els inicialitzem un valor per utilitzar-los.\nint index = 4; int array[index + 1]++;  En aquest exemple s\u0026rsquo;observa com inicialitzem un índex a 4, s\u0026rsquo;accedeix a l\u0026rsquo;element amb índex 5 de l\u0026rsquo;array, és la posició 6 (recordeu que el 0 és la primera posició de l\u0026rsquo;array) i en l\u0026rsquo;enter de la posició 6 n\u0026rsquo;augmentem el valor en una unitat.\nLongitud Al ser una estructura estàtica la longitud de l\u0026rsquo;array no es pot variar i es defineix quan es crea (amb el new). Per tal d\u0026rsquo;obtenir el seu valor en Java utilitzarem la funció length:\nSystem.out.println(\u0026quot;La longitud de l'array és \u0026quot; + array.length);  Una altra inicialització Una altra manera d\u0026rsquo;inicialitzar un array és directament definint els seus elements:\nint[] array2 = {10, 20, 54, -2, 76 };  Si a aquest array2 imprimissim el seu valor de array2.length el resultat seria 5. De forma que s\u0026rsquo;hauria declarat i reservat la memòria directament.\nRecorregut i manipulació d\u0026rsquo;arrays Normalment ens trobarem amb problemes on cal accedir a arrays i efectuar-ne un tractament determinat. Per exemple, ens podríem trobar el següent problema:\n Com ho faríem per guardar en un array els 10 primers números parells?\n //declaració i creació de l'array\tint[] llista = new int[10]; //modificació el valor dels elements de l'array for(int i=0; i\u0026lt;llista.length; i++) { llista[i] = i*2; }\t//Imprimim els valors 0 2 4 6 8 10 12 14 16 18 for(int i=0; i\u0026lt;llista.length; i++) { System.out.print(llista[i] + \u0026quot; \u0026quot;); }  Es pot observar com mitjançant l\u0026rsquo;índex i s\u0026rsquo;accedeix a tots els elements de l\u0026rsquo;array i se\u0026rsquo;n va modificant el seu valor.\nOrdenació arrays Una altra funcionalitat corrent és l\u0026rsquo;ordenació de arrays. En Java existeix una funció que ordena els elements d\u0026rsquo;un array, més endavant l\u0026rsquo;estudiarem amb deteniment.\nArrays.sort(vector);  Existeixen molts algorismes diferents capaços d\u0026rsquo;ordenar els elements d\u0026rsquo;un array, tots ells tenen la seva lògica i obeeixen a casuïstiques diferents, i per tant també tenen costos de còmput diferent. En la següent web podrem observar simulacions de diferents algorismes en un llenguatge de pseudocodi i com evoluciona cada array fins a la seva ordenació: Visualgo\nCerca d\u0026rsquo;un element dins l\u0026rsquo;array La cerca d\u0026rsquo;un element dins un array és un problema típic. No és el mateix tenir l\u0026rsquo;array ordenat que l\u0026rsquo;array desordenat:\n Si l\u0026rsquo;array està desordenat farem un recorregut buscant l\u0026rsquo;element, si no el troba s\u0026rsquo;arriba al final de l\u0026rsquo;array, si el troba sortim de l\u0026rsquo;array abans de la seva finalització. Si l\u0026rsquo;array està ordenat, a diferència de l\u0026rsquo;anterior, no cal que busquem fins al final de l\u0026rsquo;array, un cop \u0026ldquo;em passi\u0026rdquo; de l\u0026rsquo;element que estic buscant ja no cal que continuï, és una manera d\u0026rsquo;optimitzar la cerca.  Cerca en array desordenat:\ndouble[] array = {2, 5.5, 9.1, 1, 2.9, 8, 5.5, 55.4, 2.6, 5.45, 7}; //Definim variable booleana per saber si s'ha trobat el valor boolean trobat = false; //Índex int i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length) \u0026amp;\u0026amp; (!trobat)) { if (array[i] == 8) { trobat = true; } i = i + 1; } //S’ha trobat? String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Cerca en array ordenat:\ndouble[] array = {2, 5.5, 8, 9.1, 10.4, 12.9, 18, 25.5, 55.4}; //Definim variable booleana per saber si s'ha trobat el valor boolean trobat = false; //Definim variable booleana per saber si ens hem passat ja de l'element boolean passat=false; //Índex int i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length) \u0026amp;\u0026amp; (!trobat) \u0026amp;\u0026amp; (!passat)) { if (array[i] == 8) { trobat = true; } if (array[i] \u0026gt; 8) { passat = true; } i = i + 1; } //S’ha trobat? String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Bucle for millorat per arrays Per tal d\u0026rsquo;efectuar el recorregut en un array java ens permet aquesta expressió reduïda de bucles for. Per exemple, els bucles següents són equivalents:\nfor(int i=0; i\u0026lt;array.length; i++) { int valor = array[i]; System.out.println(valor); } for(int valor: array) { System.out.println(valor); }  La versió adaptada del bucle for es pot fer servir amb qualsevol tipus d\u0026rsquo;array (String, int, boolean, etc.).\nMètodes més usats de la classe java.util.Arrays Arrays.sort(array); // Ordena els elements Arrays.equals(array1, array2); // Comprova si els dos arrays són iguals Arrays.fill(array, val) //Omple el vector v amb el valor \u0026quot;val\u0026quot; Arrays.toString(array) // Retorna una cadena que representa el contingut del vector Arrays.binarySearch(array, k) // Busca el valor k dins del vector array (que prèviament ha estat ordenat)  Exemples  Exemple de diferents maneres per omplir de valors un array i imprimir-lo per línia de comandes:  //Crear Array int primerArray[] = new int[7]; //Omplir de valors amb for i després amb while for(int i=0; i \u0026lt; primerArray.length; i++){ primerArray[i] = sc.nextInt(); } int i=0; while(i \u0026lt; primerArray.length){ primerArray[i] = sc.nextInt(); i++; } //Mostrar valors amb toString amb bucle for i bucle for millorat Arrays.toString(primerArray); for( i=0; i \u0026lt; primerArray.length; i++){ System.out.println(primerArray[i]); } for( int valor : primerArray){ System.out.println(valor); } //Ús de la funció fill de la classe Arrays que consisteix en omplir totes les posicions d'un array amb el mateix valor Arrays.fill(primerArray,7); for(i=0; i \u0026lt; primerArray.length; i++){ primerArray[i] = 7; }  Còpia d\u0026rsquo;arrays  int[] llista = {1,2,3,4}; //llita i llistaCopia apunten al mateix array ja que són referències int[] llistaCopia = llista; //Fent ús de clone. En aquest cas llista i llistaCopia SON DOS ARRAYS IGUALS I INDEPENDENTS llistaCopia = llista.clone(); //còpia manual dels elements\tfor(i=0; i \u0026lt; llista.length; i++){ llistaCopia[i] = llista[i]; } System.out.println(\u0026quot;Contingut de l'array 'llista'\u0026quot;); for(int valor : llista) System.out.println(valor); System.out.println(\u0026quot;Contingut de l'array 'llistaCopia'\u0026quot;); for(int valor : llistaCopia) System.out.println(valor);  Cerca d\u0026rsquo;un element dins un array (exemple del màxim)  primerArray = new int[]{-1, -2, -3, -4}; int max = 0; for(i=0; i \u0026lt; primerArray.length; i++){ if(max\u0026lt;primerArray[i]) max = primerArray[i]; }  Sumar els elements d\u0026rsquo;un array valor a valor i guardar-lo en un altre array  int vector1[] = new int[10]; int vector2[] = new int[10]; //falta introduir els valors en vector1 i vector2 int suma[] = new int[10]; for( i=0; i\u0026lt;suma.length;i++){ suma[i] = vector1[i] + vector2[i]; }  Cerca dicotòmica  //Tamany vector System.out.println(\u0026quot;De quants elements vols el vector?\u0026quot;); int llargada = sc.nextInt(); //Creem i posem elements aleatoris entre 0 i 100 dins el vector i l'ordenem int [] vector = new int[llargada]; for(int i=0; i\u0026lt;llargada;i++) vector[i] = (int)(Math.random()*100); Arrays.sort(vector); //Imprimim vector System.out.println(Arrays.toString(vector)); //Quin element vols buscar? System.out.println(\u0026quot;Quin element vols buscar?\u0026quot;); int nombreBuscat = sc.nextInt(); //inicialitzem index inferior i superior i declarem element central int elementCentral; int inferior=0; int superior=llargada-1; //inicialment no s'ha trobat l'element boolean trobat = false; int iteracions = 0; //mentre element inferior no rebassi el superior continuem explorant while(inferior\u0026lt;=superior \u0026amp;\u0026amp; !trobat){ //Augmentem nombre iteracions iteracions++; //busquem quin és l'element central elementCentral=(superior+inferior)/2; //Imprimim l'estat actual System.out.println(\u0026quot;Iteracio: \u0026quot; + iteracions + \u0026quot; Inferior:\u0026quot; + inferior + \u0026quot; Superior:\u0026quot; + superior + \u0026quot; Element Central:\u0026quot; + vector[elementCentral] + \u0026quot; A buscar:\u0026quot; + nombreBuscat); for(int i=inferior; i \u0026lt;= superior; i++) System.out.print(vector[i]+\u0026quot; \u0026quot;); System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;\u0026quot;); //Si el trobem posem trobat a true per sortir del bucle i anunciem que l'hem trobat if(vector[elementCentral]==nombreBuscat){ trobat=true; System.out.println(\u0026quot;L'element \u0026quot;+nombreBuscat+\u0026quot; està dins l'array\u0026quot;); } //Sinó actualitzem index, caldrà actualitzar o bé el superior en cas que el nombre buscat sigui inferior a l'actual, o bé l'inferior en cas contrari. else if(nombreBuscat \u0026lt; vector[elementCentral] ){ superior=elementCentral-1; } else { inferior=elementCentral+1; } } //Si no el trobem ho anunciem if(!trobat)System.out.println(\u0026quot;L'element no es troba en el vector\u0026quot;); /** * Comparem amb... * CERCA LINEAL * **/ inferior=0; superior=llargada-1; //inicialment no s'ha trobat l'element trobat = false; iteracions = 0; //mentre element inferior no rebassi el superior continuem explorant while(inferior\u0026lt;=superior \u0026amp;\u0026amp; !trobat) { //Augmentem nombre iteracions iteracions++; //Imprimim l'estat actual System.out.println(\u0026quot;Iteracio: \u0026quot; + iteracions + \u0026quot; Inferior:\u0026quot; + inferior + \u0026quot; Superior:\u0026quot; + superior + \u0026quot; Element Actual:\u0026quot; + vector[inferior] + \u0026quot; A buscar:\u0026quot; + nombreBuscat); for (int i = inferior; i \u0026lt;= superior; i++) System.out.print(vector[i] + \u0026quot; \u0026quot;); System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;\u0026quot;); //Si el trobem posem trobat a true per sortir del bucle i anunciem que l'hem trobat if (vector[inferior] == nombreBuscat) { trobat = true; System.out.println(\u0026quot;L'element \u0026quot; + nombreBuscat + \u0026quot; està dins l'array\u0026quot;); } //Miro el següent element inferior++; } //Si no el trobem ho anunciem if(!trobat)System.out.println(\u0026quot;L'element no es troba en el vector\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/",
	"title": "Estructura d’un programa",
	"tags": [],
	"description": "",
	"content": "En aquest apartat realitzarem una introducció sobre què és un programa informàtic, quines metodologies de Software hi ha al mercat alhora de treballar i analitzarem diferents classificacions dels llenguatges de programació:\n Introducció Metodologies de Software Tipus de Llenguatges  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/programacioavancadapoo/1herencia/",
	"title": "Herència",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;herència permet a una classe nova crear-se a partir d\u0026rsquo;una classe existent. La nova classe (subclasse) \u0026ldquo;hereta\u0026rdquo; els atributs i mètodes de la classe primària, i a més a més, té la possibilitat d\u0026rsquo;incorporar nous atributs i mètodes específics a la subclasse.\n Aquesta particularitat permet crear una estructura jeràrquica de classes cada vegada més especialitzada. L\u0026rsquo;herència es basa en la reutilització de classes on es crea una classe nova incorporant atributs i mètodes de la classe pare. Els mètodes heretats poden ser sobreescrits i adoptar un comportament nou o ampliant-ne la seva funcionalitat. Aquesta reutilització permet estalviar molt de temps i adoptar components creats i ja testats.\nConceptes:\n Superclasse: Classe primària o existent en l\u0026rsquo;herència. Subclasse: classe nova i resultant d\u0026rsquo;aplicar herència a una altra classe. Especialització: Procés que permet estendre d\u0026rsquo;una classe pare a una classe filla, ampliant atributs i mètodes. Generalització: Procés de navegar de les classes filles a la classe pare. En la classe pare trobarem els atributs i mètodes comuns a totes les subclasses.  Herència simple\nJava permet l\u0026rsquo;herència simple: qualsevol classe només té una classe pare, no permet l\u0026rsquo;herència múltiple com sí permeten altres llenguatges de programació com el C++. Això ens planteja el problema que a vegades pels requisits de la nostra aplicació és necessari simular l\u0026rsquo;herència múltiple fent ús d\u0026rsquo;interfícies. Per a més informació: problema del diamant\nRelació \u0026ldquo;és un\u0026rdquo; vs \u0026ldquo;conté un\u0026rdquo;\nL\u0026rsquo;herència és una relació d\u0026rsquo;extensió d\u0026rsquo;una classe més específica respecte una classe genèrica, això ens porta a que la classe filla ÉS UNA classe pare, però amb les funcionalitats ampliades/exteses/modificades. A vegades quan es programa existeix el dubte de confondre aquesta relació amb una relació de composició CONTÉ UN, que erròniament entenguem com a subclasse \u0026ldquo;una part\u0026rdquo; de la classe principal. Un exemple seria el següent:\nCom podeu veure en l\u0026rsquo;herència es parteix d\u0026rsquo;un BaseVehicle, que a la vegada s\u0026rsquo;especialitza en un Truck, i a la vegada s\u0026rsquo;especialitza en un TacoTruck. TacoTruck \u0026ldquo;ÉS UN\u0026rdquo; BaseVehicle, TacoTruck és una extensió de BaseVehicle. En canvi Truck \u0026ldquo;CONTÉ UN\u0026rdquo; engine, engine és una part de Truck, no podria substituir l\u0026rsquo;engine per un truck i que es comporti de la mateixa manera.\nUna vegada es conceptualitza el problema a resoldre pots crear el teu arbre jeràrquic. Un exemple amb animals seria:\nImplementació Per tal d\u0026rsquo;indicar que una classe és una herència utilitzarem la paraula extends en la definició de la classe. Per exemple si tenim una classe pare Persona i dos classes filles Alumne i Professor, ho faríem de la següent manera:\npublic class Persona{ ... } public class Alumne extends Persona { ... } public class Professor extends Persona{ ... }  Si la superclasse no està al mateix package que la subclasse, s\u0026rsquo;ha d\u0026rsquo;importar la classe ja que sinó no en tindria visibilitat.\njava.lang.Object\nUna subclasse pot ser a la vegada superclasse d\u0026rsquo;altres classes i crear així un àrbre jeràrquic de classes. En Java totes les classes hereten d\u0026rsquo;una classe mare, la classe arrel de totes és java.lang.Object. Hi ha un conjunt de mètodes que tenen TOTES les classes de Java, inclús les que programeu vosaltres, aquí teniu la descripció de Java Oracle referent a la classe Object.\nTotes les classes per defecte extenen de java.lang.Object, per tant poden fer ús dels mètodes que conté aquesta classe, per exemple:\n toString(): retorna una definició dels atributs en forma de String, aquesta definició la podeu \u0026ldquo;sobreescriure i modificar i adaptar a les vostres necessitats\u0026rdquo;. equals(Object o): mètode per comparar l\u0026rsquo;Objecte o amb l\u0026rsquo;implícit(this), per defecte retorna true si es tracta del mateix objecte (mateixa referència) i false si no. Si volem comparar els atributs per comprovar que es tracta dels mateixos valors serà necessari \u0026ldquo;sobreescriure\u0026rdquo; el mètode i fer que adopti el comportament que volem, això passa per exemple amb el cas de la classe String, ens retorna true si els dos Strings tenen el mateix valor i no si fan referència al mateix objecte. clone(): s\u0026rsquo;utilitza per realitzar una còpia de l\u0026rsquo;objecte. Veurem altres maneres de realitzar còpies.  És el mateix posar en la definició extends Object que no posar-ho.\nfinal\nA vegades, pels requisits de la nostra aplicació no ens interessa que hi pugui haver una herència en una classe, en aquests casos indicaríem mitjançant l\u0026rsquo;atribut final. Per exemple si vull que Persona sigui una classe final i que per tant no es pugui extendre ho marcaria de la següent manera:\npublic final class Persona{ ... }  El mateix passa quan apliquem final a un mètode o a un atribut.\n En el cas del mètode si en la definició posem que és final no ens permetrà en subclasses sobreescriure\u0026rsquo;l, no el podrem modificar.  package paquet.exemplefinal; public class classeOrigen { public final void mostraInfo() { System.out.println(\u0026quot;mostraInfo\u0026quot;); } } package paquet.exemplefinal; public class classeFilla extends classeOrigen { public void mostraInfo() { System.out.println(\u0026quot;mostra una altra info\u0026quot;); } }  En aquest cas donaria un error de compilació ja que intentem sobreescriure un mètode que és definit com a final en la classe pare.\n En el cas d\u0026rsquo;un atribut final un cop inicialitzat no ens permetrà tornar-lo a modificar canviant-li el valor, s\u0026rsquo;utilitza per definir constants.  public class CanviVariable { private final int enter=1; public CanviVariable(int enter){ this.enter = enter; } } public class CanviVariable2 { public static void main(String[] args){ final int enter = 0; enter = 2; } }  Els casos anteriors donarien error ja que volem canviar el valor d\u0026rsquo;una variable que s\u0026rsquo;ha declarat final i ja té valor. En canvi, el cas següent no ens donaria cap error, ja que quan creem l\u0026rsquo;objecte donem valor per primer cop a aquesta variable, això sí, no li podrem canviar el valor en l\u0026rsquo;execució de tot el programa al ser final.\npublic class CanviVariable { private final int enter; public CanviVariable(int enter){ this.enter = enter; } }  Visibilitat\nFins el moment hem observat com els atributs i mètodes públics són accessibles des de fora de la pròpia classe i els que són privats són només accessibles desde dins la pròpia classe.\nAmb l\u0026rsquo;herència apareix la visibilitat protected, que permet tenir visibilitat d\u0026rsquo;atributs i mètodes situats en:\n la mateixa classe les seves subclasses altres classes del mateix package  Com s\u0026rsquo;observa existeix l\u0026rsquo;opció default quan no indiquem cap atribut de visibilitat, les classes declarades com a default tenen accés a totes les classes del propi package.\nSobreescriptura\nMés amunt hem comentat el concepte de sobreescriptura, aquesta és una de les característiques polimòrfiques que tenim amb els llenguatges POO.\nLa sobreescriptura ens permet modificar mètodes definits en la superclasse. Per tant ens permet canviar el comportament de mètodes que ja estan definits en la classe pare.\n Quan sobreescrivim un mètode podem utilitzar la paraula @Override sobre la definició del mètode per indicar-li a Java que sobreescrivim un mètode la superclasse.\nEx, sobreescrivim el comportament que ens dóna java.lang.Object per toString():\npublic class Enter{ int valor; @Override public String toString() { return \u0026quot;El valor d'Enter és:\u0026quot; + this.valor; } }  Constructors i super\nQuan definim els mètodes constructors de les subclasses, és necessari primer cridar la constructora de la classe pare, això és possible gràcies a super() o super(parametres). Quan es crea un fill primer sempre es comença inicialitzant les variables del pare i després s\u0026rsquo;inicialitzen les del fill. Si no posem cap mètode super, per defecte intentarà buscar super() en el pare, si no existís hi hauria un error de compilació.\npublic class Persona{ String dni; public Persona(String dni){ this.dni = dni; } } public class Alumne{ int matricula; public Alumne(String dni, int matricula){ super(dni); this.matricula = matricula; } } //Error de compilació ja que la constructora Persona() com a tal no existeix public class Alumne{ int matricula; public Alumne(int matricula){ super(); this.matricula = matricula; } }  Exemple\nRealitzem un exemple de com seria una herència amb classe pare Producte i classe Filla ProducteDescompte.\npublic class Producte { protected String nom; protected double preu; public Producte(String nom, double preu) { this.nom = nom; this.preu = preu; } public void anunci() { System.out.println(\u0026quot;Hola sóc el producte \u0026quot; + nom); } public double valorProducte() { return preu; } } public class ProducteDescompte extends Producte { private int descompte; public ProducteDescompte(String nom, double preu, int descompte) { super(nom, preu); this.descompte = descompte; } @Override public void anunci() { super.anunci(); System.out.println( \u0026quot;Tinc un descompte de \u0026quot; + descompte+\u0026quot;%\u0026quot;); } @Override public double valorProducte() { return preu - (preu*descompte)/100; } public void rebaixaNouDescompte(int rebaixa){ this.descompte = this.descompte - rebaixa; } public void augmentaNouDescompte(int augment){ this.descompte = this.descompte + augment; } } public class Programa { public static void main(String[] args) { Producte p = new Producte(\u0026quot;Llapis\u0026quot;, 100.0); p.anunci(); System.out.println(\u0026quot;El preu del producte és \u0026quot; + p.valorProducte()); System.out.println(); ProducteDescompte p1 = new ProducteDescompte(\u0026quot;Llapis rebaixat\u0026quot;, 100.0, 10); p1.anunci(); System.out.println(\u0026quot;El preu d'un nou producte rebaixat és \u0026quot; + p1.valorProducte()); System.out.println(); p1.augmentaNouDescompte(10); p1.anunci(); System.out.println(\u0026quot;El preu del producte després de modificar la rebaixa és \u0026quot; + p1.valorProducte()); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/introducciodissenymodular/",
	"title": "Introducció Disseny Modular",
	"tags": [],
	"description": "",
	"content": "El paradigma de programació utilitzat fins ara ha estat el de la programació estructurada, consistent en tractar de desenvolupar programes més fiables i fàcils de mantenir mitjançant la utilització exclusiva de 3 estructures de control: la seqüencial, l\u0026rsquo;alternativa i la iterativa.\nQuan els programes comencen a créixer i es tornen difícils de resoldre en conjunt per la seva gran envergadura, la programació estructurada afavoreix la divisió del problema en parts més petites que poden ser abordades més fàcilment per separat. Es tracta del principi de \u0026ldquo;divideix i guanyaràs\u0026rdquo;.\nLa programació funcional, en el marc conceptual què estem tractant, consisteix justament en aplicar aquesta tècnica de divideix i venceràs per separar un programa en parts més senzilles, anomenades funcions.\nProgramació funcional: dividir un programa en funcions específiques dins del mateix arxiu. Programació modular: consisteix a agrupar en arxius separats un conjunt de funcions més genèriques i que guardin alguna relació entre elles amb la finalitat que puguin ser reutilitzades entre programes.\n 1. Subprogrames i mòduls El concepte de subprograma s’utilitza normalment per identificar un conjunt d’instruccions que conjuntament desenvolupen una tasca concreta i que pot ser (o no) necessària en diferents llocs del programa. El concepte de mòdul es destina normalment a identificar grans apartats d’una aplicació\n2. Accions, funcions i mètodes Els subprogrames es classifiquen en:\n  Acció és un conjunt d’instruccions amb un objectiu comú, que pot necessitar o no dades externes per a la seva execució i que NO retorna cap resultat a qui l\u0026rsquo;ha cridat.\n  Funció és un conjunt d’instruccions amb un objectiu comú, que pot necessitar o no dades externes per a la seva execució i que Retorna un resultat a qui l’ha cridat.\n  El llenguatge Java és orientat a objectes, i per tant tot s\u0026rsquo;encapsula dins de classes. En aquest context les accions i funcions s\u0026rsquo;implementen amb una estructura definida dins d\u0026rsquo;una classe i anomenada mètode.\nQuan codifiquem un mètode tindrem els següents elements:\n  Signatura o capçalera del mètode: Està composta per:\n El nom del mètode. Els arguments del mètode: ens informen de quins paràmetres obtenim per tal de poder usar dins el mètode. Si el llenguatge de programació usa tipus de dades, com Java, també ens especificarà de quin tipus de dades és cadascun d\u0026rsquo;aquests arguments. Tipus de dada que retorna el mètode: només s\u0026rsquo;especificarà si el llenguatge de programació usa tipus de dades, com Java.    Cos del mètode: Defineix l\u0026rsquo;algoritme que executarà el mètode. Dins del cos del mètode hi haurà el retorn del mètode on es posarà quina dada es retorna (si és que es retorna alguna dada).\n  Quan parlem de la crida a un mètode, ens referim a fer ús d\u0026rsquo;aquesta mètode des d\u0026rsquo;un altre mètode (ja sigui des de la mateixa classe o no).\nExemple de funció i acció Si per exemple tenim la següent funció:\npublic static int sumaFuncio(int a, int b){ int resultat; resultat = a + b; return resultat; }   La signatura és: public static int sumaFuncio(int a, int b) El nom suma Els arguments: (int a, int b) Tipus de dades que retorna int El cos són les tres instruccions de dins la funció.  Com podem comprovar l\u0026rsquo;anterior mètode es una funció ja que retorna un enter. Si volguéssim canviar aquesta funció per una acció (subprograma que no retorna cap valor) ho faríem de la següent manera:\npublic static void sumaAccio(int a, int b){ int resultat; resultat = a + b; System.out.println(resultat); }  Fixeu-vos que hem canviat int -\u0026gt; void i ara ja no retornem res, sinó que ho escrivim per pantalla.\nSi volem efectuar la crida dins el main del nostre programa faríem el següent per una funció i per una acció:\npublic static void main(String args[]){ int res = sumaFuncio(2,3); System.out.println(res); sumaAccio(2,3); }  3. Accessibilitat de les variables Les variables globals són les variables tals que el seu àmbit de validesa i disponibilitat és total, és a dir, es poden utilitzar, actualitzant-les o no, des del programa principal i des de tots els subprogrames. No és aconsellable l\u0026rsquo;ús de variables globals. Les definim just després de la declaració de la classe, per ex:\npublic class Main{ public static int variableGlobal; ...  Una variable local és aquella que està declarada dins d’un subprograma. L’àmbit d’ús de les variables locals és el subprograma en què s’han definit. L’àmbit d’existència d’una variable és la part de la classe en què la variable pot ser referenciada o s’hi pot accedir pel seu nom.\nEn Java, quan declarem una variable, aquesta és accessible només dins l\u0026rsquo;estructura on es declarada. En el cas dels arguments, només són visibles en el mètode en el qual s\u0026rsquo;usen. Posem un exemple:\npublic double m2km (double m) { double km; km = m / 1000; return km; }  En aquest cas les variables m i km només són accessibles dins del mètode m2km.\nUn altre exemple:\npublic int sumElements (int[] array) { int sum = 0; for(int i = 0; i \u0026lt; array.length; i++) sum = sum + array[i]; return sum; }  Les variables sum i array només són accessibles dins del mètode sumElements, però la variable i només és visible dins del for.\n4. Pas per valor o per referència Arguments o paràmetres Els arguments o paràmetres formals són les dades que apareixen a la signatura de la funció.\nEls paràmetres o paràmetres actuals són les dades transferides en la crida d\u0026rsquo;una funció.\nTransferència per valor o per referència:\n  En la transferència per valor, el valor del paràmetre actual es copia en una altra posició de memòria, a la qual es pot accedir pel nom del paràmetre formal. Aquesta NO ÉS la variable inicial, n\u0026rsquo;és una còpia del seu valor en una altra posició de memòria.\n  En la transferència per referència, el subprograma rep *l’adreça de memòria en què es troba el paràmetre actual, a la qual es pot accedir llavors pel nom del paràmetre formal. Per això en manipular una variable passada per referència es modifica l\u0026rsquo;original ja que actua sobre la MATEIXA posició de memòria.\n  A Java, les dades simples es passen per valor i les compostes (com els arrays o els Strings) es passen per referència.\n Exemple: Pas per valor o per referència Pas de paràmetres per valor o per referència. En aquest exemple es veu la diferència de passar un valor o de passar la referència on es troba aquest valor.\npublic class Parametres { // Paràmetres passats per valor perquè són de tipus simple public static void intercanvi(int a, int b) { System.out.println(\u0026quot;Dins del mètode intercanvi:\u0026quot;); System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); int temp = a; a = b; b = temp; System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); } // Paràmetres passats per referència perquè és de tipus compost (un objecte) public static void intercanviArray(int[] v) { System.out.println(\u0026quot;Dins del mètode intercanviArray:\u0026quot;); System.out.println(\u0026quot;v[0] = \u0026quot; + v[0]); System.out.println(\u0026quot;v[1] = \u0026quot; + v[1]); int temp = v[0]; v[0] = v[1]; v[1] = temp; System.out.println(\u0026quot;v[0] = \u0026quot; + v[0]); System.out.println(\u0026quot;v[1] = \u0026quot; + v[1]); } // Main() public static void main(String[] args) { // // Exemple de pas de paràmetres per valor // System.out.println(\u0026quot;PER VALOR\u0026quot;); int x = 5; int y = 10; System.out.println(\u0026quot;x = \u0026quot; + x); System.out.println(\u0026quot;y = \u0026quot; + y); System.out.println(\u0026quot;Cridem intercanvi(x, y)\u0026quot;); intercanvi(x, y); System.out.println(\u0026quot;Tornem del mètode intercanvi(x, y)\u0026quot;); System.out.println(\u0026quot;x = \u0026quot; + x); System.out.println(\u0026quot;y = \u0026quot; + y); System.out.println(); // // Exemple de pas de paràmetres per referència // System.out.println(\u0026quot;PER REFERÈNCIA\u0026quot;); int[] array = {25, 50}; System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(\u0026quot;Cridem intercanviArray(array)\u0026quot;); intercanviArray(array); System.out.println(\u0026quot;Tornem del mètode intercanviArray(array)\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(); // //Un altre exemple de pas per valor // System.out.println(\u0026quot;PER VALOR\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(\u0026quot;Cridem intercanvi(array[0], array[1])\u0026quot;); intercanvi(array[0], array[1]); System.out.println(\u0026quot;Tornem del mètode intercanvi(array[0], array[1])\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); } }  Observació: les cadenes (tipus String) són objectes, però són immutbales, per tant no poden canviar el seu valor\n5. Mètodes Estàtics o no estàtics Els mètodes no estàtics (o mètodes) són aquells que depenen d\u0026rsquo;un objecte i que per tant s\u0026rsquo;invoquen a partir de la instanciació d\u0026rsquo;un objecte.\n Posem un exemple, imaginem aquest mètode de la classe Conversor:\npublic double m2km (double m) { double km; km = m / 1000; return km; }  Per cridar aquesta mètode des d\u0026rsquo;un altre mètode faríem:\nConversor conv = new Conversor(); double kilometers; kilometers = conv.m2km(325012);  Els mètodes estàtics són aquells que no depenen d\u0026rsquo;un objecte i que per tant s\u0026rsquo;invoquen a partir de la classe.\n Posem un exemple, imaginem aquest mètode de la classe Arithmetic:\npublic static int sum (int a, int b) { int s; s = a + b; return s; }  Per cridar aquesta mètode des d\u0026rsquo;un altre mètode:\nint res; res = Arithmetic.suma(2,3);  Exemples Exemple1: Funció suma senzilla Realitzem la suma de dos nombres dins una funció i en retornem el resultat al programa principal:\npublic class Suma { public static void main(String[] args) { int res; int num = 25; // Exemples d'ús d'un mètode res = suma(2, 3); System.out.println(\u0026quot;suma = \u0026quot; + res); res = suma(num, 10); System.out.println(\u0026quot;suma = \u0026quot; + res); res = suma(res, num); System.out.println(\u0026quot;suma = \u0026quot; + res); } // Mètode que fa la suma de dos nombres enters public static int suma (int a, int b) { int s; s = a + b; return s; } }  Exemple2: Paràmetres del programa\npublic class ProvaArgs { /** * Imprimeix per pantalla tots els paràmetres passats en l'execució del programa * @param args Paràmetres al executar el programa */ public static void main(String[] args) { for (int i=0; i\u0026lt;args.length; i++) { System.out.println(\u0026quot;Paràmetre \u0026quot; + i + \u0026quot; = \u0026quot; + args[i]); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/1propositiblocs/",
	"title": "Introducció",
	"tags": [],
	"description": "",
	"content": "Breus definicions inicials Programació informàtica: És el procés d\u0026rsquo;escriure, provar, depurar/solucionar problemes, i mantenir el codi font de programes.\n Programa: Conjunt d\u0026rsquo;instruccions d’un llenguatge de programació, ordenades d\u0026rsquo;una manera determinada, que l’ordinador és capaç d’entendre i executar per resoldre un problema. L\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre unes normes sintàctiques i semàntiques que permeten realitzar multitud de funcions diferents.\n Instrucció: És una cadena de símbols d\u0026rsquo;un alfabet, formada d\u0026rsquo;acord amb certes regles sintàctiques que el processador (o el compilador) entén, i que finalment seran interpretades i executades pel processador.\n Llenguatge informàtic: Conjunt d\u0026rsquo;instruccions que ordenades d\u0026rsquo;una determinada manera generen un codi que l\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre per realitzar una determinada tasca.\n Dada: Unitat d\u0026rsquo;informació que utilitzen els programes informàtics per ser tractada (llegir, modificar, eliminar, crear, transformar\u0026hellip;).\n Codi font: Codi que els humans poden entendre i manipular per tal de crear i modificar els diferents programes informàtics. En Java els fitxers que contenen codi font són fitxers amb extensió .java\n Codi màquina: Una vegada el codi font és escrit pels humans es transforma en un altre fitxer (compilació) que genera un altre fitxer/codi que està a més baix nivell i que enten la màquina. En Java els fitxers convertits a codi màquina són els fitxers executables, són diferents per cada plataforma, per això diem que java és un llenguatge multiplataforma, perquè el mateix codi font el podem executar en plataformes diferents.\n Procés d\u0026rsquo;execució d\u0026rsquo;un programa Els programes informàtics donen solució a una determinada necessitat o problemàtica. A partir d\u0026rsquo;un problema determinat dissenyem un conjunt de passos determinats, ordenats i finits que ens aporta la solució (algorisme). La implementació d\u0026rsquo;aquests passos amb un llenguatge de programació genera un codi que dóna lloc al programa informàtic final.\nAixí doncs el programa té un iniciador, executa una sèrie d\u0026rsquo;instruccions que solucionen un problema determinat i existeix un punt de finalització quan es troba l\u0026rsquo;estat que soluciona el problema.\nEn aquest procés es possible que tinguem dades d\u0026rsquo;entrada (input: dades necessàries per executar un codi determinat), i també és possible que tinguem dades de sortida (output: dades que desitgem retornar o mostrar quan s\u0026rsquo;acaba l\u0026rsquo;execució del codi).\nTot el codi que hem escrit i que posem a executar l\u0026rsquo;anomenarem procés (codi en execució).\nCas particular de Java Tot seguit veiem què passa amb el programa HolaMon.java escrit en Java. És el primer programa que s\u0026rsquo;acostuma a mostrar de qualsevol llenguatge de programació. L\u0026rsquo;únic que fa aquest programa és escriure per pantalla \u0026ldquo;Hola Mundo\u0026rdquo;.\nSi us fixeu en la següent il·lustració es mostra tot el procés de compilació. Inicialment tenim el codi font del fitxer HolaMundo.java escrit pel programador. El següent pas és transformar aquest fitxer en un codi intermig que és el bytecode que permetrà ser transportat a qualsevol plataforma. Aquest codi intermig és un fitxer .class que ens assegura que el procés de compilació del fitxer .java s\u0026rsquo;ha executat correctament, en java s\u0026rsquo;utilitza la comanda javac per poder obtenir-lo. javac HolaMundo.java Amb aquesta instrucció \u0026ldquo;es compila\u0026rdquo; el programa i genera un HolaMundo.class.\nUn cop tenim el fitxer .class, executant la comanda java HolaMundo obtenim l\u0026rsquo;execucio del nostre programa sobre la plataforma on estiguem, per això en la imatge següent el codi màquina que s\u0026rsquo;executa amb Win32 serà diferent que el que interpreta MacOS ja que són SO\u0026rsquo;s diferents i obeeixen a instruccions diferents.\nEn el següent exemple es pot veure com seria un fitxer .java que es llegeix i s\u0026rsquo;enten amb llenguatge humà. A continuació, en el procés de compilació, es genera el fitxer .class, aquí ja els humans no entenem el contingut del fitxer ja que està en hexadecimal, i finalment quan executem el programa es genera un fitxer en codi màquina amb una tira de 0s i 1s que són les instruccions que necessita la CPU en cada plataforma per ser executat. Aquest últim fitxer serà diferent en cada plataforma d\u0026rsquo;execució (Linux, Windows, MacOS\u0026hellip;)\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/introducciopoo/",
	"title": "Introducció a la POO",
	"tags": [],
	"description": "",
	"content": "Com hem observat, a mesura que tenim problemes més complexes és necessari fer ús de tècniques que ens ajudin a programar d\u0026rsquo;una forma més senzilla, d\u0026rsquo;aquesta manera hem passat de la programació estructurada a la programació modular. Continuant en aquest procés ara toca fer el salt per conèixer la programació orientada a objectes (POO). Com ja hem vist dins el món de la programació hi ha una sèrie de paradigmes que repassem tot seguit.\nUn paradigma és una forma de representar i manipular el coneixement. Representa un enfocament particular o filosofia per a la construcció del programari.\n En l\u0026rsquo;apartat d' Estructura d\u0026rsquo;un programa -\u0026gt; Tipus de llenguatges s\u0026rsquo;aprofundeix en els diferents paradigmes de programació.\n1. Paradigma de Programació orientada a objectes Es fonamenta en la manera en que els éssers humans percebem i entenem els objectes del nostre món\n Exemple:\nJoan Maria Que tenen en comú el Joan i la Maria? Els dos són persones.\nMitjançant un procés de generalització sabem que els dos objectes Joan i Maria pertanyen a la mateixa classe persona.\nMitjançant aquesta abstracció identifiquem molts exemples de la mateixa plantilla. Així doncs sabem que tots aquests exemples tenen les característiques comunes d\u0026rsquo;una plantilla persona.\nAprofundim ara en els nostres exemples de Persona: Joan i Maria.\n          Atributs\n- Nom\n- Estatura\n- Pes\n- Color cabell\n- Color ulls\n- Edat\n- Sexe\n- Té un nas\nMètodes\n- Somriu\n- Parla\n- Dorm\n- Pensa\n- Menja    Atributs\n- Nom\n- Estatura\n- Pes\n- Color cabell\n- Color ulls\n- Edat\n- Sexe\n- Té un nas\nMètodes\n- Somriu\n- Parla\n- Dorm\n- Pensa\n- Menja    Com podem observar tant en Joan com la Maria tenen una sèrie de característiques comunes (atributs) i un comportament comú (mètodes) ja que els dos es poden classificar dins la mateixa categoria de persones.\nLa POO consisteix en fer servir aquesta manera natural de pensar en objectes com a mecanisme per a organitzar millor el nostre codi i poder desenvolupar, mantenir i ampliar aplicacions de software amb un alt grau de complexitat.\nCaracterístiques generals de POO Abstracció Es tracta de centrar-se en “el què fa” més que no en el “com ho fa”.\n Com hem vist en l\u0026rsquo;exemple anterior, sabem que dos objectes diferents com el Joan i la Maria tenen unes característiques i un comportament comú, d\u0026rsquo;aquí hem deduït per abstracció que formen part del mateix conjunt Persones. Així doncs l\u0026rsquo;abstracció ens permet aïllar aquella part que ens interessa del conjunt. Ex:\n No és necessari saber de mecànica de bicicletes per aprendre a anar en bicicleta. No és necessari conèixer què fan exactament les funcions del kernel de linux per usar-les. No ens cal conèixer en profunditat com funciona el rentaplats per usar-lo. Tots els exemples anteriors són casos en els que fem ús d\u0026rsquo;un instrument sense coneixer-lo a fons.  De fet, ja hem fet ús de l\u0026rsquo;abstracció en la UF2. Les accions i funcions que heu creat encapsulen línies de codi, quan fem crides a aquestes funcions s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions definides dins aquests blocs. De la mateixa manera quan definiu els mòduls/classes podeu crear funcions privades que utilitzeu pel funcionament del vostre programa però que NO seran accessibles des del programa principal.\nIgual com ja hem vist en la UF2, l\u0026rsquo;abstracció permet que qualsevol objecte el poguem reutilitzar en qualsevol situació. Per exemple, l\u0026rsquo;objecte cotxe vist anteriorment el podem fer servir en una aplicació de carreres però també per a una altra de mobilitat sostenible. El que tenen en comú és que identifiquem el mateix objecte en ambdues aplicacions(característiques i comportament).\nEncapsulament Es refereix a l\u0026rsquo;ocultació d\u0026rsquo;informació de forma que les dades internes d\u0026rsquo;un objecte són ocultes al món exterior, tal sols sabem què podem fer amb ell.\n Per exemple, quan escrivim per pantalla amb el mètode “sc.nextInt()”, sols sabem que ens retorna un enter però no sabem com és la implementació d\u0026rsquo;aquest mètode per dins, ni tampoc coneixem les seves variables internes.\nModularitat es refereix a la forma en que els elements es POO es troben organitzats en mòduls (paquets en Java) facilitant l\u0026rsquo;encapsulació i abstracció de la informació.\n Jerarquia S\u0026rsquo;ordenen els objectes de forma que s\u0026rsquo;estableixen relacions entre ells. Serveix per especificar aquelles característiques d\u0026rsquo;un objecte necessàries per la nostra aplicació.\n La jerarquia s\u0026rsquo;estableix mitjançant herència. Per exemple, podem definir objectes vehicle (amb matrícula, cavalls, etc..) i també objectes camions que hereten les característiques de vehicle i n\u0026rsquo;afegeixen d\u0026rsquo;altres (pes màxim, etc\u0026hellip;).\nPolimorfisme Defineix la possibilitat de tenir mètodes iguals però amb implementacions diferents segons de l\u0026rsquo;objecte que la faci servir.\n Un bon exemple de polimorfisme és l\u0026rsquo;operador +. Si l\u0026rsquo;apliquem a dos enters ens retorna la suma d\u0026rsquo;aquests, mentre que si l\u0026rsquo;apliquem a dos strings ens els concatena, per tant, donat el mateix operador, el comportament és diferent, és un element sobrecarregat i que adopta diferent funció depenent dels tipus que el rodegen. En POO passa el mateix, podem tenir un mètode que faci una funció diferent depenent de quin objecte l\u0026rsquo;implementa.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arraybidimensional/",
	"title": "Arrays Bidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays bidimensional: és una estructura d\u0026rsquo;array de dues dimensions. També s\u0026rsquo;entén com un vector de vectors. Es coneix amb el nom de matriu. És una col·lecció d\u0026rsquo;elements del mateix tipus disposats en dues dimensions.\n En aquest cas al tenir dues dimensions en forma de taula, la primera dimensió ens indica les files i la segona les columnes.\nDeclaració A l\u0026rsquo;igual que amb els arrays unidimensionals existeix la part de declarar una referència a la matriu i tot seguit quan cridem el new reservem en memòria l\u0026rsquo;espai on allotjar la informació.\nEn l\u0026rsquo;exemple següent creem una matriu d\u0026rsquo;enters que l\u0026rsquo;anomenem balances de 11 x 6 posicions guardem en memòria 66 enters de forma consecutiva i ordenats per files i columnes.\nPer tal d\u0026rsquo;accedir a un element cal indicar ara dos índexs, un per les files i un per les columnes, si per exemple volgués accedir a l\u0026rsquo;element situat a la 4 fila i 5a columna ho faríem amb balances[3][4]\nint[][] balances = new int[11][6]; int valor = balances[3][4];  Una altra forma de declarar una matriu és amb els valors directament igual com ja havíem vist en l\u0026rsquo;array unidimensional. Per exemple, la següent matriu conté 3 files i 2 columnes:\nint[][] matriu = {13,25},{34,78},{0,-3}};  S\u0026rsquo;observen 3 files i cadascuna conté els valors entre {}, les files entre sí estan separades per una coma.\nLongitud Al igual que els vectors les matrius també poden fer ús de l\u0026rsquo;atribut length. El que passa que si provem d\u0026rsquo;imprimir matriu.length observarem que mostra el total de files que conté la matriu. Java organitza la informació com un vector de vectors, així que si volem saber el length d\u0026rsquo;una columna cal que fem el següent matriu[i].length.\nFuncionalitat    Funcionalitat Sintaxi Exemples     Declaració d\u0026rsquo;un array 2D tipus[][] nom; int[][] matriu1; double[][] matriu2;   Creació d\u0026rsquo;un array de n files i m columnes nom = new tipus[n][m]; matriu1 = new int [3][2]; matriu2 = new double[5][5];   Declaració d\u0026rsquo;un array 2D inicialitzat tipus[][] nom ={{elem01,\u0026hellip;,elem0n},{elem11,\u0026hellip;,elem1n},\u0026hellip;,{elemm1,\u0026hellip;,elemmn}} int[][] matriu1={{13,25},{34,78},{0,-3}};   Accés a l\u0026rsquo;element de la fila i i columna j nom[i][j] int a = matriu1[1][0];\ndouble m = matriu2[5][8];    Recorregut Per fer un recorregut d\u0026rsquo;un array bidimensional o matriu utilitzarem 2 bucles anidats. Això ens permetrà tenir dos índexos, un per les files i un per les columnes. Per exemple:\nint rows = 10; int cols = 10; int[][] myArray = new int[rows][cols]; for (int i = 0; i \u0026lt; rows; i++){ for (int j = 0; j \u0026lt; cols; j++){ myArray[i][j] = 0; } }  Cerca De la mateixa manera que treballàvem la cerca d\u0026rsquo;un element dins un vector, en les matrius funciona igual, només que ara toca realitzar la cerca en dos bucles anidats. En aquest cas, quan es troba l\u0026rsquo;element (si es troba) cal sortir dels dos bucles.\nEn el següent exemple busquem el 0 dins una matriu de nombres aleatoris:\nboolean trobat=false; int matriu[][] = new int[10][12]; //Introduim valors aleatoris for (int i = 0; i \u0026lt; matriu.length; i++){ for(int j = 0; j \u0026lt; matriu[i].length; j++){ matriu[i][j] = (int) (Math.random() * 100); } } for (int i = 0; i \u0026lt; matriu.length \u0026amp;\u0026amp; !trobat; i++){ for(int j = 0; j \u0026lt; matriu[i].length \u0026amp;\u0026amp; !trobat; j++){ if( matriu[i][j]==0) trobat=true; } } String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Exemple Busquem l\u0026rsquo;element màxim i mínim d\u0026rsquo;una matriu:\nint max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; //RECORREM FILES for(int i=0; i\u0026lt;matriu.length;i++) { //RECORREM COLUMNES for (int j = 0; j \u0026lt; matriu[i].length; j++) { //BUSQUEM ELEMENT MES GRAN i MES PETIT if(matriu[i][j] \u0026gt; max) max = matriu[i][j]; if(matriu[i][j] \u0026lt; min) min = matriu[i][j]; } } System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;MAX: \u0026quot;+max); System.out.println(\u0026quot;MIN: \u0026quot;+min);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/coleccions/2hashset/",
	"title": "HashSet",
	"tags": [],
	"description": "",
	"content": " HashSet: és un conjunt d\u0026rsquo;elements en els quals no hi trobem cap element repetit (Set) i que no existeix un ordre en l\u0026rsquo;inserció de nous elements.\n La definició de la classe ArrayList java.util.HashSet i de totes les seves funcionalitats la trobareu a: Java Oracle Classe HashSet\nConsiderem que un element està repetit si tenim dos objectes o1 i o2 iguals, comparant-los mitjançant l\u0026rsquo;operador o1.equals(o2). D\u0026rsquo;aquesta manera, si l\u0026rsquo;objecte a inserir en el conjunt estigués repetit, no ens deixaria inserir-lo i el mètode add retornaria false. Un conjunt pot contenir com a màxim un element null.\nEls objectes s\u0026rsquo;emmagatzemen en una taula de dispersió (hash). El cost de les operacions bàsiques (inserció, esborrat, recerca) es realitzen en temps constant sempre que els elements s\u0026rsquo;hagin dispersat de forma adequada. La iteració a través dels seus elements és més costosa, ja que necessitarà recórrer totes les entrades de la taula de dispersió, el que farà que el cost estigui en funció tant del nombre d\u0026rsquo;elements inserits en el conjunt com de el nombre d\u0026rsquo;entrades de la taula. L\u0026rsquo;ordre d\u0026rsquo;iteració pot ser diferent de l\u0026rsquo;ordre en què es van inserir els elements.\nDeclaració\nEn la declaració indicarem de quin tipus són els elements del Set \u0026lt;\u0026gt;. Per exemple per declarar un HashSet d\u0026rsquo;enters:\nHashSet\u0026lt;Integer\u0026gt; conjuntEnters = new HashSet();  Funcionalitats principals\nEn l\u0026rsquo;exemple s\u0026rsquo;observa la manipulació d\u0026rsquo;un HashSet primer per enters i després per un set d\u0026rsquo;objectes Alumne:\nimport java.util.*; public class ExHashSet { public static void main(String[] args) { // HashSet de String // Creem el HashSet HashSet\u0026lt;String\u0026gt; hS = new HashSet\u0026lt;String\u0026gt;(); // Afegim elements hS.add(\u0026quot;Element 9\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 7\u0026quot;); hS.add(\u0026quot;Element 4\u0026quot;); hS.add(\u0026quot;Element 5\u0026quot;); hS.add(\u0026quot;Element 6\u0026quot;); hS.add(\u0026quot;Element 3\u0026quot;); hS.add(\u0026quot;Element 8\u0026quot;); hS.add(\u0026quot;Element 1\u0026quot;); // Intentem afegir Elements repetits hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); if (!hS.add(\u0026quot;Element 2\u0026quot;)) System.out.println(\u0026quot;Element 2 nomes s'afegeix una sola vegada\u0026quot;); System.out.println(); // Recorregut usant la classe Iterator System.out.println(\u0026quot;Realitzem un recorregut mitjançant iterator\u0026quot;); Iterator\u0026lt;String\u0026gt; it = hS.iterator(); while (it.hasNext()) System.out.println((String)it.next()); System.out.println(); // Eliminar un element if (!hS.remove(\u0026quot;Element 25\u0026quot;)) System.out.println(\u0026quot;Si intento esborrar un objecte que no existeix em retorna false!!!\u0026quot;); System.out.println(); System.out.println(\u0026quot;Esborrem un element existent: Element 3, i mostrem com queda el HashSet\u0026quot;); hS.remove(\u0026quot;Element 3\u0026quot;); System.out.println(hS); System.out.println(); System.out.println(); //Ordenació mitjançant TreeSet System.out.println(\u0026quot;Ordenem mitjançant un TreeSet\u0026quot;); TreeSet myTreeSet = new TreeSet(); myTreeSet.addAll(hS); System.out.println(myTreeSet); //Objectes ALUMNE // ArrayList d' objectes Alumne System.out.println(\u0026quot;\\nHASHSET ALUMNES\u0026quot;); HashSet\u0026lt;Alumne\u0026gt; alumnes = new HashSet\u0026lt;Alumne\u0026gt;(); // Afegir elements System.out.println(\u0026quot;Mostrem els alumnes\u0026quot;); alumnes.add(new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;)); alumnes.add(new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;)); Alumne al = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); alumnes.add(al); alumnes.add(new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;)); alumnes.add(new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;)); // Recorregut usant la classe Iterator System.out.println(\u0026quot;\\nRealitzem un recorregut mitjançant iterator\u0026quot;); Iterator its = alumnes.iterator(); while (its.hasNext()) System.out.println(its.next()); //ORDENAR HASHSET USANT TREESET System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeSet per NOM\u0026quot;); TreeSet treeNom = new TreeSet(Alumne.alumnesCompararPerNom); treeNom.addAll(alumnes); its = treeNom.iterator(); while (its.hasNext()) System.out.println(its.next()); System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeSet per COGNOM\u0026quot;); TreeSet treeCognom = new TreeSet(Alumne.alumnesCompararPerCognom); treeCognom.addAll(alumnes); its = treeCognom.iterator(); while (its.hasNext()) System.out.println(its.next()); System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeSet per EDAT\u0026quot;); TreeSet treeEdat = new TreeSet(Alumne.alumnesCompararPerEdat); treeEdat.addAll(alumnes); its = treeEdat.iterator(); while (its.hasNext()) System.out.println(its.next()); // Comprovar si conté un objecte System.out.println(\u0026quot;\\nComprovem si conté un element Alumne \\\u0026quot;al\\\u0026quot;\u0026quot;); if (alumnes.contains(al)) { System.out.println(\u0026quot;Existeix l'alumne buscat\u0026quot;+al); } //Eliminem i recorregut System.out.println(\u0026quot;\\nEliminem l'element 'al'\u0026quot;); alumnes.remove(al); System.out.println(alumnes); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/metodologiatopdown/",
	"title": "Metodologia Top Down",
	"tags": [],
	"description": "",
	"content": "Metodologia Top Down: L\u0026rsquo;aplicació de la programació funcional en el desenvolupament d\u0026rsquo;un programa, dóna lloc a 2 tipus de fluxos de disseny oposats:\n  Disseny Top-Down: consisteix a resoldre un problema complex dividint successivament en parts cada vegada més elementals fins que siguin fàcilment abordables per separat. Normalment s\u0026rsquo;aplica a la fase de disseny.\n  Disseny Bottom-Up: consisteix en partir de blocs (funions) elementals i anar unint-los per aconseguir resoldre un problema. Normalment s\u0026rsquo;aplica a la fase d\u0026rsquo;implementació.\n  Entre els múltiples avantatges de la programació funcional, es poden citar:\n Afavoreix la reutilització del codi. Permet una completa divisió de tasques entre els programadors. Facilita el manteniment i l\u0026rsquo;escalabilitat dels programes. Facilita la depuració i la verificació. Es complementa perfectament amb la programació estructurada. de fet normalment s\u0026rsquo;utilitzen juntes. Facilita el disseny descendent (top-down) i la filosofia divideix i guanyaràs, disminuint la complexitat dels programes. Millora la productivitat.  Exemple3: Programa amb diferents funcionalitats\nimport java.util.Arrays; import java.util.Scanner; public class Activitats { //Métode que retorna el màxim de 2 nombres. Retorna num1 si són iguals public static int maxim (int num1, int num2){ if(num1\u0026gt;=num2) return num1; else return num2; } //Métode que retorna el mínim de 2 nombres. Retorna num2 si són iguals public static int min (int num1, int num2){ if(num1\u0026gt;=num2)return num2; else return num1; } //Métode que donats 3 nombres, retorna una llista ordenada ascendent public static int[] ordena (int num1, int num2, int num3){ int[] llista = {num1,num2,num3}; Arrays.sort(llista); return llista;\t} //Métode que retorna el màxim de 3 nombres. public static int maxim3 (int num1, int num2, int num3){ int [] llista = ordena(num1, num2, num3); return llista[2]; } //Métode que retorna el mínim de 3 nombres. public static int min3 (int num1, int num2,int num3){ int [] llista = ordena(num1, num2, num3); return llista[0]; } //Métode que retorna el valor màxim d'una matriu. public static int minimMatriu (int[][] mat){ int files = mat.length; int columnes = mat[0].length; int maxim = 0; for(int i=0; i\u0026lt;files;i++){ for(int j=0; j\u0026lt;columnes;j++){ if(mat[i][j] \u0026gt; maxim)maxim = mat[i][j]; //maxim = maxim(maxim, mat[i][j]); } } return maxim; } //Métode que permet crear una matriu amb nombres aleatoris public static int[][] creaMatriu (){ int files = 3; int columnes = 3; int[][] matriu = new int[files][columnes]; for (int i = 0; i \u0026lt;files ; i++) { System.out.println(\u0026quot;\u0026quot;); for (int j = 0; j \u0026lt; columnes; j++) { matriu[i][j] = (int)(Math.random()*100); System.out.print(matriu[i][j] + \u0026quot; \u0026quot;); } } System.out.println(\u0026quot;\\n\u0026quot;); return matriu; } public static void main (String[] args){ Scanner sc = new Scanner(System.in); int opcio = 9; int num1, num2, num3; while(opcio!=0){ System.out.println(\u0026quot;\\n\\n\\n---Tria una opció---\\n\u0026quot;); System.out.println(\u0026quot;1. Màxim de dos nombres\u0026quot;); System.out.println(\u0026quot;2. Mínim de dos nombres\u0026quot;); System.out.println(\u0026quot;3. Màxim de tres nombres\u0026quot;); System.out.println(\u0026quot;4. Mínim de tres nombres\u0026quot;); System.out.println(\u0026quot;5. Ordena de forma ascendent tres nombres\u0026quot;); System.out.println(\u0026quot;6. Màxim valor d'una matriu\u0026quot;); System.out.println(\u0026quot;0. Sortir\\n\u0026quot;); System.out.println(\u0026quot;---Tria una opció---\\n\u0026quot;); opcio = sc.nextInt(); switch(opcio){ case 1: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;El màxim és: \u0026quot;+ maxim(num1,num2)); break; case 2: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;El mínim és: \u0026quot;+ min(num1,num2)); break; case 3: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix tercer valor\u0026quot;); num3 = sc.nextInt(); System.out.println(\u0026quot;El màxim és: \u0026quot;+ maxim3(num1,num2, num3)); break; case 4: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix tercer valor\u0026quot;); num3 = sc.nextInt(); System.out.println(\u0026quot;El mínim és: \u0026quot;+ min3(num1,num2, num3)); break; case 5: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix tercer valor\u0026quot;); num3 = sc.nextInt(); int[] llista = ordena(num1,num2,num3); System.out.print(\u0026quot;L'ordre ascendent dels tres valors és:\u0026quot;); for(int i=0; i\u0026lt;llista.length; i++){ System.out.print(llista[i]+\u0026quot; \u0026quot;);\t} break; case 6: System.out.println(\u0026quot;Aquesta és la matriu:\u0026quot;); int maxim = minimMatriu(creaMatriu()); System.out.println(\u0026quot;El màxim valor de la matriu és: \u0026quot;+ maxim); break; case 0: System.out.println(\u0026quot;Programa finalitzat\u0026quot;); break; } } sc.close(); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/programacioavancadapoo/2polimorfismeclassesabstractes/",
	"title": "Polimorfisme i classes abstractes",
	"tags": [],
	"description": "",
	"content": "Polimorfisme i conceptes Polimorfisme (Polimorphism) és l\u0026rsquo;habilitat que té un mètode de proveïr un comportament determinat en funció de l\u0026rsquo;escala que ocupi en l\u0026rsquo;arbre jeràrquic. El mateix mètode dins una herència es pot comportar de diferent manera ja que té la capacitat de canviar el seu comportament gràcies a la sobreescriptura.\n Sobreescriptura (Overriding). Principalment és la idea de re-implementar en la classe filla el mètode de la classe pare per tal d\u0026rsquo;adaptar o modificar-ne el comportament. S\u0026rsquo;entén amb la idea d\u0026rsquo;especificar el comportament de la classe pare en el fill.\n public class Persona { public void saluda(){ System.out.println(\u0026quot;Hola soc una persona\u0026quot;); } } public class Alumne extends Persona { public void saluda(){ System.out.println(super.saluda() + \u0026quot; i també sóc un alumne\u0026quot;); } }  Els mètodes toString, equals, són exemples de mètodes que sobreescrivim amb la idea de que adoptin un comportament diferent a com estan definits en java.lang.Object.\nSobrecàrrega. En aquest cas es parla de polimorfisme estàtic ja que definim el mateix mètode però amb paràmetres d\u0026rsquo;entrada diferents. De forma que el mateix mètode(amb diferents paràmetres) pot tenir un comportament diferent en la mateixa classe.\n Per exemple ens podríem trobar la sobrecàrrega en els constructors (poder construir un mateix objecte a partir de passar-li paràmetres diferents)\npublic Persona (){ this.nom = \u0026quot;desconegut\u0026quot;; this.edat = -1; } public Persona (String nom){ this.nom = nom; this.edat = -1; } public Persona (String nom, int edat){ this.nom = nom; this.edat = edat; }  Classes abstractes Classes abstractes (Abstract class). Quan definim una classe abstracta indiquem a Java que NO VOLEM instanciar/crear objectes concrets d\u0026rsquo;aquesta classe. Segurament ens servirà com a template per tal d\u0026rsquo;adoptar un comportament comú i extendre-la a una sèrie de fills que SÍ tenen sentit. El mateix és aplicable als mètodes, un mètode abstract és només la signatura del mètode sense implementació i s\u0026rsquo;extendrà en les seves subclasses.\n public abstract class Vehicle { protected int preu=-1; public Vehicle(){} public int getPreu (int preu){ return preu; } public void setPreu (int preu){ this.preu += preu; } public abstract int factura(int dies); } public class Cotxe extends Vehicle{ protected int preu=25; public Cotxe(){ super(); } public int factura(int dies){ return dies * preu; } } public class Moto extends Vehicle{ protected int preu=10; public Moto(){ super(); } public int factura(int dies){ if(dies\u0026gt;10) return dies * preu; else return 0; } } public class Caravana extends Vehicle{ protected int preu=40; public Caravana(){ super(); } public int factura(int dies){ return (dies * preu) / 2; } } .... public static void main (String[] params){ Cotxe cotxe = new Cotxe(); Moto moto = new Moto(); Caravana caravana = new Caravana(); cotxe.factura(10); moto.factura(10); caravana.factura(10); ... } //També podria tenir public static void main (String[] params){ Vehicle cotxe = new Cotxe(); Vehicle moto = new Moto(); Vehicle caravana = new Caravana(); }  Amb l\u0026rsquo;exemple anterior, si modelitzem un parking, cada vehicle pagarà una factura diferent en funció al vehicle que tingui. Ens interessa tenir una classe principal Vehicle, la qual no tindrà implementació i que serveix per definir un mètode factura abstracte que hauran d\u0026rsquo;implementar-se en totes les subclasses. Volem aplicar diferent comportament en funció a cada vehicle per això definim el mètode de pagament factura(int dies) dins les subclasses. En aquest exemple Vehicle no tindria sentit com a instància de classe però sí que serveix per establir QUÈ han de tenir els Vehicles del nostre model implementat obligatòriament.\nElun mètode abstracte factura(int dies) de Vehicle no té implementació i obligatòriament cal implementar-lo en les classes concretes filles que tingui Vehicle. Això ens permet establir condicionants a la factura EN FUNCIÓ de cada Vehicle, per exemple si és una Moto i aparca menys de 10 dies no paga, si és una Caravana pagarà la meitat, etc.\nUna classe abstracta pot contenir mètodes concrets implementats, com getPreu o setPreu en l\u0026rsquo;exemple, ** i mètodes abstractes** com factura.\n El que ens indica que una classe sigui abstracta és que no podem crear objectes/instàncies d'aquesta classe. S\u0026rsquo;ha d\u0026rsquo;instanciar a partir dels seus fills. El que ens indica que un mètode sigui abstracte és que no té implementació definida. Els mètodes abstractes només tenen sentit dins de classes abstractes. Serveixen per indicar que tots els fills concrets han d\u0026rsquo;implementar aquest mètode.  Aquesta unificació de criteris fa que sigui molt fàcil extendre el model i incorporar de forma fàcil nous Vehicles: Camions, Bicicletes o Patinets, només ens cal pensar quins són els mètodes abstractes que necessitem tenir per incorporar i implementar-los, en el cas anterior només cal el mètode factura(). Molts cops es fa necessari tenir tots els vehicles dins un array per a que facin una determinada acció, posem per cas l\u0026rsquo;exemple anterior i fem que tots els vehicles paguin la factura de cop:\npublic static void main (String[] params){ Cotxe cotxe1 = new Cotxe(); Moto moto1 = new Moto(); Caravana caravana2 = new Caravana(); ArrayList\u0026lt;Vehicle\u0026gt; vehicles = new ArrayList(); vehicles.add(cotxe1); vehicles.add(moto1); vehicles.add(caravana2); for(Vehicle v : vehicles){ v.factura(10); System.out.println(\u0026quot;El vehicle \u0026quot;+ v.getClass()+\u0026quot; li toca pagar per 10 dies: \u0026quot; + v.factura(10)+\u0026quot; euros.\u0026quot;); } } ... }  Resumint:\n Una classe abstracta no s\u0026rsquo;instancia, sinó que només ho poden fer les seves subclasses i els anomenarem classes concretes. Una classe abstracta pot tenir mètodes abstractes i implementats dins la mateixa classe. Un mètode abstracte no té implementació i obliga que les subclasses l\u0026rsquo;implementin. Podríem tenir una classe abstracta amb tots els mètodes implementats, però en canvi, si un mètode és abstracte obliga que la classe també ho sigui. No podem tenir un mètode estàtic i abstracte ja que el podríem usar sense necessitat de crear un objecte, i ja sabem que un mètode abstracte no té implementació. Podríem tenir una jerarquia de classes abstractes. Una classe abstracta que a la vegada la subclasse sigui abstracta. L\u0026rsquo;únic requisit és que les classes concretes implementin TOTS els mètodes abstractes de totes les classes abstractes.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/sequencial/",
	"title": "Estructura seqüencial",
	"tags": [],
	"description": "",
	"content": "Estructura seqüencial En l\u0026rsquo;estructura seqüencial permet descomposar un problema en instruccions que s\u0026rsquo;executaran de la primera a la última seguint un ordre de forma incondicional.\n L' assignació consisteix en donar un valor a una variable. \u0026ldquo;Guardar\u0026rdquo; una informació en una variable, que segurament serà tractada i/o consultada més endavant.\n    Codi Diagrama de flux     Acció1;\nAcció2;\nAcció3;\nAcció4;     Estructura bàsica L\u0026rsquo;estructura bàsica de qualsevol programa en Java anirà dins una \u0026ldquo;classe\u0026rdquo; amb un fitxer .java, amb la següent plantilla:\npublic class Main { public static void main(String[] args) { } }  Java executarà tot el que trobi dins les claus del main anterior.\nComentaris Tot el que es posa entre comentaris serveix per documentar el codi en cas que sigui necessari i Java ho interpreta com a comentaris i no ho executa com si fossin instruccions. Existeixen comentaris per:\n Una fila. En aquest cas utilitzarem \u0026ldquo;// Comentari\u0026rdquo; Més d\u0026rsquo;una fila, el comentari anirà entre \u0026ldquo;/* Comentari vàries línies */\u0026rdquo;  public class Main { public static void main(String[] args) { //Comentari d'una sola línia /* Comentari de més d'una línia */ } }  Inputs Per tal d\u0026rsquo;introduir valors al nostre programa (inputs), inicialment, farem servir la classe Scanner, cal declarar-la a dalt del programa i crear un objecte Scanner, per exemple li direm sc. Aquest objecte ens permetrà introduir informació pel teclat.\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enter32bits = sc.nextInt(); long enter64bits = sc.nextLong(); float decimal = sc.nextFloat(); double decimalGran = sc.nextDouble(); boolean boolea = sc.nextBoolean(); String cadenaCaracters = sc.next(); String cadenaCaractersFinalLinia = sc.nextLine(); } }  Outputs Per tal de treure valors per la línia de comandes (outputs) el que farem serà usar System.out.print i si volem un salt de línia System.out.println\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Pots escriure el teu nom per línia de comandes?\u0026quot;); String nom = sc.nextLine(); System.out.print(\u0026quot;Hola! \u0026quot;); System.out.print(\u0026quot;El meu nom és \u0026quot; + nom); } }  Exemples  Llegeix dos nombres reals i escriu la seva suma, resta, producte i quocient.  float operand1 = sc.nextFloat(); float operand2 = sc.nextFloat(); float suma = operand1 + operand2; float resta = operand1 - operand2; float multiplicacio = operand1 * operand2; float divisio = operand1 / operand2; float modul = operand1 % operand2;  Llegeix el preu d\u0026rsquo;un producte, l\u0026rsquo;IVA (en %) i el descompte (en %) a aplicar. Escriu el preu final del producte.  float preu = sc.nextFloat(); int iva = sc.nextInt(); int descompte = sc.nextInt(); float preuAmbIva = preu + preu * iva / 100; float preuAmbIvaIDescompte = preuAmbIva - preuAmbIva * descompte / 100; System.out.println(\u0026quot;Preu final:\u0026quot; + preuAmbIvaIDescompte);  Calcula l\u0026rsquo;àrea lateral i el volum d\u0026rsquo;un cilindre recte, introduint per teclat els valors del radi i l\u0026rsquo;altura. V =pi⋅r2⋅h AL=2⋅pi⋅r⋅h  float radi = sc.nextFloat(); float altura = sc.nextFloat(); double areaLateral = 2 * Math.PI * radi * altura; double volum = Math.PI * Math.pow(radi,2) * altura; System.out.println(\u0026quot;Area lateral:\u0026quot; + areaLateral + \u0026quot; Volum:\u0026quot; + volum);  Llegeix un nombre enter no negatiu i un altre nombre enter no negatiu que indica la posició de les seves xifres i escriu la xifra que ocupa aquesta posició. Les unitats estan a la posició 1, les desenes a la posició 2, etc.  int nombre = sc.nextInt(); int posicio = sc.nextInt(); double potencia = Math.pow(10,posicio-1); double nombreRetallat = nombre / potencia; int nombreBuscat = (int)nombreRetallat % 10; System.out.println(\u0026quot;el dígit \u0026quot; +posicio+ \u0026quot; del nombre \u0026quot; + nombre + \u0026quot; és: \u0026quot;+ nombreBuscat);  Llegeix un nombre enter de segons i escriu el nombre d’hores, minuts i segons equivalents en format h:m:s.  int segonsTotals = sc.nextInt(); int hores = segonsTotals / 3600; int segonsRestants = segonsTotals % 3600; int minuts = segonsRestants / 60; int segons = segonsRestants % 60; System.out.println(hores + \u0026quot;:\u0026quot; + minuts + \u0026quot;:\u0026quot; + segons);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/implementaciopoo/",
	"title": "Implementació bàsica de POO",
	"tags": [],
	"description": "",
	"content": "Definicions          Classe\n Una classe és la definició d\u0026rsquo;un objecte real.\nÉs l\u0026rsquo;element que descriu els components d\u0026rsquo;un objecte de manera general. En ell hi queden especificats quines característiques té l\u0026rsquo;objecte (atributs) i quines accions pot realitzar (mètodes). És la plantilla que ens servirà per crear objectes.   Objecte\n Un objecte és una instància d\u0026rsquo;una classe. Diem que hem creat o instanciat un objecte quan donem valors i fem servir els components definits a la classe.   Atribut\n Un atribut és una característica concreta d\u0026rsquo;un objecte. Es defineix com les variables del programes estructurats, és a dir, definint tipus de dades i nom.   Mètode\n Els mètodes defineixen quines funcionalitats o accions pot realitzar la classe. Reflecteixen les operacions que es poden fer sobre els atributs.    Exemple Un exemple podria ser una classe jugadorFutbol que tingués:\n atributs: nom, edat, pes, posició, nacionalitat, etc. mètodes: marcaGols, esLesiona, protestaArbitre, canviaPosicio, etc.  I amb aquesta classe jugadorFutbol definida podríem tenir diferents jugadors, per tant hi instanciaríem diferents objectes:\n Leo Messi, 33 anys, 65kg, davanter, argentí. Andres Iniesta, 36 anys, 67kg, centrecampista, espanyol.   Intanciem la primera classe Definirem la classe Persona i un mètode que ens faci saludar aquesta persona mostrant un missatge per pantalla.\npackage exemple1.versio1; public class Persona { public void saluda() { System.out.println(\u0026quot;Hola, sóc una persona\u0026quot;); } }  Observacions:\n A la línia 1 tenim la declaració del package. Per conveni, el nom dels packages s\u0026rsquo;ha d\u0026rsquo;escriure en minúscules. A la línia 3 tenim la declaració de la classe. La paraula reservada public serveix per especificar l’àmbit (o accés o visibilitat) de la classe. De moment, totes les classes seran públiques. Fixeu-vos que la primera lletra és majúscula i la resta del nom de la classe en minúscula. A la línia 5 tenim la declaració del mètode. És un mètode públic això ens indica que té visibilitat en altres classes i per tant pot ser cridat des d\u0026rsquo;elles. També s\u0026rsquo;observa que la signatura del mètode no porta la paraula static, això voldrà dir que si es vol cridar aquest mètode necessitarem abans crear una instància de Persona.  Recordem que la JVM busca en la classe que executem un mètode main com a punt d\u0026rsquo;inici de l\u0026rsquo;execució, en la classe Persona no hi és, si proveu d\u0026rsquo;executar-lo el compilador de Java retorna un error conforme no ha trobat un mètode main. Cal doncs que definim aquest mètode main ja sigui a la pròpia classe Persona o una altra classe. En l\u0026rsquo;exemple següent s\u0026rsquo;ha generat una classe nova per testejar Persona capaç de crear-ne una instància i cridar al mètode saluda.\npackage exemple1.versio1; public class PersonaTest { public static void main(String[] args) { Persona persona = new Persona(); persona.saluda(); } }  Observacions:\n A diferència del mètode saluda, el mètode main de PersonaTest és static, això vol dir que no necessita de la instància de la classe PersonaTest per ser cridat. En la línia 6 es crea un objecte nou de la classe Persona, aquest objecte és instanciat en una variable que s\u0026rsquo;anomena persona. El tipus de persona és Persona que ara mateix no té cap atribut i només conté un mètode capaç de saludar. El mètode Persona() que es crida quan s\u0026rsquo;instancia l\u0026rsquo;objecte s\u0026rsquo;anomena constructor i el veurem més endavant. A continuació, com que ja tenim un objecte instanciat de Persona, ja podem cridar tots aquells mètodes no-statics que tingui aquesta persona, com per exemple saluda.  Crida amb paràmetres Efectuem un petit canvi a l\u0026rsquo;activitat anterior i definim el mètode saluda amb un paràmetre d\u0026rsquo;entrada que simbolitzi el nom de la persona i que demanarem per teclat en PersonaTest. Les dues classes quedarien de la següent manera:\npackage exemple1.versio2; public class Persona { public void saluda(String nom) { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom); } }  package exemple1.versio2; import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona que saluda: \u0026quot;); String nomPersona = sc.nextLine(); Persona persona = new Persona(); persona.saluda(nomPersona); } }  Sobre les classes utilitzades en PersonaTest:\n Usem Scanner, per això l\u0026rsquo;importem, ja que sinó no el tindríem visible. També estem cridant String i System, les dues pertanyents al paquet java.lang. Java ja les ha incorporades implícitament per això les podem usar sense declarar-ne l\u0026rsquo;import. Finalment estem creant objectes de la classe Persona. Com que PersonaTest i Persona es troben en el mateix directori, que correspon al mateix package, ja és visible i no cal importar-la tampoc.  Variables d\u0026rsquo;instància (atributs de classe) Com ja hem vist en la UF2 les variables locals es declaren dins un àmbit de visibilitat, ja sigui dins un mètode o d\u0026rsquo;una determinada estructura de control (while/for), estan actives dins aquest àmbit, després desapareixen.\nDins de cada classe hi ha les anomenades variables d\u0026rsquo;instància o atributs de la classe. Aquests poden ser instanciats en la creació de l\u0026rsquo;objecte i estan actius durant la vida d\u0026rsquo;aquest objecte. Cada objecte de la classe manté una còpia d\u0026rsquo;aquests camps amb els seus respectius valors.\nGetters \u0026amp; Setters En la definició de qualsevol classe existeixen uns mètodes particulars que ens ajuden a interactuar amb els atributs dins la classe:\n Getters: són mètodes que ens permeten accedir al contingut d\u0026rsquo;una variable d\u0026rsquo;instància. Setters: són mètodes que ens permeten modificar el contingut d\u0026rsquo;una variable d\u0026rsquo;instància.  Les classes en Java estan estructurades sota el principi d\u0026rsquo;encapsulació. Declarant les variables d\u0026rsquo;instància com a privades (podríem haver-les fet públiques) encapsulem (amaguem) la variable. Així, aquesta variable sols es pot modificar des del nostre mètode setNomVariable (setter). Evitem modificacions accidentals des de qualsevol lloc del programa.\nAixí doncs la manera de minimitzar errors i a la vegada d\u0026rsquo;ocultar el tipus de les variables (la qual cosa ens dóna flexibilitat si en un futur existeixen modificacions en l\u0026rsquo;estructura de dades de la pròpia classe) és creant els atributs de classe com a privats i implementar els seus mètodes get i set públics. L\u0026rsquo;accés des de fora la classe a aquesta variable serà a través dels mètodes. Així per a cada atribut de classe implementarem un getter i un setter.\nReprenem l\u0026rsquo;exemple anterior i afegim dues variables de classe a Persona: nom i edat, afegim degudament els seus getters \u0026amp; setters i en comprovem el funcionament en el PersonaTest creant dos exemples de Persona diferents.\npackage exemple1.versio2; public class Persona { private String nom; private int edat; public String getNom(){ return nom; } public int getEdat(){ return edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; } public void saluda() { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom + \u0026quot; i tinc \u0026quot; + edat + \u0026quot; anys\u0026quot;); } }  package exemple1.versio2; import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String nomPersona1 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); int edat1 = sc.nextInt();sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); String nomPersona2 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); int edat2 = sc.nextInt(); sc.close(); Persona persona1 = new Persona(); Persona persona2 = new Persona(); persona1.setNom(nomPersona1); persona1.setEdat(edat1); persona2.setNom(nomPersona2); persona2.setEdat(edat2); System.out.println(\u0026quot;El nom de la persona1 es: \u0026quot;+persona1.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona1.getEdat()); System.out.println(\u0026quot;El nom de la persona2 es: \u0026quot;+persona2.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona2.getEdat()); persona1.saluda(); persona2.saluda(); } }  Observacions:\n El getNom i getEdat retornen el valor de la variable d\u0026rsquo;instància d\u0026rsquo;un objecte determinat. Per la seva banda setNom i SetEdat modifiquen el contingut de la variable d\u0026rsquo;instància pertinent. Fixem-nos que saluda() ja no té com a paràmetre d\u0026rsquo;entrada el nom ja que l\u0026rsquo;agafa de la pròpia classe. L\u0026rsquo;atribut de classe és privat i per tant no és accessible des de fora la classe (s\u0026rsquo;accedeix mitjançant el getNom) però sí que ho és desde dins la pròpia classe, en saluda().  Constructors Totes les classes han de tenir un constructor que es fa servir per a instanciar objectes d\u0026rsquo;aquesta classe. En el constructor s\u0026rsquo;acostuma a donar valor als atributs de classe.\nEl constructor ha de tenir el mateix nom que la classe i no s\u0026rsquo;ha de posar tipus de retorn (ni void ni res!)\n Si en una classe no s\u0026rsquo;especifica cap constructor, el compilador proporciona un constructor per defecte sense paràmetres. Per exemple:\npublic class ClasseProva { /* És el mateix posar aquest constructor que no posar-lo. * ClasseProva (){ * * } */ } public class ClasseProvaTest { public static void main(String[] args){ ClasseProva cp = new ClasseProva(); } }  Encara que no l\u0026rsquo;haguem definit en ClasseProva, per tal de crear objectes de tipus ClasseProva, SI NO EXISTEIX CAP MÉS CONSTRUCTOR, Java ens proporciona el constructor per defecte (aquell constructor que no conté cap paràmetre ni cap operació dins el constructor). Ara bé, quan ClasseProva tingui definit almenys un constructor, desapareix ClasseProva per defecte, a no sé que també estigui explícitament definit en la classe ClasseProva.\nEls constructors són mètodes especials que sobretot NO retornen cap valor. Serveixen per indicar a Java que estem creant un objecte d\u0026rsquo;aquella classe. Sí que es pot proporcionar paràmetres d\u0026rsquo;entrada que ens ajudin a instanciar els atributs de classe d\u0026rsquo;aquell objecte. Si ens fixem en l\u0026rsquo;exemple anterior de Persona, podríem redefinir-lo de la següent manera:\npublic class Persona { private String nom; private int edat; Persona (String nom, int edat){ this.nom = nom; this.edat = edat; } public String getNom(){ return nom; } public int getEdat(){ return edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; } public void saluda() { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom + \u0026quot; i tinc \u0026quot; + edat + \u0026quot; anys\u0026quot;); } }  import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String nomPersona1 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); int edat1 = sc.nextInt();sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); String nomPersona2 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); int edat2 = sc.nextInt(); sc.close(); Persona persona1 = new Persona(nomPersona1, edat1); Persona persona2 = new Persona(nomPersona2, edat2); System.out.println(\u0026quot;El nom de la persona1 es: \u0026quot;+persona1.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona1.getEdat()); System.out.println(\u0026quot;El nom de la persona2 es: \u0026quot;+persona2.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona2.getEdat()); persona1.saluda(); persona2.saluda(); } }  Observacions:\n La constructora de Persona té dos paràmetres d\u0026rsquo;entrada que corresponen amb els dos atributs de la classe. Per diferenciar dues variables que es diuen igual (atribut de classe i paràmetre d\u0026rsquo;entrada) utilitzem el this. El this ens ajuda a diferenciar qualsevol atribut/mètode de dins la pròpia classe. En la classe test observem que ara no fem ús dels setters dels atributs, ja que a l\u0026rsquo;instanciar l\u0026rsquo;objecte amb la constructora ja els inicialitzem els atributs.  Més d\u0026rsquo;un constructor\nEs podria donar el cas que fos necessari la implementació de més d\u0026rsquo;un constructor en una classe, això és possible sempre que els tipus dels paràmetres d\u0026rsquo;entrada no coincideixin del tot, el compilador de Java diferencia els constructors dins la mateixa classe amb el llistat dels paràmetres d\u0026rsquo;entrada. Per exemple continuant amb l\u0026rsquo;exemple anterior redefinim la classe Persona amb 3 constructors:\n//Constructor per crear una persona amb nom public Persona(String nomPersona) { nom = nomPersona; edat = 0; //li poso un valor per defecte } //Constructor per crear una persona sense res public Persona() { } //Constructor per crear un persona amb nom i edat public Persona(String nomPersona, int edatPersona) { nom = nomPersona; edat = edatPersona; }  En el programa principal podríem crear ara objectes Persona de tres maneres diferents:\npublic static void main(String[] args) { Persona persona1 = new Persona(\u0026quot;Jordi\u0026quot;); persona1.setEdat(45); persona1.saluda(); Persona alumne2 = new Persona(\u0026quot;Maria\u0026quot;, 18); persona2.saluda(); Persona persona3 = new Persona(); persona3.saluda(); }  This Quan som dins d\u0026rsquo;un constructor o un mètode, this és una referència a l\u0026rsquo;objecte actual. Amb this pots fer referència a qualsevol atribut o mètode de l\u0026rsquo;objecte actual. Sobretot és necessari quan podria prestar confusió quan dos atributs o dos mètodes s\u0026rsquo;anomenen igual.\n public String getNom(){ return this.nom; } public String setEdat(){ return this.edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; } }  Observacions:\n En el mètode setNom és necessari l\u0026rsquo;ús del this ja que ens diferencia l\u0026rsquo;atribut de classe del paràmetre de la funció. En el mètode setEdat, no l\u0026rsquo;hem posat ja que no presta a confusió les dues variables, tot hi així es podria haver posat a this.edat per remarcar que estem parlant de l\u0026rsquo;atribut de classe. En els getters l\u0026rsquo;hem deixat com a bona praxis, però si no hi hagués el this tampoc hi hauria confusió i java ho interpretaria correctament.  En l\u0026rsquo;exemple següent utilitzem el this com a crida a un constructor dins la mateixa classe:\npublic Persona(String nom) { this(nom, 18); //crido al 3r constructor } public Persona() { this(\u0026quot;Anonymous\u0026quot;); //crido al 1r constructor } public Persona(String nom, int edat) { this.setNom(nom); this.setEdat(edat); }  Mètodes i variables Estàtics i No Estàtics Mètodes estàtics\nJa hem vist a la UF2 la diferència entre una variable o mètode estàtic i no estàtic. Fins al moment amb l\u0026rsquo;exemple Persona hem treballat la definició d\u0026rsquo;una classe que per ser utilitzada és necessari instanciar-ne un objecte, és així ja que és necessari guardar en memòria la informació d\u0026rsquo;aquesta persona, d\u0026rsquo;aquesta manera, els mètodes de la classe interactuen amb aquests atributs, és un clar exemple d\u0026rsquo;una classe no estàtica. És necessari la creació d\u0026rsquo;un objecte Persona per utilitzar els seus mètodes getters \u0026amp; setters o saluda. Això no treu que podria haver-hi hagut algun mètode que sí fos estàtic, o sigui, el seu comportament no varia tant si intanciem com si no instanciem una Persona, un exemple seria:\npublic static String informa(){ System.out.println(\u0026quot;Soc un metode de la classe Persona i el meu objectiu es nomes informar d'aixo\u0026quot;); }  Per fer ús d\u0026rsquo;aquest mètode informa() no és necessari crear un objecte Persona.\nAixí doncs no podrem declarar un mètode com estàtic si aquest:\n Accedeix a atributs de la classe. Modifica el contingut d\u0026rsquo;atributs de la classe. En ell hi intervenen mètodes privats de la pròpia classe.  Si el mètode ha de realitzar una tasca independent al contingut de l\u0026rsquo;objecte i no hi té incidència es pot declarar com static.\nL\u0026rsquo;exemple anterior ens podria servir per persona. Normalment s\u0026rsquo;usen els mètodes estàtics per realitzar càlculs o recorre llistats predeterminats. Un exemple és la classe Math de Java. Si li feu un cop d\u0026rsquo;ull observareu que tots els seus mètodes són statics, és així ja que el propòsit de tots ells és efectuar càlculs independents. En l\u0026rsquo;exemple següent usarem el mètode anterior informa() i el mètode max de la classe Math:\npublic static void main((String[] args) { int numero1 = 20; int numero2 = 10; int numeroMaxim = Math.max(numero1, numero2); Persona.informa(); }  Observacions:\n La notació per tal d\u0026rsquo;usar els mètodes estàtics és NomClasse.nomMetode(). Els mètodes estàtics també poden ser privats. Si per exemple hagués declarat informa() voldria dir que només el podria usar des de dins la pròpia classe Persona, no tindria visibilitat fora d\u0026rsquo;aquesta.  Es poden referenciar mètodes estàtics desde dins de mètodes no estàtics, un exemple en són els mètodes de la classe Math que els podem usar allà on siguin requerits, però no al revés. No podria declarar el mètode saluda() de la classe Persona com a estàtic ja que ESTIC USANT ATRIBUTS de la classe. Si el declaro com a estàtic podria passar que utilitzés el mètode saluda() abans de crear un objecte Persona, el mètode va a buscar les variables nom i edat que no reconeix i el compilador de Java donaria error.\npublic void saluda() { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom + \u0026quot; i tinc \u0026quot; + edat + \u0026quot; anys\u0026quot;); }  Atributs estàtics\nFins al moment hem treballat amb atributs d\u0026rsquo;instància, són aquells que poden canviar de valor en cada objecte i que per tant el determinen. Però també tenim atributs estàtics, són aquells que no se\u0026rsquo;n modifica el valor i que, per tant, tenen el mateix valor per tots els objectes. Els atributs estàtics estan sempre en memòria, per això és necessari declarar només aquells que siguin imprescindibles.\nPer a utilitzar-los posarem la paraula static abans del tipus de la variable. Per exemple MAJOR_EDAT:\npublic class Persona { public static int MAJOR_EDAT = 18; private String nom; private int edat; Persona (String nom, int edat){ this.nom = nom; this.edat = edat; } public String getNom(){ return nom; } ...  Igual que amb els mètodes, si la variable estàtica és pública i es vol accedir a ella des d\u0026rsquo;una altra classe cal que siguem la nomenclatura NomClasse.NomAtribut. Per exemple per accedir a l\u0026rsquo;anteior atribut estàtic fora de Persona hauríem de posar Persona.MAJOR_EDAT.\nUn dels usos més habituals de les variables estàtiques són per declarar constants, per exemple en la classe Math anterior tenim Math.PI. En aquests casos cal que vagin acompanyats de la paraula final, en Java quan declarem una variable com a final vol dir que un cop inicialitzada no li podem canviar el valor (com passa amb les constants). Si es vol canviar el valor a un atribut declarat com a final el compilador de Java contestarà amb un error.\npublic static final int MAJOR_EDAT = 18;  Variables referenciades Totes les variables que no són primitives en Java passen a estar referenciades, igual com ja hem vist que passa amb els arrays o els Strings. En el cas que declarem les nostres pròpies classes i les instanciem passa el mateix. Retornant a l\u0026rsquo;exemple de Persona de l\u0026rsquo;activitat anterior, quan declarem una Persona p, estem declarant una referència a un objecte de tipus Persona, però fins que no la construïm amb el new Persona() aquesta referència p apunta a un valor null. La màquina virtual de Java té un procés anomenat garbage collector que periòdicament analitza quines són les variables desreferenciades (que apunten a null) i les elimina de la memòria. Així doncs un cop passa el garbage collector pel següent codi troba una variable p a null i l\u0026rsquo;elimina:\n//Creem la referència a un objecte de tipus Persona, de moment no està creat encara Persona p; //Creem i reservem en memòria espai suficient per guardar els atributs d'aquest objecte p = new Persona(); //Efectuem modificacions a l'objecte p.setEdat(5); p.setNom(\u0026quot;Joaquim\u0026quot;); //Fem que p es desreferenciï de l'objecte instanciat. Quan passi garbage collector eliminarà tots els punters desreferenciats com aquest. p = null;  En la UF2 anterior hem observat el pas per valor i el pas per referència. Com ja hem vist quan passem com a paràmetre a una funció una variable de tipus primitiu s\u0026rsquo;efectua una còpia d\u0026rsquo;aquesta variable i no s\u0026rsquo;actua en l' original, mentre que quan el paràmetre no es primitiu es passa com a referència, i per tant SÍ que estem enviant la posició de memòria on es troba la variable, ho hem vist amb els arrays i ara veurem que passa el mateix quan passem una referència d\u0026rsquo;un objecte d\u0026rsquo;una classe que hem creat nosaltres (NO és de tipus primitiu). Anem a observar l\u0026rsquo;exemple següent:\npublic static void main(String[] args) { Persona p = new Persona(\u0026quot;Leo\u0026quot;, 5); System.out.println(\u0026quot;Abans d'entrar al canvi sense modificació:\u0026quot; + p); canviSenseModificarObjecte(p); System.out.println(\u0026quot;Després de sortir de la funció del canvi sense modificacio:\u0026quot; +p); canviModificantObjecte(p); System.out.println(\u0026quot;Després de sortir de la funció del canvi amb modificacio:\u0026quot; +p); } private static void canviSenseModificarObjecte(Persona p) { System.out.println(\u0026quot;'p' dins de canviSenseModificarObjecte abans de canviar l'objecte de Persona p: \u0026quot; + p); p = new Persona(); p.setNom(\u0026quot;Victor\u0026quot;); p.setEdat(33); System.out.println(\u0026quot;'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: \u0026quot; + p); } private static void canviModificantObjecte(Persona p) { System.out.println(\u0026quot;'p' dins de canviModificantObjecte abans de modificar-lo: \u0026quot; + p); p.setNom(\u0026quot;Pere\u0026quot;); p.setEdat(47); System.out.println(\u0026quot;'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: \u0026quot; + p); }  Resultat\nAbans d'entrar al canvi sense modificació:Persona{nom='Leo', edat=5} 'p' dins de canviSenseModificarObjecte abans de canviar l'objecte de Persona p: Persona{nom='Leo', edat=5} 'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: Persona{nom='Victor', edat=33} Després de sortir de la funció del canvi sense modificacio:Persona{nom='Leo', edat=5} 'p' dins de canviModificantObjecte abans de modificar-lo: Persona{nom='Leo', edat=5} 'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: Persona{nom='Pere', edat=47} Després de sortir de la funció del canvi amb modificacio:Persona{nom='Pere', edat=47}  Observacions:\n Veiem que imprimim directament p i se n\u0026rsquo;observen els valors dels atributs. Per defecte totes les classes tenen una funció public String toString() que quan es crida la referència de l\u0026rsquo;objecte n\u0026rsquo;imprimeix els seus valors. Més endavant veurem com modificar-ho. Com s\u0026rsquo;observa en l\u0026rsquo;exemple quan es surt del primer mètode com que els canvis d\u0026rsquo;objecte es produeixen a l\u0026rsquo;interior del mètode, al sortir del mètode la referència p apunta on originàriament apuntava (es passa per referència) de forma que perdem els canvis que s\u0026rsquo;hagin pogut produir dins. En el segon mètode com que s\u0026rsquo;efectuen els canvis justament en la direcció p original, al sortir del mètode observem com els canvis s\u0026rsquo;han mantingut en l\u0026rsquo;objecte p Persona.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/2metodologiessoftware/",
	"title": "Metodologies de Software",
	"tags": [],
	"description": "",
	"content": "El programari no es fabrica com qualsevol altre producte clàssic, sinó que es desenvolupa seguint una sèrie d\u0026rsquo;etapes. D\u0026rsquo;aquí sorgeix el concepte d\u0026rsquo;enginyeria de programari, que consisteix en l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria per obtenir desenvolupaments que optimitzin l\u0026rsquo;efectivitat i els costos.\nEls processos d\u0026rsquo;enginyeria de programari comprenen per tant, diverses etapes, que constitueixen el que s\u0026rsquo;anomena el cicle de vida del programari. Per dur a terme aquestes fases és necessari partir d\u0026rsquo;un enfocament amb el qual iniciar el procés de enginyeria. Un cop iniciat, s\u0026rsquo;ha d\u0026rsquo;utilitzar una metodologia amb unes eines que permetin completar les diferents etapes de l\u0026rsquo;cicle.\nEn l\u0026rsquo;actualitat, l\u0026rsquo;enfocament més estandaritzat és l\u0026rsquo;orientació a objectes. la creació el 1998 de l\u0026rsquo;estàndard UML (Unified Modeling Language) per a la definició de problemes i el desenvolupament de llenguatges de programació com Java o C ++ pel desenvolupament i integració de solucions, són els principals causants que aquest enfocament s\u0026rsquo;estigui consolidant.\nQuè és l\u0026rsquo;enginyeria del software? De l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria a l\u0026rsquo;programari sorgeixen els processos de desenvolupament de programari. Aquest procés es defineix com \u0026ldquo;aquell en què les necessitats de l\u0026rsquo;usuari són traduïdes en requisits de programari, aquests requisits transformats en disseny, i el disseny implementat en codi, que és provat, documentat i certificat pel seu ús operatiu\u0026rdquo; [Jacobson, 1998].\n Característiques del software  S\u0026rsquo;ha invertit la demanda i el preu respecte al HW. El Software es un producte lògic que es desenvolupa, no es construeix com la resta de productes. La gestió de costos es centra en l\u0026rsquo;enginyeria, amb la qual difereix d\u0026rsquo;altres projectes d\u0026rsquo;enginyeria. El Software no es deteriora amb el temps, però sí és necessari un manteniment. La reutilització de productes software creixent. Existeixen restriccions de recursos en el desenvolupament de software, de forma que és necessari assegurar-ne la qualitat per obtenir un software: documentat, fiable, eficient i amb una bona interfície gràfica.  Cicles de desenvolupament del software. Tipus de cicles Anomenem cicle de vida del software al temps necessari per la producció d\u0026rsquo;un projecte software desde la recopilació de requisits fins a l\u0026rsquo;entrega final del producte. El cicle de vida inclou una sèrie d\u0026rsquo;etapes que pot canviar en funció del model, la metodologia i l\u0026rsquo;autor. Existeixen varis tipus de cicles de vida que passem a comentar.\nModel en cascada o lineal Es tracta d\u0026rsquo;un model molt genèric i que estableix una sèrie de fases o etapes, que han de ser seguides en un ordre seqüencial, ja que cada fase genera entrades i documentació per a la següent fase. Les fases d\u0026rsquo;un cicle de vida en cascada segueixen el següent esquema:\nLes característiques del model són:\n Cada etapa s\u0026rsquo;inicia un cop acabada l\u0026rsquo;anterior. Ajuda a la planificació temporal i el càlcul de costos, a causa de la seqüencialitat i estructura lògica de les etapes. Hi ha una realimentació en el manteniment.  Quant als inconvenients que s\u0026rsquo;han detectat, aquests són:\n Es tracta d\u0026rsquo;un model rígid, sense robustesa ni adaptabilitat als problemes a resoldre. Hi ha dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials, ja que aquests solen venir donats per persones alienes al coneixement del cicle de desenvolupament de programari. Els errors solen detectar-se molt tard, el que implica que el cost per solucionar l\u0026rsquo;error sigui molt més gran. El manteniment es realitza mitjançant petites actualitzacions o \u0026ldquo;pegats\u0026rdquo;. Torna a aplicar cadascuna de les fases del cicle al programari ja existent, sense crear un de nou.  Fases:\n Anàlisi de sistema: el sistema de programari forma part sobre un sistema major amb el qual es relaciona. S\u0026rsquo;analitza el sistema en el seu conjunt per treure objectius que han de ser abordables pel programari. Anàlisi de requisits: definint funcions a realitzar, dades, comportament, i interacció entre elements funcionals. Disseny: a partir de requisits dissenyem els components de programari, estructures de dades, mòduls, procediments, algoritmes i interfícies\u0026hellip; Codificació: a partir d\u0026rsquo;informació generada implementem sistema, codifiquem procediments en un llenguatge de programació. Prova: validem i verifiquem que els requisits establerts pel client es realitzen correctament. Manteniment: la producció de programari no finalitza amb el lliurament, ha de ser revisat i reajustat quan això sigui necessari.  Cicle de vida prototipat Aquest model tracta de solucionar problemes del model en cascada, en concret les dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials. El client sol definir els objectius generals del programari, però no acostuma a tenir en compte tots els requisits reals que ha de tenir una aplicació. Al mateix temps, el desenvolupador pot no arribar a entendre què vol el client. Per tal de solucionar això, un cicle basat en prototips pot ser un millor enfocament.\nLes característiques d\u0026rsquo;aquest model són:\n Client i desenvolupador defineixen una sèrie d\u0026rsquo;objectius globals, dels quals s\u0026rsquo;identifiquen els requisits, amb els quals es realitza un disseny ràpid, i amb aquest, la creació d\u0026rsquo;un prototip. El prototip és avaluat per l\u0026rsquo;usuari, qui pot veure les deficiències del prototip, a partir de les quals es redefineixen els requisits. Es van construint nous prototips, amb els quals el client pot anar polint els requisits de programari, al mateix temps que el desenvolupador pot comprendre millor el que ha de fer. Aquestes interaccions finalitzen quan el prototip satisfà les necessitats del client.  Inconvenients d\u0026rsquo;aquest tipus de cicle de vida:\n És un procés molt lent. Si es desitja generar un programari de qualitat no n\u0026rsquo;hi ha prou que un prototip sigui com l\u0026rsquo;anterior amb uns petits ajustos, sinó que es requereix crear el producte de nou. això succeeix fonamentalment amb els primers prototips de cada desenvolupament. El client veu cada prototip com una versió de programari final, sense prendre consciència que cada prototip únicament ajuda a aclarir els requisits, i per tant, és generat des del principi, per aconseguir una robustesa en el desenvolupament. Els primers prototips que es rebutgen suposen un cost addicional, ja que amb prou feines poden emprar-se per al mateix desenvolupament ni poden ser reutilitzats per a altres.  Cicles de vida evolutius El programari és un producte que va evolucionant per això els desenvolupadors necessiten un nou model de cicle de vida, que permeti que les funcionalitats del programari puguin anar canviant amb el temps. El model en cascada assumeix que es lliura un producte una vegada acabades totes les fases del procés, sense considerar possibles evolucions. Tampoc es té en compte l\u0026rsquo;evolució en el model de prototips, en que aquests es dissenyen per ajudar al client a comprendre els requisits, però no per disposar de versions a millorar.\nLa solució la presenten els cicles de vida evolutius, que amb una estructura iterativa, permeten als enginyers desenvolupar versions cada vegada més completes del programari.\nCicle de vida incremental Aquest model combina el model lineal seqüencial amb la filosofia de creació de prototips. Per a això, va generant seqüències lineals de desenvolupament al mateix temps que cada seqüència lineal produeix un \u0026ldquo;increment\u0026rdquo; en el programari, el qual va progressant.\nEl primer increment sol ser un desenvolupament que tan sols incorpora els requisits i funcionalitats més bàsiques. Les versions successives consisteixen en modificacions de cada versió anterior, a la qual s\u0026rsquo;afegeixen noves funcionalitats i modificacions, es van lliurant les diferents versions o increments d\u0026rsquo;acord es van acabant. A diferència del prototipat, cada increment aprofita la versió anterior, i és una versió del producte final a falta d\u0026rsquo;algunes funcionalitats. L\u0026rsquo;esquema que segueix aquest tipus de cicle de vida és el següent:\nAquest tipus de cicle de vida és molt avantatjós des del punt de vista de costos temporals i flexibilitat en la planificació del projecte. Els primers increments no requereixen molt personal, mentre que per als següents es poden anar afegint més o menys funcionalitats segons la quantitat de personal de què es disposi o bé segons que es disposi o no de determinats recursos.\nCicle de vida en espiral És un procés evolutiu que combina la interactivitat del prototipat amb els aspectes sistemàtics del model en cascada. Cada volta de l\u0026rsquo;espiral consta de les mateixes fases que el cicle en cascada:\n Planificació: determina objectius, requisits i restriccions de el projecte. Anàlisi de risc: analitza alternatives, identifica i resol riscos Enginyeria: desenvolupament del producte. Avaluació de client: es valoren els resultats obtinguts.  Segueix les directrius del model PDCA (Plan Develop Check Act) de Demming, i segueix la filosofia del moviment Agile resumit en el Manifiesto Agile, una de les seves implementacions més conegudes és SCRUM.\nEl principal avantatge del model en espiral és que és el més adequat per projectes amb riscs. Com el programari va evolucionant, el desenvolupador i client poden anar comprenent cada vegada millor els riscos conforme es va passant per diferents nivells d\u0026rsquo;evolució. El mecanisme utilitzat per minimitzar riscos es basa en poder incorporar el prototipat en qualsevol etapa d\u0026rsquo;evolució del producte.\nDavant d\u0026rsquo;aquest avantatge, es troba l\u0026rsquo;inconvenient de requerir una alta habilitat en els enginyers per avaluar riscos. L\u0026rsquo;èxit depèn molt d\u0026rsquo;ella, ja que un risc no descobert pot donar lloc a problemes.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2tipusdades/",
	"title": "Tipus de dades i operadors",
	"tags": [],
	"description": "",
	"content": "Tipus de dades En el llenguatge Java incorpora tipus de dades diferents d\u0026rsquo;acord amb la seva naturalesa: no és el mateix un nombre, que un text o un valor verdader/fals per exemple. Aquests tipus de dades els classifiquem en tipus de dades primitius i tipus de dades de classe:\n Primitius: són les dades simples que coneixem com a nombres, text, etc. i que ens defineix de forma primitiva el llenguatge. Classe: són tipus de dades més complexos que es creen a partir dels mateixos tipus de classe o de tipus primitius.  Tipus Primitius En Java podem diferenciar els següents tipus de dades primitius:\n Numèrics:  Enters: byte, short, int i long Reals: float, double   Textuals:  chars   Lògics:  boolean    La diferència entre els nombres enters i reals és que els nombres enters no contenen decimals (ex: 2 | 3 | 25) i els nombres reals reserven espai pels decimals (ex: 4,45 | 6,82 | 3,141592). Tot seguit us mostro una taula de rangs:\n   Nom Longitud Rangs de valors     byte 8 bits De -27 a 27 -1   short 16 bits De -215 a 215 -1   int 32 bits De -231 a 231 -1   long 64 bits De -263 a 263 -1   float 32 bits    double 64 bits    char 16 bits     Els valors que admet una variable de tipus booleà és: true o false. Un valor booleà és molt comú en el camp informàtic on moltes vegades cal prendre una decisió que es pot avaluar en \u0026ldquo;veritat\u0026rdquo; o \u0026ldquo;fals\u0026rdquo;.\nExemple d\u0026rsquo;assignació de valors Declarem i assignem un valor a les variables:\nboolean valorBoolea = true; int valorEnter = 50; float valorDecimal = 50.3; char lletra =’v’;  En aquest cas primer declarem les variables i després li assignem un valor:\nboolean valorBoolea; valorBoolea = true; int valorEnter; valorEnter = 50; float valorDecimal; valorDecimal = 50.3; char lletra; lletra =’v’;  Operadors Operadors aritmètics Són les operacions que avaluen una operació i retornen un resultat numèric.\n   Operació Operador     Suma +   Resta -   Multiplicació *   Divisió /   Mòdul %    Altres operadors\nExisteixen altres formes que simplifiquen l\u0026rsquo;escriptura alhora de fer operacions senzilles. Seria el cas dels comptadors. D\u0026rsquo;aquesta manera existeixen expressions com:\nint comptador = 0; comptador = comptador + 1; //es pot fer de forma més simple int comptador = 0; comtpador++; //Les dues expressions següents també són equivalents i s'aplica a tots els operadors aritmètics: int comptador = 0; comptador = comptador + 10; comptador =+ 10; comptador = comptador - 10; comptador =- 10; comptador = comptador * 10; comptador =* 10; comptador = comptador / 10; comptador =/ 10;  Recordem l\u0026rsquo;ordre de prioritat en les operacions aritmètiques:\n 1r Parèntesi () 2n Multiplicacions, divisioons i mòdul * / % 3r Sumes i restes + -  Operadors lògics i relacionals Són les operacions que avaluen una expressió i retornen un resultat booleà (true o false).\nOperadors lògics\n   A B !A A \u0026amp;\u0026amp; B A || B     true true false true true   true false false false true   false true true false true   false false true false false    Operadors relacionals\nAquests operadors els podem aplicar a diferents tipus de dades i s\u0026rsquo;avalua l\u0026rsquo;expressió a un booleà (true o false).\n   Operació Signe Exemple1 Resultat1 Exemple2 Resultat2     Major \u0026gt; 5 \u0026gt; 3 true 3 \u0026gt; 5 false   Major o igual \u0026gt;= 5 \u0026gt;= 5 true 5 \u0026gt;= 3 true   Menor \u0026lt; 5 \u0026lt; 5 false 3 \u0026lt; 2 false   Menor o igual \u0026lt;= 6 \u0026lt;= 5 false 4 \u0026lt;= 5 true   Igual == \u0026lsquo;c\u0026rsquo; == \u0026rsquo;d' false 5 == 3 false   No igual != \u0026lsquo;c\u0026rsquo; != \u0026rsquo;d' true 5 != 5 false    Prioritat\nLa prioritat alhora d\u0026rsquo;avaluar expressions que contenen operadors aritmètics, relacionals i lògics és:\n 1r. Es realitzen els càlculs aritmètics. 2n. S\u0026rsquo;avaluen les operacions relacionals de \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 3r. S\u0026rsquo;avaluen les operacions relacionals de == != 4rt. S\u0026rsquo;avaluen les negacions lògiques ! 5è. S\u0026rsquo;avaluen les operacions de conjunció \u0026amp;\u0026amp; 6è. S\u0026rsquo;avaluen les operacions de disjunció ||  Les operacions anteriors s\u0026rsquo;avaluen sempre d\u0026rsquo;esquerra a dreta.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/coleccions/3hashmap/",
	"title": "Hashmap",
	"tags": [],
	"description": "",
	"content": " HashMap: és una estructura de dades que conté elements que obeeixen a la lògica clau-valor (K-V). La clau és única en tota la col·lecció i identifica un element respecte els altres, els valors poden estar duplicats.\n La definició de la classe HashMap java.util.HashMap i de totes les seves funcionalitats la trobareu a: Java Oracle Classe HashMap\nUtilitza una taula de dispersió per a emmagatzemar la informació de mapa. Les operacions bàsiques (get i put) es faran en temps constant sempre que es dispersin adequadament els elements. El cost de la iteració dependrà del nombre d\u0026rsquo;entrades de la taula i del nombre d\u0026rsquo;elements del mapa. No es garanteix que es respecti l\u0026rsquo;ordre de les claus. Tot hi que se l\u0026rsquo;identifica com una Collection, un HashMap hereta de Map i no de Collection.\nDeclaració\nEn la declaració indicarem de quin tipus és la llista en \u0026lt;K, V\u0026gt;. Per exemple per declarar un HashMap on la clau són enters i els valors són Strings:\nHashMap\u0026lt;Integer,String\u0026gt; hm = new HashMap\u0026lt;Integer,String\u0026gt;();  Funcionalitats principals\nEn l\u0026rsquo;exemple s\u0026rsquo;observa la manipulació d\u0026rsquo;un HashMap primer per un parell\u0026lt;Integer, String\u0026gt; i després per un parell \u0026lt;Integer,Alumne\u0026gt;:\nimport java.util.*; import java.util.stream.Collectors; public class ExHashmap { public static void main(String[] args) { // HashSet de String // Creem el Hashmap HashMap\u0026lt;Integer,String\u0026gt; hm = new HashMap\u0026lt;Integer,String\u0026gt;(); // Afegim elements hm.put(45,\u0026quot;Element 9\u0026quot;); hm.put(23,\u0026quot;Element 2\u0026quot;); hm.put(12,\u0026quot;Element 7\u0026quot;); hm.put(87,\u0026quot;Element 4\u0026quot;); hm.put(97,\u0026quot;Element 5\u0026quot;); hm.put(34,\u0026quot;Element 6\u0026quot;); hm.put(56,\u0026quot;Element 3\u0026quot;); hm.put(32,\u0026quot;Element 8\u0026quot;); hm.put(98,\u0026quot;Element 1\u0026quot;); // Afegim elements amb la mateixa clau hm.put(98,\u0026quot;Element maxacat\u0026quot;); hm.put(56,\u0026quot;Element maxacat\u0026quot;); hm.put(32,\u0026quot;Element maxacat\u0026quot;); hm.put(34,\u0026quot;Element maxacat\u0026quot;); // Imprimim hashmap System.out.println(\u0026quot;\\nRealitzem recorregut de tres maneres diferents\u0026quot;); System.out.println(\u0026quot;1. Mitjançant la key\u0026quot;); for (int key : hm.keySet()) { System.out.println(key+\u0026quot; --\u0026gt; \u0026quot;+hm.get(key)); } System.out.println(\u0026quot;\\n2. Només amb els valors\u0026quot;); for (Object value : hm.values()) { System.out.println((String)value); } System.out.println(\u0026quot;\\n3. Amb valor i clau\u0026quot;); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : hm.entrySet()) { int key = entry.getKey(); Object value = entry.getValue(); System.out.println(\u0026quot;Per la clau \u0026quot; + key + \u0026quot; tenim el valor \u0026quot; + value); } System.out.println(\u0026quot;\\nSi intento eliminar amb el mètode remove(key), si la key no existeix retorna null\u0026quot;); System.out.println(hm.remove(1)); System.out.println(\u0026quot;\\nSi intento eliminar amb el mètode remove(key), si la key existeix retorna el valor\u0026quot;); System.out.println(hm.remove(98)); //Ordenació mitjançant TreeMap System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeMap\u0026quot;); TreeMap\u0026lt;Integer, String\u0026gt; hmOrdenat = new TreeMap\u0026lt;\u0026gt;(hm); //TreeMap\u0026lt;Integer, String\u0026gt; hmOrdenat2 = new TreeMap\u0026lt;\u0026gt;(); //hmOrdenat2.putAll(hm); System.out.println(\u0026quot;\\nMostrem HashMap ordenat per keys\u0026quot;); for (int key : hmOrdenat.keySet()) { System.out.printf(\u0026quot;key: %s, value: %s\\n\u0026quot;, key, hmOrdenat.get(key)); } /*System.out.println(\u0026quot;\\nMostrem HashMap ordenat per keys\u0026quot;); Set ref = hmOrdenat.keySet(); Iterator it = ref.iterator(); while (it.hasNext()) { int key = (int) it.next(); System.out.println(key + \u0026quot; --\u0026gt; \u0026quot; + hmOrdenat.get(key)); }*/ System.out.println(\u0026quot;\\nMostrem HashMap ordenat per valors\u0026quot;); final Map\u0026lt;Integer, String\u0026gt; ordenarPerString = hm.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -\u0026gt; e1, LinkedHashMap::new)); for (int key : ordenarPerString.keySet()) { System.out.printf(\u0026quot;key: %s, value: %s\\n\u0026quot;, key, ordenarPerString.get(key)); } //Objectes ALUMNE // HashMap d' objectes Alumne System.out.println(\u0026quot;\\nHASHMAP ALUMNES\u0026quot;); HashMap\u0026lt;Integer, Alumne\u0026gt; alumnes = new HashMap\u0026lt;Integer,Alumne\u0026gt;(); // Afegir element alumnes.put(4,new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;)); alumnes.put(3,new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;)); Alumne al = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); alumnes.put(2,al); alumnes.put(1,new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;)); alumnes.put(5,new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;)); // Imprimim hashmap les altre dues formes d'imprimir també funcionen. System.out.println(\u0026quot;\\nRealitzem recorregut\u0026quot;); System.out.println(\u0026quot;Mostrem HashMap d'alumnes:\u0026quot;); for (int key : alumnes.keySet()) { System.out.println(\u0026quot;key: \u0026quot;+ key +\u0026quot; valor: \u0026quot; + alumnes.get(key)); } //ORDENAR MITJANÇANT ARRAYLIST System.out.println(\u0026quot;\\nOrdenar claus i valors per ArrayList\u0026quot;); List\u0026lt;Integer\u0026gt; keyAlumnes = new ArrayList\u0026lt;\u0026gt;(alumnes.keySet()); Collections.sort(keyAlumnes); System.out.println(\u0026quot;Ordenar claus\u0026quot;); System.out.println(keyAlumnes); List\u0026lt;Alumne\u0026gt; alumnesLlista = new ArrayList\u0026lt;\u0026gt;(alumnes.values()); Collections.sort(alumnesLlista, Alumne.alumnesCompararPerCognom); System.out.println(\u0026quot;\\nOrdenar valors per cognom\u0026quot;); for(Alumne alumne: alumnesLlista) System.out.println(alumne); // Comprovar si conté un objecte System.out.println(\u0026quot;\\nComprovem si conté un element per key\u0026quot;); if (alumnes.containsKey(4)) { System.out.println(\u0026quot;Existeix l'alumne buscat \u0026quot;+alumnes.get(4)); } System.out.println(\u0026quot;\\nComprovem si conté un element per valor\u0026quot;); if (alumnes.containsValue(al)) { System.out.println(\u0026quot;Existeix l'alumne buscat \u0026quot;+alumnes.get(1)); } //Eliminem i recorregut System.out.println(\u0026quot;\\nEliminem l'element amb key: 1\u0026quot;); alumnes.remove(1); System.out.println(alumnes); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/programacioavancadapoo/3interficies/",
	"title": "Interfícies",
	"tags": [],
	"description": "",
	"content": "Les interfícies són un pas més cap a l\u0026rsquo;abstracció. Una interfície té tots els mètodes abstractes. Ens serveix per diferenciar la declaració dels mètodes de la seva implementació. S\u0026rsquo;acostuma a crear interfícies per definir característiques/funcionalitats que han de tenir les classes concretes i afegir-les en la seva implementació. Desde Java8 és possible tenir mètodes default implementats per defecte dins les interfícies, ho veurem amb l\u0026rsquo;exemple del diamant al final de la lliçó.\nCaracterístiques de les interfícies:\n Els mètodes d\u0026rsquo;una interfície són públics, en canvi, les interfícies poden ser públiques default. Les interfícies només poden tenir variables públiques, estàtiques i finals, constants. Si no es posa res, es sobreentén que són públiques, estàtiques i finals.  Implementació La declaració d\u0026rsquo;una interfície la faríem de la següent manera:\npublic interface Movible{ int SEGONS_PARTIDA = 200; public void giraDreta(); public void giraEsquerra(); public int frena(); public int anarEndavant(); }  Un cop tenim definit com volem la interfície ara cal incloure-la en les classes. Fins ara utilitzàvem extends ja que la relació era \u0026ldquo;ÉS UN\u0026rdquo;, amb les interfícies estem afegint característiques a un objecte, usarem la paraula implements.\nDe l\u0026rsquo;exemple anterior, si tinguéssim una simulació de vehicles i ens fes falta definir funcions per les funcions físiques de cada vehicle ho podríem fer de la següent manera:\npublic abstract class Vehicle{ protected int velocitat; protected int orientacio; ... } public class Cotxe extends Vehicle implements Movible{ public void giraDreta(){ orientacio = orientacio + 45; } public void giraEsquerra(){ orientacio = orientacio - 45; } public int frena(){ if(velocitat \u0026lt;=10) velocitat = 0; else velocitat -=10; } public int anarEndavant(){ velocitat +=10; } } public class Moto extends Vehicle implements Movible{ public void giraDreta(){ orientacio = orientacio + 60; } public void giraEsquerra(){ orientacio = orientacio - 60; } public int frena(){ if(velocitat \u0026lt;=5) velocitat = 0; else velocitat -=5; } public int anarEndavant(){ velocitat +=5; } }  Si volgués incloure un nou vehicle a la meva simulació tant sols seria necessari que tingués en compte d\u0026rsquo;implementar aquells mètodes que té definits la interfície i també els mètodes abstractes que tingués la classe abstracta.\nUna de les avantatges de les interfícies és que permet més d\u0026rsquo;una implementació per classe a diferència de les herències que en java tenim només herència simple. Podríem tenir com exemple:\npublic interface Movible{ public void A(); } public interface Comercial{ public void B(); } public interface Navegable{ public void C(); } public class Taxi extends Vehicle implements Movible, Comercial{ public void A(){ ... } public void B(){ ... } } public class Veler extends Vehicle implements Movible, Navegable{ public void A(){ ... } public void C(){ ... } }  També, al igual que amb les classes abstractes, podria existir jerarquies de classe dins una interfície, es podrien estendre. Si això passa, les classes concretes haurien d\u0026rsquo;implementar tots aquells mètodes de totes les superclasses de la/les interfície/s utilitzades.\npublic interface InterficieSuper{ public void A(); } public interface InterficieSub extends InterficieSuper{ public void B(); } public class ClasseConcreta implements InterficieSub{ public void A(){ ... } public void B(){ ... } }  Agrupar per funcionalitat Totes les classes que implementen una interfície són compatibles amb el tipus introduït per la interfície. Una interfície no es pot instanciar, però sí s\u0026rsquo;hi pot fer referència. Així, si I és una interface i C és una classe que implementa la interfície, es poden declarar referències al tipus I que apuntin objectes de C: I obj = new C (\u0026lt;paràmetres\u0026gt;); Exemple:\nSeguint amb l\u0026rsquo;exemple anterior amb les interfícies movible, comercial i navegable. Podríem agrupar els objectes concrets en ArrayList d\u0026rsquo;una interfície i realitzar-ne el recorregut:\nArrayList\u0026lt;Movible\u0026gt; movibles= new ArrayList(); mov.add(new Cotxe()); mov.add(new Taxi()); mov.add(new Veler()); for (Movible vehicleMoviment : movibles) { vehicleMoviment.A(); }  Herència múltiple En java existeix el problema que les classes només hereten d\u0026rsquo;un pare, això provoca el conflicte conegut amb el problema del diamant: Problema diamant\nExemple\nSi tenim un mètode definit a A i sobreescrit a B i C, D quin hereta? El de B o el de C?\nPer resoldre-ho, el que faríem en Java seria el següent:\ninterface B{ public default void m1() { System.out.println(\u0026quot;display method of m1 for B\u0026quot;); } } interface B{ public default void m1() { System.out.println(\u0026quot;display method of m1 for C\u0026quot;); } } public class D implements B, C{ public void m1() { B.super.m1(); //or, C.super.m1(); } public static void main(String args[]) { D obj = new D(); obj.display(); } }  Resumint:\n Una interfície pot ser implementada per múltiples classes, de manera similar a com una classe pot ser superclasse de múltiples classes. Les classes que implementen una interfície estan obligades a sobreescriure tots els mètodes definits en la interfície. Si la definició d\u0026rsquo;algun dels mètodes a sobreescriure coincideix amb la definició d\u0026rsquo;algun mètode heretat, aquest desapareix de la classe. Una classe pot implementar múltiples interfícies, a diferència de l\u0026rsquo;herència, que només es permet d\u0026rsquo;una única classe base. Totes les classes que implementen una interfície són compatibles amb el tipus introduït per la interfície. L\u0026rsquo;existència de les interfícies possibilita l\u0026rsquo;existència d\u0026rsquo;una jerarquia de tipus (que no s\u0026rsquo;ha de confondre amb la jerarquia de classes) que permet l\u0026rsquo;herència múltiple.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/3tipusllenguatges/",
	"title": "Tipus de Llenguatges",
	"tags": [],
	"description": "",
	"content": "Els llenguatges de programació es poden classificar a partir de diferents criteris\n Segons la proximitat al nucli. Segons el paradigma de programació. Segons la traducció a codi màquina. Segons la generació.  1. Segons la proximitat al nucli La proximitat al nucli queda determinat per saber en quin moment s\u0026rsquo;executa aquest llenguatge. Poden ser llenguatges d\u0026rsquo;alt nivell, dins el sistema de capes, molt allunyat del nucli, o llenguatges de baix nivell propers al nucli.\n Els llenguatges de programació es poden classificar segons la seva proximitat al llenguatge màquina:\n   Llenguatges de baix nivell     Llenguatge de programació pròxim al nucli de la màquina i que només entén la màquina.   Es composa per codi binari (símbols 0 i 1).   És el llenguatge més bàsic i també més difícil d\u0026rsquo;entendre pels humans ja que totes les instruccions són tires de 0s i 1s.   És un llenguatge molt lligat a l\u0026rsquo;arquitectura de la màquina.   S\u0026rsquo;utilitzen adreces de memòria per fer referència a les dades.   Les instruccions tenen un format rígid.       Llenguatges ensambladors     Separen les característiques del maquinari de la tasca de programació.   Es substitueixen els codis numèrics per representacions textuals equivalents a les instruccions màquina que representen.   Segueixen tenint una forta relació amb els llenguatges màquina però permeten utilitzar adreces simbòliques i incloure línies de comentaris.       Llenguatges d\u0026rsquo;alt nivell     Alliberen el programador de tasques tedioses i complexes que frenen la productivitat i l\u0026rsquo;eficiència.   Tenen un gran nivell d\u0026rsquo;abstracció que fa innecessari el coneixement de l\u0026rsquo;arquitectura de la màquina.   Les instruccions s\u0026rsquo;expressen per caràcters alfanumèrics; permeten definir variables; disposen d\u0026rsquo;instruccions molt ponents de tipus aritmètic, lògiques, tractament de caràcters, etc .; són fàcils de corregir i actualitzar i fàcils d\u0026rsquo;aprendre.   Per contra, no són tant conscients en quant a consum de recursos.    2. Segons el paradigma de programació Un paradigma de programació és un enfoc particular/filosofia pel disseny i construcció de codi. Depenent de cada context resulta més idoni utilitzar-ne un o altre\n A grans trets diferenciarem entre\n  Llenguatges imperatius: - Descriu la programació com una seqüència instruccions o ordres que canvien l\u0026rsquo;estat d\u0026rsquo;un programa. - Formen part d\u0026rsquo;aquest tipus molts llenguatges d\u0026rsquo;alt nivell i d\u0026rsquo;ús general: python, c, java, c++ etc. - Es fixen en el COM es desenvolupa el codi (com s\u0026rsquo;aconsegueix un objectiu pas a pas). - En aquest paradigma s\u0026rsquo;inclouen altres paradigmes com el modular, orientació a objectes, concurrent, etc.\n  Llenguatges declaratius: - Es fixen en QUÈ descriu (declara la solució), es basa en les propietats de la solució buscada. - No es coneix l\u0026rsquo;algorisme usat per trobar aquesta solució. - No es coneix el rendiment i/o eficiència del codi a priori - Molt útil en la resolució de problemes i situacions determinades. - En aquest paradigma s\u0026rsquo;inclouen els paradigmes funcional, lògic i no procedimental.\n  Com a subtipus dels anteriors destaquem:\n   Programació estructurada   Utilitza únicament seqüències, instruccions condicionals i instruccions repetitives. Es tracta en la UF1 de M03 Programació.\n    Programació modular   El programa es dissenya per parts(mòduls). Es tracta en la UF2 de M03 Programació.\n    Programació orientada a objectes   Programació basada en la comunicació i el pas de missatges entre objectes (estructures amb atributs i mètodes). Es tracta en la UF4 de M03 Programació.\n    Programació concurrent   Útil quan hem de realitzar diverses accions a la vegada i utilitzant recursos compartits. Es tracta en M09 Programació de serveis.\n    Programació funcional   Tot el codi es basa en funcions, des de l\u0026rsquo;expressió mínima a qualsevol estructura complexa. Exemple d\u0026rsquo;aquest paradigma és el llenguatge Lisp o Haskel.\n    Programació lògica   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog.\n \n3. Segons la traducció a codi màquina Els llenguatges de programació poden tenir diferents tractaments fins a ser executats, així diferenciem els llenguatges interpretats, compilats i els híbrids.\n Desde que un programa és escrit i és executat per la màquina hi ha un seguit de passos que cal tenir presents:\n Anàlisi (lèxic, sintàtic i semàntic) Traducció(generació i optimització de codi)  Depenent de com es realitza aquesta traducció tenim llenguatges compilats i interpretats:\n   Llenguatges compilats     Una vegada el codi és analitzat es genera el codi objecte d\u0026rsquo;acord amb les característiques del compilador del llenguatge. Depenent del tipus de compilador l\u0026rsquo;objecte pot ser directament executable o necessita altres passos previs com l\u0026rsquo;acoblament, l\u0026rsquo;enllaçat i la càrrega (Com per exemple el llenguatge C).   Per tal de flexibilitzar el codi, els compiladors treballen amb biblioteques de mòduls objecte. Per incloure-les en el codi màquina final s\u0026rsquo;ha d\u0026rsquo;usar un enllaçador que retorna un únic programa executable.   Els programes objecte s\u0026rsquo;executen molt més ràpidament que els interpretats ja que estan optimitzats per uns determinats recursos HW, però no permet transportar codi objecte entre diferents plataformes d\u0026rsquo;execució.   Exemples de llenguatges els traductors són compiladors són FORTRAN, COBOL, C, PASCAL, ADA \u0026hellip;       Llenguatges interpretats     En aquest cas es duu a la vegada el procés de traducció i el d\u0026rsquo;execució. La seva forma de treball és anar analitzant instruccions de codi del programa font, generant el codi màquina corresponent i executant.   Són més lents que els compilats, per contra, són fàcilment transportables entre diferents màquines, ja que és el propi programa font el que es mou.   Exemples de llenguatge interpretat són PROLOG, i SQL, Javascript, Python, etc.       Llenguatges híbrids     Aprofiten el millor d\u0026rsquo;ambdós mons com Java o Visual Studio .NET. Són capaços de compilar el codi a un llenguatge intermedi denominat bytecode en JAVA i MSI en .NET, que després són interpretats per una màquina virtual (MVJ o .NET Framework), així aconsegueixen una substancial millora en el rendiment i mantenen la característica de transportabilitat entre diferents plataformes    4. Segons la generació Depenent de quan es va crear el llenguatge s\u0026rsquo;emmarca en unes necessitats i usos concrets que han donat lloc a generacions. Són seqüencials en el temps.\n    Primera generació   Són els que corresponen als llenguatges ja vistos de baix nivell o llenguatges màquina.\n    Segona generació   Són aquells que pertanyen als llenguatges assembladors.\n    Tercera generació   A la tercera generació pertanyen aquells llenguatges estructurats que seguien un ordre alhora d\u0026rsquo;executar les instruccions. Llenguatges com C, pascal, cobol, etc.\n    Quarta generació   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog. Els llenguatges de quarta generació, són els més propers a la sintaxi de la llengua humana, i s\u0026rsquo;acostumen a utilitzar en les creacions de bases de dades o com a llenguatges de programació dels llenguatges o sistemes d\u0026rsquo;autor. Són llenguages no procedimentals com SQL que permeten definir quins seran els resultats finals sense necessitat de preocupar-se per saber com fer-ho.\n    Cinquena generació   Amb la incorporació i expansió dels llenguatges orientats a objectes i amb la generalització de l\u0026rsquo;ús de les GUI, és possible abarca problemes de major abstracció. Alguns exemples són Java, C++, etc. S\u0026rsquo;ha generalitzat tant els IDEs de desenvolupament com els CLIs per cada servei/llenguatge.\n \n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3algor%C3%ADsmia/",
	"title": "Algorísmia",
	"tags": [],
	"description": "",
	"content": "Què és un algorisme? Un algorisme és un mètode per resoldre un PROBLEMA, són un conjunt d\u0026rsquo;operacions finites i ordenades que s\u0026rsquo;han de seguir per a la resolució d\u0026rsquo;un problema.\n Característiques dels algorismes\nLes característiques bàsiques d\u0026rsquo;un algorisme són:\n Ordenat. Cada instrucció té una posició dins el conjunt. Precís. Cada instrucció és unívoca i obeeix a un objectiu. Definit. Si es segueix un algorisme dues vegades, s\u0026rsquo;ha d\u0026rsquo;obtenir el mateix resultat cada vegada. Finit. L\u0026rsquo;algorisme ha d\u0026rsquo;acabar en algun moment, per tant, tindrà un nombre finit de passos. Un bon disseny algorítmic contindrà tres parts: Entrada (Input), Procés (Tractament de la informació) i Sortida (Output).  Pseudocodi El pseudocodi és un llenguatge informal d’alt nivell que usa les convencions i l’estructura d’un llenguatge de programació, però que està orientat a ser entès pels humans.\n Diagrama de flux Un diagrama de flux de control consisteix en una subdivisió de passes seqüencials, d’acord amb les sentències i estructures de control d’un programa, que mostra els diferents camins que pot seguir un programa a l’hora d’executar les seves instruccions. Cada passa s’associa a una figura geomètrica específica.\n Complexitat ciclomàtica La Complexitat ciclomàtica (en anglès, Cyclomatic Complexity) és una mètrica de programari en enginyeria de programari que proporciona una mesura quantitativa de la complexitat lògica d\u0026rsquo;un programa. Consisteix en comptar el nombre de camins necessaris per tal d\u0026rsquo;anar de la primera a la última instrucció passant per tots els camins possibles i cobrint tots els casos.\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/desenvolupamentpoo/",
	"title": "Desenvolupament de POO",
	"tags": [],
	"description": "",
	"content": "Exemples d\u0026rsquo;associació entre classes Exemple 1: Classe Triangle Creem una classe Triangle.\npublic class Triangle { private int side1; private int side2; private int side3; /** * Constructor per defecte. */ public Triangle(){ side1 = 3; side2 = 4; side3 = 5;\t} /** * Constructor que rep la mida dels tres costats. * @param nouSide1 Costat 1 * @param nouSide2 Costat 2 * @param nouSide3 Costat 3 */ public Triangle(int nouSide1, int nouSide2, int nouSide3){ side1 = nouSide1; side2 = nouSide2; side3 = nouSide3;\t} /** * Calcula el perímetre del triangle. * @return Perímetre del triangle */ public int perimetre(){ return side1+side2+side3; } /** * Calcula l'àrea del triangle. * @return Àrea del triangle */ public double area(){ double s = (side1+side2+side3)/2; double a = s*(s-side1)*(s-side2)*(s-side3); double area = Math.sqrt(a); return area; } /** * Prova de la classe. * @param args */ public static void main(String[] args){ Triangle triangle = new Triangle(10,14,15); System.out.println(\u0026quot;Àrea del triangle: \u0026quot; + triangle.area()); System.out.println(\u0026quot;Perímetre del triangle: \u0026quot; + triangle.perimetre()); } }  Exemple 2: Comptador d\u0026rsquo;un dígit Observem una possible implementació d\u0026rsquo;un comptador d\u0026rsquo;un sol dígit de 0-9.\npublic class Comptador { private int numComptador; /** * Definim la constructora */ public Comptador(){ numComptador = 0; } /** * Definim el getter de numCumptador * @return el valor del comptador */ public int getNumComptador(){ return numComptador; } /** * Definim el setter de numComptador * @param a */ public void setNumComptador(int a){ numComptador=a; } /** * Incrementa el comptador */ public void incrementaComptador(){ if (numComptador==9)numComptador=0; else numComptador++;\t} /** * Decrementa el comptador */ public void decrementaComptador() { if (numComptador==0)numComptador=9; else numComptador--; } public static void main(String[] args) { Scanner in = new Scanner (System.in); Comptador c = new Comptador(); System.out.println(\u0026quot;\\n EXERCICI COMPTADOR\u0026quot;); System.out.println(\u0026quot;\\n ---------------------\u0026quot;); System.out.println(\u0026quot;Valor Inicial: \u0026quot;+c.getNumComptador()); System.out.println(\u0026quot;Incrementem 15 vegades el comptador\u0026quot;); for (int h=0; h\u0026lt;15; h++){ c.incrementaComptador(); System.out.println(c.getNumComptador()); } System.out.println(\u0026quot;Decrementem 15 vegades el valor del comptador\u0026quot;); for (int h=0; h\u0026lt;15; h++){ c.decrementaComptador(); System.out.println(c.getNumComptador()); } } }  Exemple 3: Comptador de dos dígits (usant l\u0026rsquo;anterior) Ara volem un comptador de dos dígits però usant dos comptadors d\u0026rsquo;un sol dígit (exemple anterior)\npublic class Comptador2 { Comptador desenes; Comptador unitats; /** * Constructora de Comptador de dos dígits usant la classe Comptador */ public Comptador2(){ desenes = new Comptador(); unitats = new Comptador(); desenes.setNumComptador(0); unitats.setNumComptador(0); } /** * Mètode getter del comptador */ public String getNumComptador(){ return desenes.getNumComptador()+\u0026quot;\u0026quot;+unitats.getNumComptador(); } /** * Mètode setter del comptador * @param desenes * @param unitats */ public void setNumComptador(int desenes, int unitats){ this.desenes.setNumComptador(desenes); this.unitats.setNumComptador(unitats); } /** * Incrementa el comptador */ public void incrementaComptador(){ if(desenes.getNumComptador()==9 \u0026amp;\u0026amp; unitats.getNumComptador()==9){ desenes.setNumComptador(0); unitats.setNumComptador(0); }else if(unitats.getNumComptador()==9){ desenes.incrementaComptador(); unitats.setNumComptador(0); }else{ unitats.incrementaComptador(); } } /** * Decrementa el comptador */ public void decrementaComptador(){ if(desenes.getNumComptador()==0 \u0026amp;\u0026amp; unitats.getNumComptador()==0){ desenes.setNumComptador(9); unitats.setNumComptador(9); }else if(unitats.getNumComptador()==0){ desenes.decrementaComptador(); unitats.setNumComptador(9); }else{ unitats.decrementaComptador(); } } public static void main(String[] args) { Comptador2 c2 = new Comptador2(); System.out.println(\u0026quot;\\n\\n EXERCICI COMPTADOR 2\u0026quot;); System.out.println(\u0026quot;\\n -------------------------\u0026quot;); System.out.println(\u0026quot;Ara enlloc de tenir un comptador, tenim unitats i desenes (2 instàncies de la classe comptador)\u0026quot;); System.out.print(\u0026quot;Valor inicial: \u0026quot; + c2.getNumComptador()); System.out.println(\u0026quot;Incrementem valors fins a 101 i veiem què passa\u0026quot;); for (int h=0; h\u0026lt;101; h++){ c2.incrementaComptador(); c2.getNumComptador(); System.out.println(c2.getNumComptador()); } System.out.println(\u0026quot;Decrementem els valors fins a -102 i veiem què passa\u0026quot;); for (int h=0; h\u0026lt;102; h++){ c2.decrementaComptador(); c2.getNumComptador(); System.out.println(c2.getNumComptador()); } } }  Exemple 4: Classe amb alumnes Exemple de com usar una col·lecció d\u0026rsquo;objectes, en aquest cas tenim una classe Alumne i una classe Classe que serà un conjunt d\u0026rsquo;alumnes. Durant l\u0026rsquo;exemple veurem diferents conceptes:\n Alumne Test amb JUnit Alumne Classe Programa principal  Comencem amb la definició de la classe Alumne, a més a més:\n Mètodes Override Mètodes de còpia d\u0026rsquo;un objecte Comparator  import java.util.Comparator; public class Alumne implements Cloneable{ private int edat=18; private String nom; private String cognoms; //CONSTRUCTORES public Alumne(){ this(18,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;); } public Alumne(String nom, String cognoms){ this.nom = nom; this.cognoms = cognoms; } public Alumne(int edat, String nom, String cognoms){ this.edat = edat; this.nom = nom; this.cognoms = cognoms; } //CÒPIA OBJECTE public Alumne (Alumne a){ this.edat = a.getEdat(); this.nom = a.getNom(); this.cognoms = a.getCognoms(); } //GETTERS public int getEdat() { return edat; } public String getNom() { return nom; } public String getCognoms() { return cognoms; } //SETTERS public void setEdat(int edat) { this.edat = edat; } public void setNom(String nouNom) { nom = nouNom; } public void setCognoms(String cognoms) { this.cognoms = cognoms; } //MÈTODES SOBREESCRITS @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Alumne)) return false; Alumne alumne = (Alumne) o; if (getEdat() != alumne.getEdat()) return false; if (!getNom().equals(alumne.getNom())) return false; return getCognoms().equals(alumne.getCognoms()); } @Override public int hashCode() { int result = getEdat(); result = 31 * result + getNom().hashCode(); result = 31 * result + getCognoms().hashCode(); return result; } @Override public String toString() { return \u0026quot;Alumne{\u0026quot; + \u0026quot;edat=\u0026quot; + edat + \u0026quot;, nom='\u0026quot; + nom + '\\'' + \u0026quot;, cognoms='\u0026quot; + cognoms + '\\'' + '}'; } //DEFINIM COMPARATORS PER A ORDENAR /*Comparator per Nom*/ public static Comparator\u0026lt;Alumne\u0026gt; alumnesCompararPerNom = new Comparator\u0026lt;Alumne\u0026gt;() { public int compare(Alumne a1, Alumne a2) { String alumneNom1 = a1.getNom().toUpperCase(); String alumneNom2 = a2.getNom().toUpperCase(); //ordre ascendent return alumneNom1.compareTo(alumneNom2); //ordre descendent //return alumneNom2.compareTo(alumneNom1); }}; /*Comparator per Cognoms*/ public static Comparator\u0026lt;Alumne\u0026gt; alumnesCompararPerCognom = new Comparator\u0026lt;Alumne\u0026gt;() { public int compare(Alumne a1, Alumne a2) { String alumneCognom1 = a1.getCognoms().toUpperCase(); String alumneCognom2 = a2.getCognoms().toUpperCase(); //ordre ascendent return alumneCognom1.compareTo(alumneCognom2); //ordre descendent //return alumneCognom2.compareTo(alumneCognom1); }}; /*Comparator per Nom*/ public static Comparator\u0026lt;Alumne\u0026gt; alumnesCompararPerEdat = new Comparator\u0026lt;Alumne\u0026gt;() { public int compare(Alumne a1, Alumne a2) { int alumneEdat1 = a1.getEdat(); int alumneEdat2 = a2.getEdat(); //ordre ascendent if (alumneEdat1\u0026gt;=alumneEdat2) return 1; else return -1; //ordre descendent //if (alumneEdat1\u0026gt;=alumneEdat2) return -1; //else return 1; }}; //ALTRES MÈTODES public void saluda() { System.out.println(\u0026quot;Hola, sóc un alumne i em dic \u0026quot; + nom); } }  Tot seguit continuem amb una classe Test que ens ajudi a testejar la classe Alumne:\nimport org.junit.Test; import static org.junit.Assert.*; public class AlumneTest { @Test public void getEdat() throws Exception { Alumne a = new Alumne(); assertEquals(18, a.getEdat()); Alumne a2 = new Alumne(26, \u0026quot;\u0026quot;,\u0026quot;\u0026quot;); assertEquals(26, a2.getEdat()); } @Test public void getNom() throws Exception { Alumne a = new Alumne(); assertEquals(\u0026quot;\u0026quot;, a.getNom()); Alumne a2 = new Alumne(\u0026quot;Ramon\u0026quot;,\u0026quot;\u0026quot;); assertEquals(\u0026quot;Ramon\u0026quot;, a2.getNom()); } @Test public void getCognoms() throws Exception { Alumne a = new Alumne(); assertEquals(\u0026quot;\u0026quot;, a.getCognoms()); Alumne a2 = new Alumne(\u0026quot;\u0026quot;,\u0026quot;Torres\u0026quot;); assertEquals(\u0026quot;Torres\u0026quot;, a2.getCognoms()); } @Test public void setEdat() throws Exception { Alumne a = new Alumne(); a.setEdat(20); assertEquals(20, a.getEdat()); } @Test public void setNom() throws Exception { Alumne a = new Alumne(); a.setNom(\u0026quot;Miquel\u0026quot;); assertEquals(\u0026quot;Miquel\u0026quot;, a.getNom()); } @Test public void setCognoms() throws Exception { Alumne a = new Alumne(); a.setCognoms(\u0026quot;Torres\u0026quot;); assertEquals(\u0026quot;Torres\u0026quot;, a.getCognoms()); } @Test public void testClone() throws Exception { Alumne a = new Alumne(); Alumne clon = (Alumne)a.clone(); assertEquals(a,clon); Alumne a2 = new Alumne(30, \u0026quot;Mireia\u0026quot;, \u0026quot;Ramirez\u0026quot;); Alumne copia = new Alumne(a2); assertEquals(a2,copia); } @Test public void equals() throws Exception { Alumne a = new Alumne(20,\u0026quot;Joan\u0026quot;,\u0026quot;Rius\u0026quot;); Alumne b = new Alumne (20,\u0026quot;Joan\u0026quot;,\u0026quot;Rius\u0026quot;); assertEquals(a,b); assertNotNull(a); a = null; assertNull(a); } @Test public void testToString() throws Exception { Alumne a = new Alumne(); assertEquals(\u0026quot;Alumne{edat=18, nom='', cognoms=''}\u0026quot;, a.toString()); Alumne a2 = new Alumne(28,\u0026quot;Maria\u0026quot;,\u0026quot;Romero\u0026quot;); assertEquals(\u0026quot;Alumne{edat=28, nom='Maria', cognoms='Romero'}\u0026quot;, a2.toString()); }  Ara definim la classe Classe (com serà una classe amb alumnes)\nimport java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; public class Classe implements Cloneable{ private String grup; private String aula; private ArrayList\u0026lt;Alumne\u0026gt; alumnes = new ArrayList\u0026lt;\u0026gt;(); //CONSTRUCTORES public Classe(){ } public Classe(String grup, String aula, ArrayList\u0026lt;Alumne\u0026gt; grupAlumne){ this.grup = grup; this.aula = aula; this.alumnes = grupAlumne; } //CÒPIA OBJECTE public Classe (Classe classe){ this.grup = classe.getGrup(); this.aula = classe.getAula(); this.alumnes = classe.getAlumnes(); } //GETTERS public String getGrup() { return grup; } public String getAula() { return aula; } public ArrayList\u0026lt;Alumne\u0026gt; getAlumnes() { return alumnes; } public Alumne getAlumne(int posicio) { return alumnes.get(posicio); } //SETTERS public void setGrup(String grup) { this.grup = grup; } public void setAula(String aula) { this.aula = aula; } public void setAlumnes(ArrayList\u0026lt;Alumne\u0026gt; alumnes) { this.alumnes = alumnes; } //Mètodes típics de llistes public void afegirAlumne(Alumne a){ alumnes.add(a); } public boolean esBuit(){ return alumnes.size()==0; } public boolean existeixAlumne(Alumne a){ return alumnes.contains(a); } public int posicioAlumne(Alumne a){ return alumnes.indexOf(a); } public void eliminarAlumne(Alumne a){ alumnes.remove(a); } //MÈTODES SOBREESCRITS @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Classe classe = (Classe) o; if (!grup.equals(classe.grup)) return false; if (!aula.equals(classe.aula)) return false; return alumnes.equals(classe.alumnes); } @Override public int hashCode() { int result = grup.hashCode(); result = 31 * result + aula.hashCode(); result = 31 * result + alumnes.hashCode(); return result; } @Override public String toString() { return \u0026quot;Classe{\u0026quot; + \u0026quot;grup='\u0026quot; + grup + '\\'' + \u0026quot;, aula='\u0026quot; + aula + '\\'' + \u0026quot;, alumnes=\u0026quot; + alumnes + '}'; } }  Finalment anem a crear el programa principal.\nimport java.util.Scanner; public class AlumneClasseMain { public static void main(String args[]){ //Anem a crear una classe de 5 estudiants Classe classe = new Classe(); Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Introdueix el nom del grup\u0026quot;); String grup = sc.nextLine(); classe.setGrup(grup); System.out.println(); System.out.println(\u0026quot;Introdueix el nom de l'aula\u0026quot;); String aula = sc.nextLine(); classe.setAula(aula); System.out.println(); System.out.println(\u0026quot;Introduim 5 alumnes\u0026quot;); Alumne a = new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;); classe.afegirAlumne(a); a = new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;); classe.afegirAlumne(a); a = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); classe.afegirAlumne(a); a = new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;); classe.afegirAlumne(a); a = new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;); classe.afegirAlumne(a); System.out.println(); System.out.println(\u0026quot;Imprimim la classe:\u0026quot; + classe); System.out.println(); System.out.println(\u0026quot;L'aula està buida? \u0026quot; + classe.esBuit()); System.out.println(); System.out.println(\u0026quot;Si l'alumne 'a' existeix imprimeix-lo i diga'n la seva posició \u0026quot;); if(classe.existeixAlumne(a)){ System.out.println(\u0026quot;L'alumne 'a' és :\u0026quot; + a); System.out.println(\u0026quot;L'alumne 'a' es troba a la posició :\u0026quot; + classe.posicioAlumne(a)); System.out.println(\u0026quot;Eliminem aquest alumne :\u0026quot;); classe.eliminarAlumne(a); } System.out.println(); System.out.println(\u0026quot;Modifiquem informació de l'alumne 3 i a partir d'ara es dirà Pere Benitez i té 18 anys.\u0026quot;); classe.getAlumne(3).setNom(\u0026quot;Pere\u0026quot;); classe.getAlumne(3).setCognoms(\u0026quot;Benitez\u0026quot;); classe.getAlumne(3).setEdat(18); System.out.println(); System.out.println(); System.out.println(\u0026quot;Imprimim l'alumne 3\u0026quot; + classe.getAlumne(3)); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/condicional/",
	"title": "Estructura condicional",
	"tags": [],
	"description": "",
	"content": "Estructura condicional L\u0026rsquo;estructura de control condicional o alternativa permet prendre una decisió en un moment determinat sobre quines instruccions s\u0026rsquo;han d\u0026rsquo;executar. Donada una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet decidir entre un o varis camins d\u0026rsquo;execució.\n Existeixen diferents tipus d\u0026rsquo;estructura condicional.\n Estructura simple (if) Estructura composta (if/else) Estructura encadenada (if/else if/else) Sentència switch (switch) Combinació d\u0026rsquo;estructures  1. Estructura simple (if) Aquesta és la forma bàsica. Consisteix en una estructura en la qual si l' avaluació lògica és certa s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions, en cas contrari s\u0026rsquo;ometen aquestes instruccions. Consideracions:\n L\u0026rsquo;expressió lògica ha d\u0026rsquo;anar precedida de la paraula if i entre parèntesi (). Les instruccions que s\u0026rsquo;han d\u0026rsquo;executar es situen a continuació dins de les claus {}. Només s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions contingut entre {} quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a cert.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n}\nAcció3;     2. Estructura composta (if/else) La diferència respecte el cas anterior és que ara quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals també s\u0026rsquo;executarà un bloc d\u0026rsquo;instruccions.\n Aquestes instruccions aniran contingudes dins de parèntesis {} i precedides de la paraula else.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n} else {\nAcció3;\n}\nAcció4;     3. Estructura encadenada o múltiple (if/else if/ else) A vegades es dóna la situació que no volem decidir només entre dos camins d\u0026rsquo;execució, sinó que el problema ens requereix escollir entre diferents camins, així serà necessari introduir la figura del else if(). Comportament:\n En aquest cas el programa avalua la primera expressió booleana que es troba, si és certa executa el bloc d\u0026rsquo;instruccions que hi pertany. Però si l\u0026rsquo;avaluació és falsa anirà a la següent expressió booleana que es trobarà en un bloc else if(). I així consecutivament fins a la última. S\u0026rsquo;ha de tenir en compte que és important la prioritat en l\u0026rsquo;avaluació de les diferents expressions booleanes. Si s\u0026rsquo;avalua a cert en alguna expressió booleana JA NO avalua els següents casos, entra dins el bloc d\u0026rsquo;instruccions, s\u0026rsquo;executen les instruccions pertinents, i surt de l\u0026rsquo;estructura de control sense avaluar la resta de casos (podrien avaluar-se també a cert, per això és important la prioritat alhora d\u0026rsquo;establir els casos). Si s\u0026rsquo;introdueix un bloc else i cap expressió booleana s\u0026rsquo;avalua a cert, s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions corresponents a l\u0026rsquo;else.     Codi Diagrama de flux     Acció0;\nif ( cond1 ) {\nAcció1;\n} else if (cond2) {\nAcció2;\n}else if (cond3) {\nAcció3;\n}else if (cond4) {\nAcció4;\n}else {\nAcció5;\n}\nAcció6;     4. Sentència switch (switch) Aquesta estructura és útil quan en funció del valor d\u0026rsquo;una variable es poden executar camins d\u0026rsquo;instruccions diferents. Per exemple podríem pensar en un menú d\u0026rsquo;una app on tenim diferents opcions o un comandament a distància de la tele. Consideracions:\n En aquest cas s\u0026rsquo;avalua a == EL VALOR de la variable en qüestió i definirem les instruccions pertinents en cada cas. A l\u0026rsquo;inici d\u0026rsquo;aquesta estructura comença amb un switch seguida de la variable que volem avaluar entre parèntesi: switch (variable). Tot seguit, i entre claus {}, definim tots els casos que es volen tractar d\u0026rsquo;aquesta variable. Per a cada cas existeix un bloc case valor: amb tots els casos possibles. Si volem executar un bloc d\u0026rsquo;instruccions en cas que no es trobi cap dels valors desitjats per la variable sempre tenim el bloc default: que ens permet fer la mateixa funció que \u0026ldquo;l\u0026rsquo;else\u0026rdquo; en les estructures anteriors. En cada bloc case és necessari acabar-lo amb un break; necessari per a que ens surti de l\u0026rsquo;estructura switch. És una estructura que podríem simular amb una estructura encadenada o múltiple, la única diferència respecte a l\u0026rsquo;anterior és que en aquest cas, si no posem el break, sí que permetria executar més d\u0026rsquo;un case diferent.     Codi Diagrama de flux     Acció0;\nswitch ( expressio ) {\ncase valor1:\nAcció1;\nbreak;\ncase valor2:\nAcció2;\nbreak;\ncase valor3:\nAcció3;\nbreak;\ncase valor4:\nAcció4;\nbreak;\ndefault:\nAcció5;\n} Acció6;     5. Combinació d\u0026rsquo;estructures Moltes vegades els problemes que ens trobem a la vida real requereix de la composició de diferents estructures de control, així doncs es podria donar el cas que tinguéssim diferents estructures de control unes dins d\u0026rsquo;altres de forma jerarquitzada.\nExemple: En l\u0026rsquo;època actual de Coronavirus, donat els cribatges de PCRs per detectar casos positius ens interessaria detectar quins són els assimptomàtics. Així doncs m\u0026rsquo;invento un algorisme que permeti filtrar aquelles persones que ens interessa per realitzar les proves. És necessari que donades unes quantes dades ens digui si cal que faci alguna de les proves o no.\n Volem analitzar les persones entre 18 i 40 anys, d\u0026rsquo;aquestes es farà la prova bàsica de PCR, però les noies embarassades no realitzaran aquesta bàsica sinó que faran una prova més avançada. Pel que fa a les persones majors de 40 anys els hi realitzarem una prova avançada de PCR i un test d\u0026rsquo;esforç físic.  Exemples  Crea un programa on es mostri el resultat de sumar dos nombres sempre que la suma de tots dos sigui inferior o igual a 15. (exemple estructura simple)  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int suma = num1 + num2; if( suma \u0026lt;= 15) { System.out.println(num1+num2); }  Crea un programa que permeti a dir, donats dos nombres per l\u0026rsquo;usuari, si són múltiples l\u0026rsquo;un a l\u0026rsquo;altre. (exemple estructura composta)  System.out.println(\u0026quot;Entra el 1r nombre\u0026quot;); int num1 = sc.nextInt(); System.out.println(\u0026quot;Entra el 2n nombre\u0026quot;); int num2 = sc.nextInt(); if(num1%num2 == 0 || num2%num1 == 0){ System.out.println(\u0026quot;Són divisors\u0026quot;); } else { System.out.println(\u0026quot;No són divisors\u0026quot;); }  Creeu un programa que permeti introduir dos nombres i realitzar una operació sobre la base de l\u0026rsquo;nombre de codi, 1, 2 o 3 permeti restar, multiplicar o dividir els dos nombres i mostrar el resultat per pantalla.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int opcio = sc.nextInt(); if(opcio==1)System.out.println(num1 - num2); else if(opcio == 2) System.out.println(num1 * num2); else if(opcio == 3) System.out.println(num1 / num2); else System.out.println(\u0026quot;Opcio no correcta.\u0026quot;);  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int codi = sc.nextInt(); int resultat=0; if(codi==1) { resultat = operand1 - operand2; }else if(codi==2){ resultat = operand1 * operand2; }else if(codi==3){ resultat = operand1 / operand2; }else{ System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat);  El mateix exemple anterior però ara amb un switch.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int codi = sc.nextInt(); int resultat=0; switch(codi) { case 1: resultat = operand1 - operand2; break; case 2: resultat = operand1 * operand2; break; case 3: resultat = operand1 / operand2; break; default: System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat); switch(codi) { case 1: case 2: case 3: System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot; + resultat); }  Crea un programa que donats 4 números indiqui si els números són iguals i quin d\u0026rsquo;ells és el menor i major nombre de tots ells. El programa a més haurà de mostrar per pantalla el resultat de restar el major pel menor d\u0026rsquo;ells i el resultat de multiplicar els altres dos.  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int num3 = sc.nextInt(); int num4 = sc.nextInt(); int max = num1; int min = num1; int mult; /** * * Són iguals?? */ if(num1 == num2 \u0026amp;\u0026amp; num1 == num3 \u0026amp;\u0026amp; num1 == num4) System.out.println(\u0026quot;Són iguals\u0026quot;); else System.out.println(\u0026quot;No són iguals\u0026quot;); /** * PROBLEMA DEL MAJOR MENOR 5 OPCIONS * */ //OPCIO 1 força bruta if(num2\u0026gt;num1 \u0026amp;\u0026amp; num2\u0026gt;num3 \u0026amp;\u0026amp; num2\u0026gt;num4)max = num2; else if(num3\u0026gt;num1 \u0026amp;\u0026amp; num3\u0026gt;num2 \u0026amp;\u0026amp; num3\u0026gt;num4) max = num3; else if(num4\u0026gt;num1 \u0026amp;\u0026amp; num4\u0026gt;num2 \u0026amp;\u0026amp; num4\u0026gt;num3) max = num4; if(num2\u0026lt;num1 \u0026amp;\u0026amp; num2\u0026lt;num3 \u0026amp;\u0026amp; num2\u0026lt;num4)min = num2; else if(num3\u0026lt;num1 \u0026amp;\u0026amp; num3\u0026lt;num2 \u0026amp;\u0026amp; num3\u0026lt;num4) min = num3; else if(num4\u0026lt;num1 \u0026amp;\u0026amp; num4\u0026lt;num2 \u0026amp;\u0026amp; num4\u0026lt;num3) min = num4; //OPCIO 2 comparem el max amb tots i el min amb tots individualment max = num1; if(num2\u0026gt;max) max = num2; if(num3\u0026gt;max) max = num3; if(num4\u0026gt;max) max = num4; min = num1; if(num2\u0026lt;min) min = num2; if(num3\u0026lt;min) min = num3; if(num4\u0026lt;min) min = num4; //OPCIO 3 a Semifinals comparant! int max1,max2, min1,min2; if(num1\u0026gt; num2)max1 = num1; else max1 = num2; if(num3 \u0026gt; num4) max2 = num3; else max2=num4; if(max1 \u0026gt; max2) max = max1; else max=max2; if(num1 \u0026lt; num2)min1 = num1; else min1 = num2; if(num3 \u0026lt; num4) min2 = num3; else min2=num4; if(min1 \u0026gt; min2) min = min1; else min=min2; //OPCIO 4 semifinals math.max math.min max1 = Math.max(num1,num2); max2 = Math.max(num3,num4); max = Math.max(max1,max2); min1 = Math.min(num1,num2); min2 = Math.min(num3,num4); min = Math.min(min1,min2); //OPCIO 5 math.max i math.min max = Math.max (Math.max(num1,num2), Math.max(num3,num4)); min = Math.min (Math.min(num1,num2), Math.min(num3,num4)); System.out.println(max-min); //Segona part de l'activitat on es realitza la multiplicacio amb els que no són major i menor if( (max==num1 \u0026amp;\u0026amp; min==num2) || (max==num2 \u0026amp;\u0026amp; min==num1))mult=num3 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num1))mult=num2 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num1))mult=num2 * num3; else if( (max==num2 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num2))mult=num1 * num4; else if( (max==num2 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num2))mult=num1 * num3; else if( (max==num3 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num3))mult=num1 * num2; //Solució utilitzant Math.mix i Math.max per extreure valors que no siguin ni màxim ni mínim. int min3 = Math.min (Math.max(num1,num2), Math.max(num3,num4)); int max3 = Math.max (Math.min(num1,num2), Math.min(num3,num4)); int mult2 = min3 * max3;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/iteratiu/",
	"title": "Estructura iterativa",
	"tags": [],
	"description": "",
	"content": "Estructura iterativa L\u0026rsquo;estructura de control iterativa permet reproduir un bloc d\u0026rsquo;instruccions un nombre de vegades determinat.\nMentre es compleixi una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet executar un bloc d\u0026rsquo;instruccions determinat. Anomenarem bucle el bloc d\u0026rsquo;instruccions que es repeteixen i iteració a cadascuna de les vegades que es repeteix.\n Característiques generals:  Tots els bucles tenen:\n Una precondició: Estat abans d\u0026rsquo;entrar al bucle Una postcondició:Estat al sortir de bucle Una expressió booleana: mentre es compleixi l\u0026rsquo;expressió booleana s\u0026rsquo;itera el bucle, un cop l\u0026rsquo;expressió booleana s\u0026rsquo;avalua a fals es \u0026ldquo;surt\u0026rdquo; del bucle i es continua amb l\u0026rsquo;execució de les instruccions següents. Variable de control: Ens serveix per controlar el nombre d\u0026rsquo;iteracions. Aquesta variable pot estar englobada en un dels següents grups:  acumulador: guardem en una variable una operació concreta. comptador: augmentem o disminuïm una variable \u0026ldquo;comptant\u0026rdquo; iteracions. booleana: pot ser simplement una variable booleana que es manipuli dins el bucle.     Un bucle necessita:\n1. Una condició de sortida: cal que l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals per sortir del bucle, sinó provocarem un bucle infinit.\n2. La variable de control ens ha d\u0026rsquo;acostar pas a pas a complir amb la condició de sortida del bucle.\n3. Dins el bucle acostumen a ver instruccions amb l\u0026rsquo;objectiu de buscar un resultat.\n Existeixen diferents estructures iteratives.\n While For Do while Combinació d\u0026rsquo;estructures  1. While L\u0026rsquo;estructura bàsica d\u0026rsquo;un bucle while en Java és:\nwhile(expressió booleana){ Instruccions del bucle }  Com ja s\u0026rsquo;ha explicat, mentre s\u0026rsquo;avaluï l\u0026rsquo;expressió booleana a cert s\u0026rsquo;executaran totes les instruccions contingudes en les claus {}. Quan es deixi de complir l\u0026rsquo;expressió booleana el fil d\u0026rsquo;execució sortirà del bucle i continuarà amb la següent instrucció que hi hagi després.\nConsideracions:\n Si l\u0026rsquo;expressió no avalua a una expressió booleana donarà un error de compilació. Si no s\u0026rsquo;apliquen mecanismes que modifiquen el comportament de l\u0026rsquo;expressió booleana aconseguirem un bucle infinit.     Codi Diagrama de flux     Acció1;\nwhile ( cond ) {\nAcció2;\n}\nAcció4;     2. For El for és una estructura que permet realitzar recorreguts a un conjunt de dades de forma simple. Ens permet condensar la funcionalitat de bucle en una sola línia. Per exemple podem recorre els nombres del 1 al 10 de la següent manera:\nfor(int i=1; i \u0026lt;= 10; i++){ System.out.println(i); }  Com s\u0026rsquo;observa, dins dels parèntesi \u0026ldquo;()\u0026rdquo; tenim tres instruccions separades per \u0026ldquo;;\u0026rdquo; :\n Inicialització d\u0026rsquo;una variable iteradora abans d\u0026rsquo;entrar al bucle (int i=1). Després tenim l\u0026rsquo;expressió booleana igual com posaríem en un bucle while (i\u0026lt;=10). Finalment tenim el pas que ens assegura que el bucle acaba (i++).  Així doncs\nfor (inicialització Iterador; Expressió booleana; Modificació Iterador)\n Qualsevol bucle while es pot transformar en un bucle for i viceversa.\n Així doncs, l\u0026rsquo;exemple anterior si el transformem en un while queda de la següent manera:\nint i=1; //Inicialització variable while( i \u0026lt;= 10 ){ //Expressió booleana System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }  3. Do while Aquesta estructura no és gaire utilitzada i és similar a l\u0026rsquo;estructura while. La diferència és que en el while abans de realitzar cap iteració es comprova l\u0026rsquo;expressió booleana, en canvi amb el do while primer es realitzar una iteracio i després es comprova l\u0026rsquo;expressió booleana. A efectes pràctics si estem segurs que existeix almenys una iteració es pot usar aquesta estructura.\nEl cas anterior fet en do while seria:\nint i=1; //Inicialització variable do { System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }while( i \u0026lt;= 10 ); //Expressió booleana     Codi Diagrama de flux     Acció1;\ndo {\nAcció2;\n} while ( cond );\nAcció3;     4. Combinació d\u0026rsquo;estructures Moltes vegades els nostres programes requereixen de més d\u0026rsquo;un bucle encadenat, per exemple quan resseguim una matriu de dades. Imagineu-vos un programa que escanegi un tauler d\u0026rsquo;escacs, no només ha de llegir files, sinó que també ha de llegir columnes, així doncs l\u0026rsquo;estructura seria la següent:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } }  En l\u0026rsquo;exemple anterior per cada posició ièssima es recorre el bucle 8 vegades per cada j. Així per cada fila recorrem totes les columnes. Si mirem l\u0026rsquo;execució del bucle obtenim:\nPosició 1 1 Posició 1 2 Posició 1 3 Posició 1 4 Posició 1 5 Posició 1 6 Posició 1 7 Posició 1 8 Posició 2 1 Posició 2 2 Posició 2 3 Posició 2 4 Posició 2 5 Posició 2 6 Posició 2 7 Posició 2 8 Posició 3 1 Posició 3 2 Posició 3 3 ... Posició 8 8  En aquest cas estem parlant de dos bucles que són independents entre ells. Ja que per cada bucle interior no té afectació en l\u0026rsquo;exterior.\nPerò a vegades és necessari que els bucles siguin dependents, en aquest cas sí que hi hauria afectació. Modifiquem el programa anterior perquè per exemple enlloc de mostrar tot el tauler de posicions només vull mostrar aquelles que es troben per sobre de la diagonal:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ if(i \u0026lt; j) { System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } } }  En aquest cas, si executeu veureu que només mostra la meitat superior de posicions. Això és així perquè en el bucle interior realitzem una operació que DEPÈN de la variable i que pertany al primer bucle, per tant el bucle interior depèn de l\u0026rsquo;exterior.\nExemples  Fer un programa que llegeixi dos nombre enters n 1 i n 2 amb n 1 \u0026lt; n 2 i escrigui tots els nombres enters dins l’interval [n 1 , n 2 ] en ordre creixent. Aquest és un exemple de recorregut on la variable n1 fa de comptador.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); while(n1\u0026lt;=n2) { System.out.println(n1); n1++; }  Fer un programa que llegeixi dos nombre enters n 1 i n 2 amb n 1 \u0026lt; n 2 i escrigui els nombres enters parells que hi ha dins l’interval [n 1 , n 2 ] en ordre creixent. El nombre zero es considera parell.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); for(int i=n1; i \u0026lt;= n2; i++) { if(i%2==0)System.out.println(i); } //2naOpcio (meitat d'iteracions) if(n1%2!=0)n1++; while(n1\u0026lt;=n2) { System.out.println(n1); n1 = n1+2; }  Fer un programa que llegeixi el valor de la base, un nombre enter i l’exponent, un nombre enter no negatiu, i escrigui el valor de la potència a b . No emprar la funció Math.pow(). En aquest cas resultat fa d' acumulador d\u0026rsquo;un resultat que es mostra al final.  int base = sc.nextInt(); int exponent = sc.nextInt(); int i = 0; int resultat = 1; while(i \u0026lt; exponent) { resultat = resultat * base; i++; } System.out.println(resultat);  Fer un programa que llegeixi un nombre enter i escrigui si és un nombre primer o no. Un nombre enter és primer si es més gran que 1 i només és divisible per 1 i per ell mateix.  /* Fixeu-vos amb l'expressió booleana del bucle, en aquest cas es fa ús d'una variable booleana per sortir del bucle i no continuar iterant, en cas que ja haguem descobert la solució i no sigui necessari continuar iterant. */ System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); //inicialitzo variables,index=n/2 i analitzem tots els possibles divisors de n/2 fins a 1. boolean esPrimer = true; int index = n/2; //En la condició del bucle,si trobem un divisor ja no cal que continuem buscant i acabem while(index \u0026gt; 1 \u0026amp;\u0026amp; esPrimer){ if(n % index == 0) esPrimer=false; index--; } //Escrivim solucio String sol = (!esPrimer)? \u0026quot;NO és primer\u0026quot; : \u0026quot;És primer\u0026quot; ; System.out.println(sol);  Fer un programa que llegeixi un nombre enter i escrigui si és capicua o no.Considerarem també capicues els nombres enters d\u0026rsquo;una xifra.  System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); int valorInicial = n; int capicua = 0; while(n\u0026gt;0){ capicua = capicua*10; capicua = capicua + n%10; System.out.println(capicua); n = n/10; } System.out.println(capicua); if(valorInicial == capicua) System.out.println(n+ \u0026quot;és un nombre capicua\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/llibreries/",
	"title": "Llibreries",
	"tags": [],
	"description": "",
	"content": "Definició En el context de la programacio una llibreria es un conjunt de codi re-utilitzable, encapsulat d\u0026rsquo;alguna manera (paquets, classes, moduls, dll, \u0026hellip;) i documentat adequadament.\n En el cas de Java tenim llibreries de classes i les seves propietats. Per exemple podriem considerar la classe Math, que ens proporciona un conjunt de funcions matematiques, una llibreria en si mateixa. Ex:  int x = -15; int y = Math.abs(x);   Tambe tenim paquets com java.util que agrupen de forma organitzada un conjunt de classes amb unes funcionalitats comunes (utilitats). Veieu mes exemples de les llibreries del SDK a la última pagina del document. import java.util.Scanner;  import java.util.Scanner;  Llibreries de classes: paquets  Una llibreria de classes, o package (paquet) en Java, es un conjunt de classes vinculades entre elles d’acord a algun criteri tematic o d’organitzacio del seu codi. Els paquets s\u0026rsquo;organitzen de forma jerarquica, de manera que podem crear sub-paquets dins d\u0026rsquo;altres paquets: paquet1.paquet2.paquetn Els noms dels packages s’escriuen tots en minúscula i separant paquets i sub-paquets per un punt. Totes les classes de Java pertanyen a algun package. En cas de no incloure cap sentencia package, es considera que aquella classe pertany a un package especial anomenat per defecte (default package). Donada una classe, aquesta únicament pot pertanyer a un paquet. Donat un paquet, a dintre seu mai hi poden haver dues classes amb el mateix nom.  Inclusio de classes dins d\u0026rsquo;un paquet  Per incloure una classe dins d\u0026rsquo;un paquet nomes cal incloure la següent sentencia al inici del fitxer de codi font, abans de qualsevol altra instruccio: package nomdelpaquet Ús de classes d\u0026rsquo;altres paquets Per usar classes definides en altres paquets cal usar la sentencia import:  import nomdelpaquet.Classe; import nomdelpaquet.*; package dam.uf2; import java.util.*; public class ComptaChar { ...  Estructura dels fitxers dins dels paquets  Els arxius .class pertanyents a paquets i subpaquets han d\u0026rsquo;estar organitzats de manera adequada perque tant el compilador com la maquina virtual de Java puguin utilitzar-los. Cada paquet es situa en un directori. Cada sub-paquet s\u0026rsquo;ubica en un directori de nivell inferior, i així successivament. El nom de cada directori ha de ser el del propi paquet.  Paquets bàsics del JDK (Java Development Kit)  java.lang: es el paquet principal i el compilador l’incorpora de manera automatica (no cal importar-lo). Conte les classes basiques de Java, incloent-hi el tractament de cadenes de caracters, el maneig de nombres i funcions matematiques, l’acces als recursos del sistema, i la programacio multiarea. java.io: controla les operacions d’entrada i sortida i els arxius. java.util: conte classes i metodes de proposits molt diversos, com ara generacio de nombres aleatoris (Random), tractament d\u0026rsquo;arrays (Arrays), propietats del sistema, etc. java.net: dona suport a les comunicacions TCP/IP. Inclou les classes que fan referencia a la comunicacio en xarxa. java.applet: conte nomes la classe applet que permet el desenvolupament d’aplicacions incrustades en pagines HTML. java.awt: conte les classes i els metodes de l’Abstract Windows Toolkit, independents del sistema, per al maneig de la interfície d’usuari. java.awt.image: conte classes i metodes independents del sistema, neces- saris per al maneig de grafics i imatges. java.awt.peer: com que les classes i els metodes son específics de cada sistema, java.awt.peer conte les classes necessaries per connectar els components defi- nits en el paquet java.awt amb els components correctes de cada sistema.  Exemple Si tenim un projecte amb el següent arbre de fitxers:\nL\u0026rsquo;estructura que necessitem en cada fitxer per poder veure la resta de fitxers és la següent:\n En el Main.java principal necessitem importar els dos fitxers que no tenim al mateix directori:  import classes.classes2.Funcions2; import classes.Funcions;   Per emprar Funcions3 desde Main no ens cal indicar-hi res ja que es troba al mateix directori i per tant ja és visible per Main.\n  Funcions es troba dins el package classes, per això en el Main cal importar-lo i en Funcions.java cal indicar-li a quin package pertany:\n  package classes;  De la mateixa manera Funcions2 es troba dins el package classes.classes2, per això en el Main cal importar-lo i en Funcions3.java cal indicar-li a quin package pertany:  package classes.classes2;  Aquí teniu l'enllaç al projecte: Projecte imports/package\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/cadenescaracters/",
	"title": "Tractament cadena de caràcters",
	"tags": [],
	"description": "",
	"content": " Un String és una classe que permet treballar amb cadenes de caràcters. La classe String de Java ens dóna moltes funcionalitats que ens permeten realitzar moltes tasques d\u0026rsquo;una forma senzilla.\n La funció sobre la classe String la trobareu a: Java Oracle Classe String\nInicialització La manera de declarar i inicialitzar aquest objecte és com en els tipus primitius. Amb la variable String diem que la variable str i strBuit emmagatzemen un String i a continuació s\u0026rsquo;hi assigna un valor. En el cas del valor \u0026quot;\u0026quot; assignem un String buit.\nString str = \u0026quot;El primer string\u0026quot;; String strBuit = \u0026quot;\u0026quot;;  Funcionalitats interessants /* longitud del string STR.LENGTH() */ System.out.println(\u0026quot;longitud \u0026quot; + str.length()); /* Caràcter en la posició pos de str. STR.CHARAT(int) */ str = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;En la posició 4 hi ha: \u0026quot; + str.charAt(4)); System.out.println(\u0026quot;En la posició 11 hi ha: \u0026quot; + str.charAt(11)); /* Comença o acaba l'string en... STARTSWITH OR ENDSWITH */ str = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;comienza por El \u0026quot; + str.startsWith(\u0026quot;El\u0026quot;)); System.out.println(\u0026quot;termina por programa \u0026quot; + str.endsWith(\u0026quot;programa\u0026quot;)); /* Posició d'un caràcter dins un string STR.INDEXOF('x') Ocurrència a partir d'un cert caràcter STR.INDEXOF('x', pos) */ int pos = str.indexOf('p'); System.out.println(\u0026quot;posición de la letra p \u0026quot; + pos); //segona ocurrencia de p pos = str.indexOf('p', pos + 1); /* Comparació entre dos strings STR.COMPARETO(STRING2) */ str = \u0026quot;Pep\u0026quot;; System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Xavi\u0026quot;)); System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Gines\u0026quot;)); System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Pep\u0026quot;)); /* Substring amb UNA variable posicioInicial indica a a partir de quin caràcter volem recollir el substring fins al final. STR.SUBSTRING(posicioInicial) Substring amb Dues variables determinen quin substring obtindrem entre les dues posicions STR.SUBSTRING(posicioInicial, posicioFinal) */ str = \u0026quot;El lenguaje Java\u0026quot;; System.out.println(\u0026quot;Substring \u0026quot; + str.substring(12)); //Java System.out.println(\u0026quot;Substring \u0026quot; + str.substring(3, 11)); //lenguaje /* Eliminar espais en blanc STR.TRIM() */ str = \u0026quot; 12 \u0026quot;; System.out.println(\u0026quot;string original :\u0026quot; + str); System.out.println(\u0026quot;string sin espacios en blanco :\u0026quot; + str.trim()); /* Convertir array a String ARRAYS.TOSTRING(array) */ int[] arrayNumeric = {24, 2, 4, -12}; System.out.println(\u0026quot;número --\u0026gt; string \u0026quot; + Arrays.toString(arrayNumeric)); /* Convertir strings a enters i decimals INTEGER.PARSEINT(str.TRIM()); DOUBLE.VALUEOF(str).DOUBLEVALUE(); */ str = \u0026quot;12\u0026quot;; int numeroInt = Integer.parseInt(str.trim()); System.out.println(\u0026quot;string --\u0026gt; número \u0026quot; + numeroInt); str = \u0026quot;12.35 \u0026quot;; double numeroDouble = Double.valueOf(str).doubleValue(); System.out.println(\u0026quot;string --\u0026gt; número \u0026quot; + numeroDouble); /* Separar String en diferents cadenes str.SPLIT(\u0026quot; \u0026quot;); --\u0026gt; Separa les diferents paraules per espais */ String cadena = \u0026quot;Hola que tal com estas\u0026quot;; String[] vectorSeparat = cadena.split(\u0026quot; \u0026quot;); for (String a : vectorSeparat) System.out.println(a); /* EXEMPLE D'ÚS: De cada alumne volem obtenir el nom amb el format correcte i el dni. */ String alumnes = \u0026quot;\u0026quot; + \u0026quot;Nom; Cognoms; DNI\\n\u0026quot; + \u0026quot;xavi; sanChO; 111111a\\n\u0026quot; + \u0026quot;pep; beÀ; 222222b\\n\u0026quot;; String[] rows = alumnes.split(\u0026quot;\\n\u0026quot;); for (int i = 1; i \u0026lt; rows.length; i++) { String[] dades = rows[i].split(\u0026quot;;\u0026quot;); String nom = dades[0]; String cognoms = dades[1]; String nomComplet = nom + \u0026quot; \u0026quot; + cognoms; String[] partsNom = nomComplet.split(\u0026quot; \u0026quot;); String capitalitzat = \u0026quot;\u0026quot;; for (String part : partsNom) { String senseEspais = part.trim(); if (!senseEspais.equals(\u0026quot;\u0026quot;)) { String inicial = part.substring(0, 1).toUpperCase(); String resta = part.substring(1).toLowerCase(); capitalitzat += inicial + resta + \u0026quot; \u0026quot;; } } System.out.println(capitalitzat); String dni = dades[2].trim(); System.out.println(dni); }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/programacioavancadapoo/",
	"title": "Programació avançada de POO",
	"tags": [],
	"description": "",
	"content": "En aquesta segona part de la UF coneixerem i implementarem característiques de la POO que dónen sentit al desenvolupament d\u0026rsquo;aplicacions:\n  Herència\n  Polimorfisme i classes abstractes\n  Interfícies\n  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/",
	"title": "Programació estructuada",
	"tags": [],
	"description": "",
	"content": "Què és la programació estructurada? La programació estructurada és un paradigma de programació en el qual les instruccions de codi s\u0026rsquo;executen de forma ordenada utilitzant només tres estructures: seqüencial, condicional i repetitiva.\n S\u0026rsquo;anomena estructura a la manera en què diferents parts es combinen per construir un tot. Un programa tindrà l\u0026rsquo;estructura corresponent a la forma en què les diferents accions individuals o avaluacions parcials es combinen per construir el programa en el seu conjunt.\nEls fonaments de l\u0026rsquo;anomenada programació estructurada es van establir a principis dels anys seixanta i es van consolidar amb els treballs de Dijkstra, Bohm.. El resum dels seus postulats és el següent: \u0026ldquo;es diu que un programa és estructurat si s\u0026rsquo;expressa únicament mitjançant combinacions de les estructures bàsiques\u0026rdquo;:\n seqüencial condicional iterativa  Estructura bàsica: Totes les estructures de control tenen un únic punt d\u0026rsquo;entrada i un únic punt de sortida.\nTot seguit repassarem les tres estructures de control: seqüencials, condicionals i iteratives en Java.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/recursivitat/",
	"title": "Recursivitat",
	"tags": [],
	"description": "",
	"content": " Definició Un subprograma és recursiu quan al llarg de la seva execució s’efectua alguna crida a si mateix.\nDes d’un punt de vista tècnic s’efectua una crida d’un programa a un altre programa, amb la particularitat de que aquest programa és el mateix.\n PARTS de la crida recursiva En una situació recursiva s’ha de pensar en:\n Quan acaba? Cas Base:   Solució senzilla No s’activa més recursió. En tot algorisme recursiu hi ha d’haver almenys un cas base  Com continua? Cas recurrent:   Efectuarem una crida a la mateixa funció per acostar-nos al cas base. Poden incloure’s passos addicionals a més de la crida recursiva  Avantatges  Què ofereix la recursivitat?\n  Codi elegant i senzill Solucions òptimes a problemes iteratius que computacionalment són complexos     Què NO ofereix la recursivitat?\n  Creació de moltes variables Guardem molta informació de crides a funció en memòria.    Com funciona? El procés d’execució recursiu consisteix en una cadena de generació de crides a la mateixa funció. En cada crida:\n Es reserva l’espai en memòria necessari per emmagatzemar els paràmetres i els objectes locals usats en el subprograma. Es reben els paràmetres i es cedeix l’execució d’instruccions al subprograma que comença a executar-se. A l’acabar la seva feina, allibera l’espai reservat, els identificadors locals deixen de tenir vigència i passa l’execució de la instrucció següent a la crida.  Comparativa Iteratiu vs Recursiu    Iteratiu Recursiu     Realitza una petició Realitza una petició   Repeteix el cos del bucle Repeteix les crides a mètodes recursius   Té una condició d’acabament Té una condició d’acabament   S’acaba quan es compleix la condició de continuació del bucle S’acaba quan la crida arriba al cas base, desencadenant una sequència de crides enrera   S’ha de complir la condició d’acabament S’ha de complir que s’arriba al cas base    TOT algorisme iteratiu es pot representar recursiu i tot algorisme recursiu es pot representar iteratiu\n Exemple factorial Iteratiu\nint factorial; int nombre = sc.nextInt(); for(int i=0; i \u0026lt; nombre; i++){ factorial = factorial * i; }  Recursiu\nint nombre = 5; 5 * factorial(4) 4 * factorial(3) 3 * factorial(2) 2 * factorial(1) 1; public int factorial (n){ if(n==1) return 1; else return n * factorial (n-1); }  Exemples Suma de dos nombres: public static int suma(int a, int b) { if (b == 0) return a; else if (a == 0) return b; else return 1 + suma(a, b - 1); }  Suma elements d'un vector: public static int sumaVector(int t[], int n){ if(n==0)return t[0]; else return t[n] + sumaVector(t,n-1); }  Cerca dicotòmica: public class CercaDicotomica { public static void main(String[] args) { CercaDicotomica programa = new CercaDicotomica(); programa.inici(); } public void inici() { int[] array = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}; int cercaDivuit = cercaDicotomica(array, 0, array.length-1, 18); int cercaCinc = cercaDicotomica(array, 0, array.length-1, 5); System.out.println(\u0026quot;Cerca del 18: \u0026quot; + cercaDivuit); System.out.println(\u0026quot;Cerca del 5: \u0026quot; + cercaCinc); } /** Cerca dicotòmica recursiva sobre un array d'enters. * * @param array On es fa la cerca * @param inici Posició inicial de la cerca * @param fi Posició final * @param valor Valor a cercar * @return Índex on és el valor, o -1 si no existeix */ public int cercaDicotomica(int[] array, int inici, int fi, int valor) { //CAS BASE: No s'ha trobat el valor if (inici \u0026gt; fi) return -1; //Es calcula la posició central entre els dos índexs de cerca int pos = inici + (fi - inici) / 2; //CAS RECURSIU: Si el valor es menor que la posició que s'ha mirat //llavors cal seguir cercant per la part \u0026quot;dreta\u0026quot; de l'array if (array[pos] \u0026gt; valor) return cercaDicotomica(array, inici, pos - 1, valor); //CAS RECURSIU: Si el valor és més gran que la posició que s'ha mirat //llavors cal seguir cercant per la part \u0026quot;esquerra\u0026quot; de l'array else if (array[pos] \u0026lt; valor) return cercaDicotomica(array, pos + 1, fi, valor); //CAS BASE: És igual, per tant, s'ha trobat else return pos; }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/coleccions/",
	"title": "Col·leccions",
	"tags": [],
	"description": "",
	"content": " Les Collections representen grups d\u0026rsquo;objectes, anomenats elements. Podem trobar diversos tipus de col·leccions, segons si els seus elements estan ordenats, o si permetem repetició d\u0026rsquo;elements o no.\n La informació de Java Oracle corresponen a les Collections la trobareu aquí.\nCom observareu de l\u0026rsquo;enllaç anterior una Collection és una interfície de la qual heradaran totes les estructures de dades que veurem a continuació. En aquesta interfície hi trobareu un conjunt de mètodes que totes les estructures tenen implementades: add(), size(), isEmpty(), etc. Aquests operadors són polimòrfics això vol dir que amb la mateixa denominació efectuen la mateixa funcionalitat però per estructures de dades diferents. Ex: el mateix mètode add() ens serveix per afegir un element a un HashSet a un ArrayList o a un LinkedList.\nSempre que tinguem un tipus de dades que contingui una col·lecció implementarà totes les funcions comunes a ella i les podrem utilitzar. En aquesta interfície trobem una sèrie de mètodes que ens serviran per accedir als elements de qualsevol col·lecció de dades, sigui del tipus que sigui.\nAquests mètodes generals són:\n   Mètode Funcionalitat     boolean add(Object o) Afegir un element en la col·lecció   void clear() Elimina tots els elements de la col·lecció   boolean contains(Object o) Comprova si existeix l\u0026rsquo;element en la col·lecció   boolean isEmpty() Comprova si la col·lecció està buida   boolean remove(Object o) Elimina un element de la col·lecció   int size() Retorna la quantitat d\u0026rsquo;elements que té la col·lecció   Object[] toArray() Retorna els conjunt d\u0026rsquo;elements dins un array       Classe Elements repetits Elements ordenats Comentaris     ArrayList Sí, els permet Elements ordenats per ordre d\u0026rsquo;inserció És non-synchronized, si es vol synchronized: Vector   HashSet No, no els permet No existeix un ordre Internament utilitza una taula de hash per guardar els elements   HashMap Les claus són úniques, els valors poden estar duplicats No existeix un ordre Guarda valors basat en claus (diccionari)    Nota: Tot hi que HashMap no hereta de Collections (ho fa de Maps), el tractarem com un element més d\u0026rsquo;anàlisi ja que les seves propietats són molt idònies per determinats tipus de problema.\nQuan utilitzar aquestes estructures en Java?\n Si no voleu tenir valors duplicats a la base de dades, HashSet hauria de ser la vostra primera opció, ja que totes les seves classes no permeten duplicats. Si es necessiten operacions de cerca freqüents basades en els valors de l\u0026rsquo;índex, Llista (ArrayList) és una opció millor. Si cal mantenir l’ordre d’inserció, també la llista és la interfície de col·lecció preferida. Si el requisit és tenir les assignacions de claus i valors a la base de dades, llavors HashMap és la vostra millor aposta.  Collections i Maps són interfícies molt genèriques i analitzarem de forma pràctica les següents classes heredades d\u0026rsquo;aquestes amb exemples:\n ArrayList: Array dinàmic per guardar objectes i elements. HashSet: Conjunt d\u0026rsquo;elements únics i que no tenen un ordre establert. HashMap: Conjunt d\u0026rsquo;elements clau-valor (K-V).  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/",
	"title": "Dades Compostes",
	"tags": [],
	"description": "",
	"content": "Fins ara hem treballat amb estructures de dades simples. A mesura que tractem problemes més complexos es fa necessari agrupar i tractar les dades com un únic conjunt, això són el que s\u0026rsquo;anomenen els objectes, l\u0026rsquo;encapsulament de dades en una mateixa estructura. Així doncs en el següent capítol analitzarem:\n Arrays unidimensional: conjunt de dades del mateix tipus dins una dimensió. Arrays bidimensionals: conjunt de dades del mateix tipus dins de dues dimensions. (Taula) Cadena de caràcters: conjunt de caràcters que s\u0026rsquo;agrupen en una estructura que s\u0026rsquo;anomena String. Col·leccions: Estructures compostes amb les característiques que aporta les interfícies List, Set i Map.   "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/",
	"title": "Programació Modular",
	"tags": [],
	"description": "",
	"content": "Una vegada hem conegut els fonaments de la programació estructurada, hem observat que a mesura que el programa creix en complexitat es fa necessari escriure moltes línies de codi, reutilitzant, a vegades, moltes parts. Per tal d\u0026rsquo;ordenar aquest codi és necessari agrupar-lo en diferents blocs i reutilitzar quan sigui possible. Així doncs treballarem:\n Introducció Disseny Modular : aprendrem a organitzar els mòduls que generem en Java en diferents llibreries/paquets. Metodologia Top-Down : observarem com desenvolupar petits aplicatius partint de l\u0026rsquo;origen i arribant a les parts més específiques. Llibreries : entendrem l\u0026rsquo;organització dels paquets i llibreries en un projecte. Recursivitat : coneixerem i jugarem amb la crida a funcions de forma recursiva.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/",
	"title": "Programació Orientada a Objectes",
	"tags": [],
	"description": "",
	"content": "Fins el moment hem vist les avantatges d\u0026rsquo;usar la programació modular en els nostres projectes. Ara entrem a analitzar perquè Java se l\u0026rsquo;anomena un llenguatge orientat a objectes i quins beneficis ens dóna per les nostres aplicacions.\n Introducció paradigma POO : coneixem què és la Programació orientada a objectes (POO) i quines característiques principals té. Implementació bàsica de POO : coneixem i implementem en Java les parts bàsiques de les que es composa una classe i les provem. Desenvolupament de POO : aprendrem a combinar diferents classes que ens portin a la resolució de petits aplicatius. Programació Avançada de POO : aprendrem a usar característiques avançades sobre la programació orientada a objectes (polimorfisme, herència, classes abstractes, interfícies).  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/",
	"title": "M03 Programació DAM",
	"tags": [],
	"description": "",
	"content": "M03 Programació DAM En aquesta pàgina web trobareu els apunts del M03. Programació DAM. La web està realitzada utilitzant un Framework Web(Hugo), hostatjada a Github i es fa ús de Github Pages.\nTot seguit es mostra la calendarització i les hores de les UFs que s\u0026rsquo;imparteixen en aquest mòdul de 1r de DAM. Fixeu-vos que l\u0026rsquo;ordre de realització de les UFs és: UF1, UF2, UF4 i UF3. La UF4 segueix a la UF2, ja que pedagògicament té més sentit realitzar-la després d\u0026rsquo;aquesta UF.\n   UF dates hores     UF1: Programació estructurada 15/09/20 - 11/12/20 85h   UF2: Disseny modular 14/12/20 - 05/02/21 50h   UF4: Programació orientada a objectes (POO) 06/02/21 - 23/04/21 68h   UF3: Fonaments de fitxers 24/04/21 - 25/05/21 30h    L\u0026rsquo;índex de continguts que veurem és:\nUF1: Programació estructurada\n Estructura d\u0026rsquo;un programa  Introducció Metodologies de Software Tipus de Llenguatges   Tipus de dades Algorísmia Programació estructurada  Estructura sequencial Estructura condicional Estructura iterativa   Estructures compostes  Arrays Unidimensionals Arrays Bidimensionals Tractament cadena de caràcters    UF2: Disseny modular\n Programació Modular  Introducció al Disseny Modular Metodologia Top-Down Llibreries Recursivitat    UF4: Programació orientada a objectes (POO)\n  Programació Orientada a Objectes\n Introducció a la POO Implementació bàsica en POO Desenvolupament de POO Programació Avançada en POO  Herència Polimorfisme i Classes Abstractes Interfícies      Col·leccions\n ArrayList HashSet HashMap    UF3: Fonaments de fitxers\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]