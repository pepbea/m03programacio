[
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arrayunidimensional/",
	"title": "Arrays Unidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que permet agrupar dades del mateix tipus dins un mateix bloc.\n Exemple Per exemple podríem necessitar les edats d\u0026rsquo;una classe per efectuar-ne un tractament especial. Fins ara el que podíem fer és declarar tantes variables enteres com alumnes hi hagi per tal de guardar-ne l\u0026rsquo;edat:\nint edatAlumne1 = 29; int edatAlumne2 = 26; int edatAlumne3 = 18; ... int edatAlumne30 = 28;  Com podeu observar, si escaléssim el problema anterior i enlloc de 30 necessitéssim les edats dels 700 estudiants de l\u0026rsquo;institut, la declaració de variables seria una feina feixuga i amb un alt índex d\u0026rsquo;equivocar-nos, a més no permetria mantenir i modificar el programa de forma àgil. Per això hi ha les estructures de dades d\u0026rsquo;un mateix tipus. Una manera de guardar 700 edats dins una mateixa estructura seria aquesta:\n//Declarem una posició de memòria on comença un array int[] edatsAlumnes; //Aquest array és estàtic, per això abans d'usar-lo ens reservem en memòria el nombre d'enters que necessitem edatsAlumnes = new int[700]; //Omplim les edats dels alumnes for(int i = 0; i \u0026lt; edatsAlumnes.length; i++) edatsAlumnes[i] = sc.nextInt();  Declaració array En les línies anteriors hem observat que per crear un objecte array, és necessari fer servir la paraula reservada new, amb això el que fem és reservar en memòria l\u0026rsquo;espai necessari per allotjar la informació. En el següent exemple creem un array estàtic que l\u0026rsquo;anomeno arrayEstatic de 12 posicions.\nint[] arrayEstatic = new int[12]; //També es podria fer de la següent manera: int arrayEstatic[] = new int[12];  Fixeu-vos que en el primer exemple he fet la declaració i la reserva d\u0026rsquo;espais dels enters en instruccions separades, en canvi en aquest últim exemple ho he fet tot junt en una única línia.\nPer accedir a la posició enèssima de l\u0026rsquo;array ho puc fer de la següent manera arrayEstatic[n].\nEls Indexs d\u0026rsquo;un array comencen en la posició 0, no en la 1. L\u0026rsquo;últim element de l\u0026rsquo;array es troba a la posició llargària de l\u0026rsquo;array - 1. Així doncs en l\u0026rsquo;exemple anterior el primer enter de l\u0026rsquo;arrayEstatic es troba en la posició arrayEstatic[0] mentre que l\u0026rsquo;últim en la posició arrayEstatic[11]. Hem de tenir en compte que l'índex no pot ser un valor negatiu, i que per exemple podria ser un càlcul numèric o fent ús de variables arrayEstatic[i + 1]\n És important entendre que un cop declaro un arrayEstatic, es reserva en memòria espai per guardar el tipus de dades * Tamany de l'array. En l\u0026rsquo;exemple anterior es demana al programa que ens reservi espai per a 12 enters consecutius. Aquests enters no tenen un valor definit (al ser enters Java els hi posa un 0), per tant cal que els inicialitzem un valor per utilitzar-los.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/",
	"title": "Estructura d’un programa",
	"tags": [],
	"description": "",
	"content": "En aquest apartat realitzarem una introducció sobre què és un programa informàtic, quines metodologies de Software hi ha al mercat alhora de treballar i analitzarem diferents classificacions dels llenguatges de programació:\n Introducció Metodologies de Software Tipus de Llenguatges  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/1propositiblocs/",
	"title": "Introducció",
	"tags": [],
	"description": "",
	"content": "Breus definicions inicials Programació informàtica: És el procés d\u0026rsquo;escriure, provar, depurar/solucionar problemes, i mantenir el codi font de programes.\n Programa: Conjunt d\u0026rsquo;instruccions d’un llenguatge de programació, ordenades d\u0026rsquo;una manera determinada, que l’ordinador és capaç d’entendre i executar per resoldre un problema. L\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre unes normes sintàctiques i semàntiques que permeten realitzar multitud de funcions diferents.\n Instrucció: És una cadena de símbols d\u0026rsquo;un alfabet, formada d\u0026rsquo;acord amb certes regles sintàctiques que el processador (o el compilador) entén, i que finalment seran interpretades i executades pel processador.\n Llenguatge informàtic: Conjunt d\u0026rsquo;instruccions que ordenades d\u0026rsquo;una determinada manera generen un codi que l\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre per realitzar una determinada tasca.\n Dada: Unitat d\u0026rsquo;informació que utilitzen els programes informàtics per ser tractada (llegir, modificar, eliminar, crear, transformar\u0026hellip;).\n Codi font: Codi que els humans poden entendre i manipular per tal de crear i modificar els diferents programes informàtics. En Java els fitxers que contenen codi font són fitxers amb extensió .java\n Codi màquina: Una vegada el codi font és escrit pels humans es transforma en un altre fitxer (compilació) que genera un altre fitxer/codi que està a més baix nivell i que enten la màquina. En Java els fitxers convertits a codi màquina són els fitxers executables, són diferents per cada plataforma, per això diem que java és un llenguatge multiplataforma, perquè el mateix codi font el podem executar en plataformes diferents.\n Procés d\u0026rsquo;execució d\u0026rsquo;un programa Els programes informàtics donen solució a una determinada necessitat o problemàtica. A partir d\u0026rsquo;un problema determinat dissenyem un conjunt de passos determinats, ordenats i finits que ens aporta la solució (algorisme). La implementació d\u0026rsquo;aquests passos amb un llenguatge de programació genera un codi que dóna lloc al programa informàtic final.\nAixí doncs el programa té un iniciador, executa una sèrie d\u0026rsquo;instruccions que solucionen un problema determinat i existeix un punt de finalització quan es troba l\u0026rsquo;estat que soluciona el problema.\nEn aquest procés es possible que tinguem dades d\u0026rsquo;entrada (input: dades necessàries per executar un codi determinat), i també és possible que tinguem dades de sortida (output: dades que desitgem retornar o mostrar quan s\u0026rsquo;acaba l\u0026rsquo;execució del codi).\nTot el codi que hem escrit i que posem a executar l\u0026rsquo;anomenarem procés (codi en execució).\nCas particular de Java Tot seguit veiem què passa amb el programa HolaMon.java escrit en Java. És el primer programa que s\u0026rsquo;acostuma a mostrar de qualsevol llenguatge de programació. L\u0026rsquo;únic que fa aquest programa és escriure per pantalla \u0026ldquo;Hola Mundo\u0026rdquo;.\nSi us fixeu en la següent il·lustració es mostra tot el procés de compilació. Inicialment tenim el codi font del fitxer HolaMundo.java escrit pel programador. El següent pas és transformar aquest fitxer en un codi intermig que és el bytecode que permetrà ser transportat a qualsevol plataforma. Aquest codi intermig és un fitxer .class que ens assegura que el procés de compilació del fitxer .java s\u0026rsquo;ha executat correctament, en java s\u0026rsquo;utilitza la comanda javac per poder obtenir-lo. javac HolaMundo.java Amb aquesta instrucció \u0026ldquo;es compila\u0026rdquo; el programa i genera un HolaMundo.class.\nUn cop tenim el fitxer .class, executant la comanda java HolaMundo obtenim l\u0026rsquo;execucio del nostre programa sobre la plataforma on estiguem, per això en la imatge següent el codi màquina que s\u0026rsquo;executa amb Win32 serà diferent que el que interpreta MacOS ja que són SO\u0026rsquo;s diferents i obeeixen a instruccions diferents.\nEn el següent exemple es pot veure com seria un fitxer .java que es llegeix i s\u0026rsquo;enten amb llenguatge humà. A continuació, en el procés de compilació, es genera el fitxer .class, aquí ja els humans no entenem el contingut del fitxer ja que està en hexadecimal, i finalment quan executem el programa es genera un fitxer en codi màquina amb una tira de 0s i 1s que són les instruccions que necessita la CPU en cada plataforma per ser executat. Aquest últim fitxer serà diferent en cada plataforma d\u0026rsquo;execució (Linux, Windows, MacOS\u0026hellip;)\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arraybidimensional/",
	"title": "Arrays Bidimensionals",
	"tags": [],
	"description": "",
	"content": "Hugo-theme-learn has been built to be as configurable as possible by defining multiple partials\nIn themes/hugo-theme-learn/layouts/partials/, you will find all the partials defined for this theme. If you need to overwrite something, don\u0026rsquo;t change the code directly. Instead follow this page. You\u0026rsquo;d create a new partial in the layouts/partials folder of your local project. This partial will have the priority.\nThis theme defines the following partials :\n header: the header of the content page (contains the breadcrumbs). Not meant to be overwritten custom-header: custom headers in page. Meant to be overwritten when adding CSS imports. Don\u0026rsquo;t forget to include style HTML tag directive in your file footer: the footer of the content page (contains the arrows). Not meant to be overwritten custom-footer: custom footer in page. Meant to be overwritten when adding Javacript. Don\u0026rsquo;t forget to include javascript HTML tag directive in your file favicon: the favicon logo: the logo, on top left hand corner. meta: HTML meta tags, if you want to change default behavior menu: left menu. Not meant to be overwritten menu-footer: footer of the the left menu search: search box toc: table of contents  Change the logo Create a new file in layouts/partials/ named logo.html. Then write any HTML you want. You could use an img HTML tag and reference an image created under the static folder, or you could paste a SVG definition !\nThe size of the logo will adapt automatically\n Change the favicon If your favicon is a png, just drop off your image in your local static/images/ folder and name it favicon.png\nIf you need to change this default behavior, create a new file in layouts/partials/ named favicon.html. Then write something like this:\n\u0026lt;link rel=\u0026quot;shortcut icon\u0026quot; href=\u0026quot;/images/favicon.png\u0026quot; type=\u0026quot;image/x-icon\u0026quot; /\u0026gt;  Change default colors Hugo Learn theme let you choose between 3 native color scheme variants, but feel free to add one yourself ! Default color scheme is based on Grav Learn Theme.\nRed variant [params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;red\u0026quot;  Blue variant [params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;blue\u0026quot;  Green variant [params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;green\u0026quot;  \u0026lsquo;Yours‘ variant First, create a new CSS file in your local static/css folder prefixed by theme (e.g. with mine theme static/css/theme-mine.css). Copy the following content and modify colors in CSS variables.\n:root{ --MAIN-TEXT-color:#323232; /* Color of text by default */ --MAIN-TITLES-TEXT-color: #5e5e5e; /* Color of titles h2-h3-h4-h5 */ --MAIN-LINK-color:#1C90F3; /* Color of links */ --MAIN-LINK-HOVER-color:#167ad0; /* Color of hovered links */ --MAIN-ANCHOR-color: #1C90F3; /* color of anchors on titles */ --MENU-HEADER-BG-color:#1C90F3; /* Background color of menu header */ --MENU-HEADER-BORDER-color:#33a1ff; /*Color of menu header border */ --MENU-SEARCH-BG-color:#167ad0; /* Search field background color (by default borders + icons) */ --MENU-SEARCH-BOX-color: #33a1ff; /* Override search field border color */ --MENU-SEARCH-BOX-ICONS-color: #a1d2fd; /* Override search field icons color */ --MENU-SECTIONS-ACTIVE-BG-color:#20272b; /* Background color of the active section and its childs */ --MENU-SECTIONS-BG-color:#252c31; /* Background color of other sections */ --MENU-SECTIONS-LINK-color: #ccc; /* Color of links in menu */ --MENU-SECTIONS-LINK-HOVER-color: #e6e6e6; /* Color of links in menu, when hovered */ --MENU-SECTION-ACTIVE-CATEGORY-color: #777; /* Color of active category text */ --MENU-SECTION-ACTIVE-CATEGORY-BG-color: #fff; /* Color of background for the active category (only) */ --MENU-VISITED-color: #33a1ff; /* Color of 'page visited' icons in menu */ --MENU-SECTION-HR-color: #20272b; /* Color of \u0026lt;hr\u0026gt; separator in menu */ } body { color: var(--MAIN-TEXT-color) !important; } textarea:focus, input[type=\u0026quot;email\u0026quot;]:focus, input[type=\u0026quot;number\u0026quot;]:focus, input[type=\u0026quot;password\u0026quot;]:focus, input[type=\u0026quot;search\u0026quot;]:focus, input[type=\u0026quot;tel\u0026quot;]:focus, input[type=\u0026quot;text\u0026quot;]:focus, input[type=\u0026quot;url\u0026quot;]:focus, input[type=\u0026quot;color\u0026quot;]:focus, input[type=\u0026quot;date\u0026quot;]:focus, input[type=\u0026quot;datetime\u0026quot;]:focus, input[type=\u0026quot;datetime-local\u0026quot;]:focus, input[type=\u0026quot;month\u0026quot;]:focus, input[type=\u0026quot;time\u0026quot;]:focus, input[type=\u0026quot;week\u0026quot;]:focus, select[multiple=multiple]:focus { border-color: none; box-shadow: none; } h2, h3, h4, h5 { color: var(--MAIN-TITLES-TEXT-color) !important; } a { color: var(--MAIN-LINK-color); } .anchor { color: var(--MAIN-ANCHOR-color); } a:hover { color: var(--MAIN-LINK-HOVER-color); } #sidebar ul li.visited \u0026gt; a .read-icon { color: var(--MENU-VISITED-color); } #body a.highlight:after { display: block; content: \u0026quot;\u0026quot;; height: 1px; width: 0%; -webkit-transition: width 0.5s ease; -moz-transition: width 0.5s ease; -ms-transition: width 0.5s ease; transition: width 0.5s ease; background-color: var(--MAIN-LINK-HOVER-color); } #sidebar { background-color: var(--MENU-SECTIONS-BG-color); } #sidebar #header-wrapper { background: var(--MENU-HEADER-BG-color); color: var(--MENU-SEARCH-BOX-color); border-color: var(--MENU-HEADER-BORDER-color); } #sidebar .searchbox { border-color: var(--MENU-SEARCH-BOX-color); background: var(--MENU-SEARCH-BG-color); } #sidebar ul.topics \u0026gt; li.parent, #sidebar ul.topics \u0026gt; li.active { background: var(--MENU-SECTIONS-ACTIVE-BG-color); } #sidebar .searchbox * { color: var(--MENU-SEARCH-BOX-ICONS-color); } #sidebar a { color: var(--MENU-SECTIONS-LINK-color); } #sidebar a:hover { color: var(--MENU-SECTIONS-LINK-HOVER-color); } #sidebar ul li.active \u0026gt; a { background: var(--MENU-SECTION-ACTIVE-CATEGORY-BG-color); color: var(--MENU-SECTION-ACTIVE-CATEGORY-color) !important; } #sidebar hr { border-color: var(--MENU-SECTION-HR-color); }  Then, set the themeVariant value with the name of your custom theme file. That\u0026rsquo;s it !\n[params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;mine\u0026quot;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/sequencial/",
	"title": "Estructura seqüencial",
	"tags": [],
	"description": "",
	"content": "Estructura seqüencial En l\u0026rsquo;estructura seqüencial permet descomposar un problema en instruccions que s\u0026rsquo;executaran de la primera a la última seguint un ordre de forma incondicional.\n L' assignació consisteix en donar un valor a una variable. \u0026ldquo;Guardar\u0026rdquo; una informació en una variable, que segurament serà tractada i/o consultada més endavant.\n    Codi Diagrama de flux     Acció1;\nAcció2;\nAcció3;\nAcció4;     Estructura bàsica L\u0026rsquo;estructura bàsica de qualsevol programa en Java anirà dins una \u0026ldquo;classe\u0026rdquo; amb un fitxer .java, amb la següent plantilla:\npublic class Main { public static void main(String[] args) { } }  Java executarà tot el que trobi dins les claus del main anterior.\nComentaris Tot el que es posa entre comentaris serveix per documentar el codi en cas que sigui necessari i Java ho interpreta com a comentaris i no ho executa com si fossin instruccions. Existeixen comentaris per:\n Una fila. En aquest cas utilitzarem \u0026ldquo;// Comentari\u0026rdquo; Més d\u0026rsquo;una fila, el comentari anirà entre \u0026ldquo;/* Comentari vàries línies */\u0026rdquo;  public class Main { public static void main(String[] args) { //Comentari d'una sola línia /* Comentari de més d'una línia */ } }  Inputs Per tal d\u0026rsquo;introduir valors al nostre programa (inputs), inicialment, farem servir la classe Scanner, cal declarar-la a dalt del programa i crear un objecte Scanner, per exemple li direm sc. Aquest objecte ens permetrà introduir informació pel teclat.\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enter32bits = sc.nextInt(); long enter64bits = sc.nextLong(); float decimal = sc.nextFloat(); double decimalGran = sc.nextDouble(); boolean boolea = sc.nextBoolean(); String cadenaCaracters = sc.next(); String cadenaCaractersFinalLinia = sc.nextLine(); } }  Outputs Per tal de treure valors per la línia de comandes (outputs) el que farem serà usar System.out.print i si volem un salt de línia System.out.println\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Pots escriure el teu nom per línia de comandes?\u0026quot;); String nom = sc.nextLine(); System.out.print(\u0026quot;Hola! \u0026quot;); System.out.print(\u0026quot;El meu nom és \u0026quot; + nom); } }  Exemples  Llegeix dos nombres reals i escriu la seva suma, resta, producte i quocient.  float operand1 = sc.nextFloat(); float operand2 = sc.nextFloat(); float suma = operand1 + operand2; float resta = operand1 - operand2; float multiplicacio = operand1 * operand2; float divisio = operand1 / operand2; float modul = operand1 % operand2;  Llegeix el preu d\u0026rsquo;un producte, l\u0026rsquo;IVA (en %) i el descompte (en %) a aplicar. Escriu el preu final del producte.  float preu = sc.nextFloat(); int iva = sc.nextInt(); int descompte = sc.nextInt(); float preuAmbIva = preu + preu * iva / 100; float preuAmbIvaIDescompte = preuAmbIva - preuAmbIva * descompte / 100; System.out.println(\u0026quot;Preu final:\u0026quot; + preuAmbIvaIDescompte);  Calcula l\u0026rsquo;àrea lateral i el volum d\u0026rsquo;un cilindre recte, introduint per teclat els valors del radi i l\u0026rsquo;altura. V =pi⋅r2⋅h AL=2⋅pi⋅r⋅h  float radi = sc.nextFloat(); float altura = sc.nextFloat(); double areaLateral = 2 * Math.PI * radi * altura; double volum = Math.PI * Math.pow(radi,2) * altura; System.out.println(\u0026quot;Area lateral:\u0026quot; + areaLateral + \u0026quot; Volum:\u0026quot; + volum);  Llegeix un nombre enter no negatiu i un altre nombre enter no negatiu que indica la posició de les seves xifres i escriu la xifra que ocupa aquesta posició. Les unitats estan a la posició 1, les desenes a la posició 2, etc.  int nombre = sc.nextInt(); int posicio = sc.nextInt(); double potencia = Math.pow(10,posicio-1); double nombreRetallat = nombre / potencia; int nombreBuscat = (int)nombreRetallat % 10; System.out.println(\u0026quot;el dígit \u0026quot; +posicio+ \u0026quot; del nombre \u0026quot; + nombre + \u0026quot; és: \u0026quot;+ nombreBuscat);  Llegeix un nombre enter de segons i escriu el nombre d’hores, minuts i segons equivalents en format h:m:s.  int segonsTotals = sc.nextInt(); int hores = segonsTotals / 3600; int segonsRestants = segonsTotals % 3600; int minuts = segonsRestants / 60; int segons = segonsRestants % 60; System.out.println(hores + \u0026quot;:\u0026quot; + minuts + \u0026quot;:\u0026quot; + segons);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/2metodologiessoftware/",
	"title": "Metodologies de Software",
	"tags": [],
	"description": "",
	"content": "El programari no es fabrica com qualsevol altre producte clàssic, sinó que es desenvolupa seguint una sèrie d\u0026rsquo;etapes. D\u0026rsquo;aquí sorgeix el concepte d\u0026rsquo;enginyeria de programari, que consisteix en l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria per obtenir desenvolupaments que optimitzin l\u0026rsquo;efectivitat i els costos.\nEls processos d\u0026rsquo;enginyeria de programari comprenen per tant, diverses etapes, que constitueixen el que s\u0026rsquo;anomena el cicle de vida del programari. Per dur a terme aquestes fases és necessari partir d\u0026rsquo;un enfocament amb el qual iniciar el procés de enginyeria. Un cop iniciat, s\u0026rsquo;ha d\u0026rsquo;utilitzar una metodologia amb unes eines que permetin completar les diferents etapes de l\u0026rsquo;cicle.\nEn l\u0026rsquo;actualitat, l\u0026rsquo;enfocament més estandaritzat és l\u0026rsquo;orientació a objectes. la creació el 1998 de l\u0026rsquo;estàndard UML (Unified Modeling Language) per a la definició de problemes i el desenvolupament de llenguatges de programació com Java o C ++ pel desenvolupament i integració de solucions, són els principals causants que aquest enfocament s\u0026rsquo;estigui consolidant.\nQuè és l\u0026rsquo;enginyeria del software? De l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria a l\u0026rsquo;programari sorgeixen els processos de desenvolupament de programari. Aquest procés es defineix com \u0026ldquo;aquell en què les necessitats de l\u0026rsquo;usuari són traduïdes en requisits de programari, aquests requisits transformats en disseny, i el disseny implementat en codi, que és provat, documentat i certificat pel seu ús operatiu\u0026rdquo; [Jacobson, 1998].\n Característiques del software  S\u0026rsquo;ha invertit la demanda i el preu respecte al HW. El Software es un producte lògic que es desenvolupa, no es construeix com la resta de productes. La gestió de costos es centra en l\u0026rsquo;enginyeria, amb la qual difereix d\u0026rsquo;altres projectes d\u0026rsquo;enginyeria. El Software no es deteriora amb el temps, però sí és necessari un manteniment. La reutilització de productes software creixent. Existeixen restriccions de recursos en el desenvolupament de software, de forma que és necessari assegurar-ne la qualitat per obtenir un software: documentat, fiable, eficient i amb una bona interfície gràfica.  Cicles de desenvolupament del software. Tipus de cicles Anomenem cicle de vida del software al temps necessari per la producció d\u0026rsquo;un projecte software desde la recopilació de requisits fins a l\u0026rsquo;entrega final del producte. El cicle de vida inclou una sèrie d\u0026rsquo;etapes que pot canviar en funció del model, la metodologia i l\u0026rsquo;autor. Existeixen varis tipus de cicles de vida que passem a comentar.\nModel en cascada o lineal Es tracta d\u0026rsquo;un model molt genèric i que estableix una sèrie de fases o etapes, que han de ser seguides en un ordre seqüencial, ja que cada fase genera entrades i documentació per a la següent fase. Les fases d\u0026rsquo;un cicle de vida en cascada segueixen el següent esquema:\nLes característiques del model són:\n Cada etapa s\u0026rsquo;inicia un cop acabada l\u0026rsquo;anterior. Ajuda a la planificació temporal i el càlcul de costos, a causa de la seqüencialitat i estructura lògica de les etapes. Hi ha una realimentació en el manteniment.  Quant als inconvenients que s\u0026rsquo;han detectat, aquests són:\n Es tracta d\u0026rsquo;un model rígid, sense robustesa ni adaptabilitat als problemes a resoldre. Hi ha dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials, ja que aquests solen venir donats per persones alienes al coneixement del cicle de desenvolupament de programari. Els errors solen detectar-se molt tard, el que implica que el cost per solucionar l\u0026rsquo;error sigui molt més gran. El manteniment es realitza mitjançant petites actualitzacions o \u0026ldquo;pegats\u0026rdquo;. Torna a aplicar cadascuna de les fases del cicle al programari ja existent, sense crear un de nou.  Fases:\n Anàlisi de sistema: el sistema de programari forma part sobre un sistema major amb el qual es relaciona. S\u0026rsquo;analitza el sistema en el seu conjunt per treure objectius que han de ser abordables pel programari. Anàlisi de requisits: definint funcions a realitzar, dades, comportament, i interacció entre elements funcionals. Disseny: a partir de requisits dissenyem els components de programari, estructures de dades, mòduls, procediments, algoritmes i interfícies\u0026hellip; Codificació: a partir d\u0026rsquo;informació generada implementem sistema, codifiquem procediments en un llenguatge de programació. Prova: validem i verifiquem que els requisits establerts pel client es realitzen correctament. Manteniment: la producció de programari no finalitza amb el lliurament, ha de ser revisat i reajustat quan això sigui necessari.  Cicle de vida prototipat Aquest model tracta de solucionar problemes del model en cascada, en concret les dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials. El client sol definir els objectius generals del programari, però no acostuma a tenir en compte tots els requisits reals que ha de tenir una aplicació. Al mateix temps, el desenvolupador pot no arribar a entendre què vol el client. Per tal de solucionar això, un cicle basat en prototips pot ser un millor enfocament.\nLes característiques d\u0026rsquo;aquest model són:\n Client i desenvolupador defineixen una sèrie d\u0026rsquo;objectius globals, dels quals s\u0026rsquo;identifiquen els requisits, amb els quals es realitza un disseny ràpid, i amb aquest, la creació d\u0026rsquo;un prototip. El prototip és avaluat per l\u0026rsquo;usuari, qui pot veure les deficiències del prototip, a partir de les quals es redefineixen els requisits. Es van construint nous prototips, amb els quals el client pot anar polint els requisits de programari, al mateix temps que el desenvolupador pot comprendre millor el que ha de fer. Aquestes interaccions finalitzen quan el prototip satisfà les necessitats del client.  Inconvenients d\u0026rsquo;aquest tipus de cicle de vida:\n És un procés molt lent. Si es desitja generar un programari de qualitat no n\u0026rsquo;hi ha prou que un prototip sigui com l\u0026rsquo;anterior amb uns petits ajustos, sinó que es requereix crear el producte de nou. això succeeix fonamentalment amb els primers prototips de cada desenvolupament. El client veu cada prototip com una versió de programari final, sense prendre consciència que cada prototip únicament ajuda a aclarir els requisits, i per tant, és generat des del principi, per aconseguir una robustesa en el desenvolupament. Els primers prototips que es rebutgen suposen un cost addicional, ja que amb prou feines poden emprar-se per al mateix desenvolupament ni poden ser reutilitzats per a altres.  Cicles de vida evolutius El programari és un producte que va evolucionant per això els desenvolupadors necessiten un nou model de cicle de vida, que permeti que les funcionalitats del programari puguin anar canviant amb el temps. El model en cascada assumeix que es lliura un producte una vegada acabades totes les fases del procés, sense considerar possibles evolucions. Tampoc es té en compte l\u0026rsquo;evolució en el model de prototips, en que aquests es dissenyen per ajudar al client a comprendre els requisits, però no per disposar de versions a millorar.\nLa solució la presenten els cicles de vida evolutius, que amb una estructura iterativa, permeten als enginyers desenvolupar versions cada vegada més completes del programari.\nCicle de vida incremental Aquest model combina el model lineal seqüencial amb la filosofia de creació de prototips. Per a això, va generant seqüències lineals de desenvolupament al mateix temps que cada seqüència lineal produeix un \u0026ldquo;increment\u0026rdquo; en el programari, el qual va progressant.\nEl primer increment sol ser un desenvolupament que tan sols incorpora els requisits i funcionalitats més bàsiques. Les versions successives consisteixen en modificacions de cada versió anterior, a la qual s\u0026rsquo;afegeixen noves funcionalitats i modificacions, es van lliurant les diferents versions o increments d\u0026rsquo;acord es van acabant. A diferència del prototipat, cada increment aprofita la versió anterior, i és una versió del producte final a falta d\u0026rsquo;algunes funcionalitats. L\u0026rsquo;esquema que segueix aquest tipus de cicle de vida és el següent:\nAquest tipus de cicle de vida és molt avantatjós des del punt de vista de costos temporals i flexibilitat en la planificació del projecte. Els primers increments no requereixen molt personal, mentre que per als següents es poden anar afegint més o menys funcionalitats segons la quantitat de personal de què es disposi o bé segons que es disposi o no de determinats recursos.\nCicle de vida en espiral És un procés evolutiu que combina la interactivitat del prototipat amb els aspectes sistemàtics del model en cascada. Cada volta de l\u0026rsquo;espiral consta de les mateixes fases que el cicle en cascada:\n Planificació: determina objectius, requisits i restriccions de el projecte. Anàlisi de risc: analitza alternatives, identifica i resol riscos Enginyeria: desenvolupament del producte. Avaluació de client: es valoren els resultats obtinguts.  Segueix les directrius del model PDCA (Plan Develop Check Act) de Demming, i segueix la filosofia del moviment Agile resumit en el Manifiesto Agile, una de les seves implementacions més conegudes és SCRUM.\nEl principal avantatge del model en espiral és que és el més adequat per projectes amb riscs. Com el programari va evolucionant, el desenvolupador i client poden anar comprenent cada vegada millor els riscos conforme es va passant per diferents nivells d\u0026rsquo;evolució. El mecanisme utilitzat per minimitzar riscos es basa en poder incorporar el prototipat en qualsevol etapa d\u0026rsquo;evolució del producte.\nDavant d\u0026rsquo;aquest avantatge, es troba l\u0026rsquo;inconvenient de requerir una alta habilitat en els enginyers per avaluar riscos. L\u0026rsquo;èxit depèn molt d\u0026rsquo;ella, ja que un risc no descobert pot donar lloc a problemes.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2tipusdades/",
	"title": "Tipus de dades i operadors",
	"tags": [],
	"description": "",
	"content": "Tipus de dades En el llenguatge Java incorpora tipus de dades diferents d\u0026rsquo;acord amb la seva naturalesa: no és el mateix un nombre, que un text o un valor verdader/fals per exemple. Aquests tipus de dades els classifiquem en tipus de dades primitius i tipus de dades de classe:\n Primitius: són les dades simples que coneixem com a nombres, text, etc. i que ens defineix de forma primitiva el llenguatge. Classe: són tipus de dades més complexos que es creen a partir dels mateixos tipus de classe o de tipus primitius.  Tipus Primitius En Java podem diferenciar els següents tipus de dades primitius:\n Numèrics:  Enters: byte, short, int i long Reals: float, double   Textuals:  chars   Lògics:  boolean    La diferència entre els nombres enters i reals és que els nombres enters no contenen decimals (ex: 2 | 3 | 25) i els nombres reals reserven espai pels decimals (ex: 4,45 | 6,82 | 3,141592). Tot seguit us mostro una taula de rangs:\n   Nom Longitud Rangs de valors     byte 8 bits De -27 a 27 -1   short 16 bits De -215 a 215 -1   int 32 bits De -231 a 231 -1   long 64 bits De -263 a 263 -1   float 32 bits    double 64 bits    char 16 bits     Els valors que admet una variable de tipus booleà és: true o false. Un valor booleà és molt comú en el camp informàtic on moltes vegades cal prendre una decisió que es pot avaluar en \u0026ldquo;veritat\u0026rdquo; o \u0026ldquo;fals\u0026rdquo;.\nExemple d\u0026rsquo;assignació de valors Declarem i assignem un valor a les variables:\nboolean valorBoolea = true; int valorEnter = 50; float valorDecimal = 50.3; char lletra =’v’;  En aquest cas primer declarem les variables i després li assignem un valor:\nboolean valorBoolea; valorBoolea = true; int valorEnter; valorEnter = 50; float valorDecimal; valorDecimal = 50.3; char lletra; lletra =’v’;  Operadors Operadors aritmètics Són les operacions que avaluen una operació i retornen un resultat numèric.\n   Operació Operador     Suma +   Resta -   Multiplicació *   Divisió /   Mòdul %    Altres operadors\nExisteixen altres formes que simplifiquen l\u0026rsquo;escriptura alhora de fer operacions senzilles. Seria el cas dels comptadors. D\u0026rsquo;aquesta manera existeixen expressions com:\nint comptador = 0; comptador = comptador + 1; //es pot fer de forma més simple int comptador = 0; comtpador++; //Les dues expressions següents també són equivalents i s'aplica a tots els operadors aritmètics: int comptador = 0; comptador = comptador + 10; comptador =+ 10; comptador = comptador - 10; comptador =- 10; comptador = comptador * 10; comptador =* 10; comptador = comptador / 10; comptador =/ 10;  Recordem l\u0026rsquo;ordre de prioritat en les operacions aritmètiques:\n 1r Parèntesi () 2n Multiplicacions, divisioons i mòdul * / % 3r Sumes i restes + -  Operadors lògics i relacionals Són les operacions que avaluen una expressió i retornen un resultat booleà (true o false).\nOperadors lògics\n   A B !A A \u0026amp;\u0026amp; B A || B     true true false true true   true false false false true   false true true false true   false false true false false    Operadors relacionals\nAquests operadors els podem aplicar a diferents tipus de dades i s\u0026rsquo;avalua l\u0026rsquo;expressió a un booleà (true o false).\n   Operació Signe Exemple1 Resultat1 Exemple2 Resultat2     Major \u0026gt; 5 \u0026gt; 3 true 3 \u0026gt; 5 false   Major o igual \u0026gt;= 5 \u0026gt;= 5 true 5 \u0026gt;= 3 true   Menor \u0026lt; 5 \u0026lt; 5 false 3 \u0026lt; 2 false   Menor o igual \u0026lt;= 6 \u0026lt;= 5 false 4 \u0026lt;= 5 true   Igual == \u0026lsquo;c\u0026rsquo; == \u0026rsquo;d' false 5 == 3 false   No igual != \u0026lsquo;c\u0026rsquo; != \u0026rsquo;d' true 5 != 5 false    Prioritat\nLa prioritat alhora d\u0026rsquo;avaluar expressions que contenen operadors aritmètics, relacionals i lògics és:\n 1r. Es realitzen els càlculs aritmètics. 2n. S\u0026rsquo;avaluen les operacions relacionals de \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 3r. S\u0026rsquo;avaluen les operacions relacionals de == != 4rt. S\u0026rsquo;avaluen les negacions lògiques ! 5è. S\u0026rsquo;avaluen les operacions de conjunció \u0026amp;\u0026amp; 6è. S\u0026rsquo;avaluen les operacions de disjunció ||  Les operacions anteriors s\u0026rsquo;avaluen sempre d\u0026rsquo;esquerra a dreta.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/3tipusllenguatges/",
	"title": "Tipus de Llenguatges",
	"tags": [],
	"description": "",
	"content": "Els llenguatges de programació es poden classificar a partir de diferents criteris\n Segons la proximitat al nucli. Segons el paradigma de programació. Segons la traducció a codi màquina. Segons la generació.  1. Segons la proximitat al nucli La proximitat al nucli queda determinat per saber en quin moment s\u0026rsquo;executa aquest llenguatge. Poden ser llenguatges d\u0026rsquo;alt nivell, dins el sistema de capes, molt allunyat del nucli, o llenguatges de baix nivell propers al nucli.\n Els llenguatges de programació es poden classificar segons la seva proximitat al llenguatge màquina:\n   Llenguatges de baix nivell     Llenguatge de programació pròxim al nucli de la màquina i que només entén la màquina.   Es composa per codi binari (símbols 0 i 1).   És el llenguatge més bàsic i també més difícil d\u0026rsquo;entendre pels humans ja que totes les instruccions són tires de 0s i 1s.   És un llenguatge molt lligat a l\u0026rsquo;arquitectura de la màquina.   S\u0026rsquo;utilitzen adreces de memòria per fer referència a les dades.   Les instruccions tenen un format rígid.       Llenguatges ensambladors     Separen les característiques del maquinari de la tasca de programació.   Es substitueixen els codis numèrics per representacions textuals equivalents a les instruccions màquina que representen.   Segueixen tenint una forta relació amb els llenguatges màquina però permeten utilitzar adreces simbòliques i incloure línies de comentaris.       Llenguatges d\u0026rsquo;alt nivell     Alliberen el programador de tasques tedioses i complexes que frenen la productivitat i l\u0026rsquo;eficiència.   Tenen un gran nivell d\u0026rsquo;abstracció que fa innecessari el coneixement de l\u0026rsquo;arquitectura de la màquina.   Les instruccions s\u0026rsquo;expressen per caràcters alfanumèrics; permeten definir variables; disposen d\u0026rsquo;instruccions molt ponents de tipus aritmètic, lògiques, tractament de caràcters, etc .; són fàcils de corregir i actualitzar i fàcils d\u0026rsquo;aprendre.   Per contra, no són tant conscients en quant a consum de recursos.    2. Segons el paradigma de programació Un paradigma de programació és un enfoc particular/filosofia pel disseny i construcció de codi. Depenent de cada context resulta més idoni utilitzar-ne un o altre\n A grans trets diferenciarem entre\n  Llenguatges imperatius: - Descriu la programació com una seqüència instruccions o ordres que canvien l\u0026rsquo;estat d\u0026rsquo;un programa. - Formen part d\u0026rsquo;aquest tipus molts llenguatges d\u0026rsquo;alt nivell i d\u0026rsquo;ús general: python, c, java, c++ etc. - Es fixen en el COM es desenvolupa el codi (com s\u0026rsquo;aconsegueix un objectiu pas a pas). - En aquest paradigma s\u0026rsquo;inclouen altres paradigmes com el modular, orientació a objectes, concurrent, etc.\n  Llenguatges declaratius: - Es fixen en QUÈ descriu (declara la solució), es basa en les propietats de la solució buscada. - No es coneix l\u0026rsquo;algorisme usat per trobar aquesta solució. - No es coneix el rendiment i/o eficiència del codi a priori - Molt útil en la resolució de problemes i situacions determinades. - En aquest paradigma s\u0026rsquo;inclouen els paradigmes funcional, lògic i no procedimental.\n  Com a subtipus dels anteriors destaquem:\n   Programació estructurada   Utilitza únicament seqüències, instruccions condicionals i instruccions repetitives. Es tracta en la UF1 de M03 Programació.\n    Programació modular   El programa es dissenya per parts(mòduls). Es tracta en la UF2 de M03 Programació.\n    Programació orientada a objectes   Programació basada en la comunicació i el pas de missatges entre objectes (estructures amb atributs i mètodes). Es tracta en la UF4 de M03 Programació.\n    Programació concurrent   Útil quan hem de realitzar diverses accions a la vegada i utilitzant recursos compartits. Es tracta en M09 Programació de serveis.\n    Programació funcional   Tot el codi es basa en funcions, des de l\u0026rsquo;expressió mínima a qualsevol estructura complexa. Exemple d\u0026rsquo;aquest paradigma és el llenguatge Lisp o Haskel.\n    Programació lògica   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog.\n \n3. Segons la traducció a codi màquina Els llenguatges de programació poden tenir diferents tractaments fins a ser executats, així diferenciem els llenguatges interpretats, compilats i els híbrids.\n Desde que un programa és escrit i és executat per la màquina hi ha un seguit de passos que cal tenir presents:\n Anàlisi (lèxic, sintàtic i semàntic) Traducció(generació i optimització de codi)  Depenent de com es realitza aquesta traducció tenim llenguatges compilats i interpretats:\n   Llenguatges compilats     Una vegada el codi és analitzat es genera el codi objecte d\u0026rsquo;acord amb les característiques del compilador del llenguatge. Depenent del tipus de compilador l\u0026rsquo;objecte pot ser directament executable o necessita altres passos previs com l\u0026rsquo;acoblament, l\u0026rsquo;enllaçat i la càrrega (Com per exemple el llenguatge C).   Per tal de flexibilitzar el codi, els compiladors treballen amb biblioteques de mòduls objecte. Per incloure-les en el codi màquina final s\u0026rsquo;ha d\u0026rsquo;usar un enllaçador que retorna un únic programa executable.   Els programes objecte s\u0026rsquo;executen molt més ràpidament que els interpretats ja que estan optimitzats per uns determinats recursos HW, però no permet transportar codi objecte entre diferents plataformes d\u0026rsquo;execució.   Exemples de llenguatges els traductors són compiladors són FORTRAN, COBOL, C, PASCAL, ADA \u0026hellip;       Llenguatges interpretats     En aquest cas es duu a la vegada el procés de traducció i el d\u0026rsquo;execució. La seva forma de treball és anar analitzant instruccions de codi del programa font, generant el codi màquina corresponent i executant.   Són més lents que els compilats, per contra, són fàcilment transportables entre diferents màquines, ja que és el propi programa font el que es mou.   Exemples de llenguatge interpretat són PROLOG, i SQL, Javascript, Python, etc.       Llenguatges híbrids     Aprofiten el millor d\u0026rsquo;ambdós mons com Java o Visual Studio .NET. Són capaços de compilar el codi a un llenguatge intermedi denominat bytecode en JAVA i MSI en .NET, que després són interpretats per una màquina virtual (MVJ o .NET Framework), així aconsegueixen una substancial millora en el rendiment i mantenen la característica de transportabilitat entre diferents plataformes    4. Segons la generació Depenent de quan es va crear el llenguatge s\u0026rsquo;emmarca en unes necessitats i usos concrets que han donat lloc a generacions. Són seqüencials en el temps.\n    Primera generació   Són els que corresponen als llenguatges ja vistos de baix nivell o llenguatges màquina.\n    Segona generació   Són aquells que pertanyen als llenguatges assembladors.\n    Tercera generació   A la tercera generació pertanyen aquells llenguatges estructurats que seguien un ordre alhora d\u0026rsquo;executar les instruccions. Llenguatges com C, pascal, cobol, etc.\n    Quarta generació   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog. Els llenguatges de quarta generació, són els més propers a la sintaxi de la llengua humana, i s\u0026rsquo;acostumen a utilitzar en les creacions de bases de dades o com a llenguatges de programació dels llenguatges o sistemes d\u0026rsquo;autor. Són llenguages no procedimentals com SQL que permeten definir quins seran els resultats finals sense necessitat de preocupar-se per saber com fer-ho.\n    Cinquena generació   Amb la incorporació i expansió dels llenguatges orientats a objectes i amb la generalització de l\u0026rsquo;ús de les GUI, és possible abarca problemes de major abstracció. Alguns exemples són Java, C++, etc. S\u0026rsquo;ha generalitzat tant els IDEs de desenvolupament com els CLIs per cada servei/llenguatge.\n \n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3algor%C3%ADsmia/",
	"title": "Algorísmia",
	"tags": [],
	"description": "",
	"content": "Què és un algorisme? Un algorisme és un mètode per resoldre un PROBLEMA, són un conjunt d\u0026rsquo;operacions finites i ordenades que s\u0026rsquo;han de seguir per a la resolució d\u0026rsquo;un problema.\n Característiques dels algorismes\nLes característiques bàsiques d\u0026rsquo;un algorisme són:\n Ordenat. Cada instrucció té una posició dins el conjunt. Precís. Cada instrucció és unívoca i obeeix a un objectiu. Definit. Si es segueix un algorisme dues vegades, s\u0026rsquo;ha d\u0026rsquo;obtenir el mateix resultat cada vegada. Finit. L\u0026rsquo;algorisme ha d\u0026rsquo;acabar en algun moment, per tant, tindrà un nombre finit de passos. Un bon disseny algorítmic contindrà tres parts: Entrada (Input), Procés (Tractament de la informació) i Sortida (Output).  Pseudocodi El pseudocodi és un llenguatge informal d’alt nivell que usa les convencions i l’estructura d’un llenguatge de programació, però que està orientat a ser entès pels humans.\n Diagrama de flux Un diagrama de flux de control consisteix en una subdivisió de passes seqüencials, d’acord amb les sentències i estructures de control d’un programa, que mostra els diferents camins que pot seguir un programa a l’hora d’executar les seves instruccions. Cada passa s’associa a una figura geomètrica específica.\n Complexitat ciclomàtica La Complexitat ciclomàtica (en anglès, Cyclomatic Complexity) és una mètrica de programari en enginyeria de programari que proporciona una mesura quantitativa de la complexitat lògica d\u0026rsquo;un programa. Consisteix en comptar el nombre de camins necessaris per tal d\u0026rsquo;anar de la primera a la última instrucció passant per tots els camins possibles i cobrint tots els casos.\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/condicional/",
	"title": "Estructura condicional",
	"tags": [],
	"description": "",
	"content": "Estructura condicional L\u0026rsquo;estructura de control condicional o alternativa permet prendre una decisió en un moment determinat sobre quines instruccions s\u0026rsquo;han d\u0026rsquo;executar. Donada una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet decidir entre un o varis camins d\u0026rsquo;execució.\n Existeixen diferents tipus d\u0026rsquo;estructura condicional.\n Estructura simple (if) Estructura composta (if/else) Estructura encadenada (if/else if/else) Sentència switch (switch) Combinació d\u0026rsquo;estructures  1. Estructura simple (if) Aquesta és la forma bàsica. Consisteix en una estructura en la qual si l' avaluació lògica és certa s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions, en cas contrari s\u0026rsquo;ometen aquestes instruccions. Consideracions:\n L\u0026rsquo;expressió lògica ha d\u0026rsquo;anar precedida de la paraula if i entre parèntesi (). Les instruccions que s\u0026rsquo;han d\u0026rsquo;executar es situen a continuació dins de les claus {}. Només s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions contingut entre {} quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a cert.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n}\nAcció3;     2. Estructura composta (if/else) La diferència respecte el cas anterior és que ara quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals també s\u0026rsquo;executarà un bloc d\u0026rsquo;instruccions.\n Aquestes instruccions aniran contingudes dins de parèntesis {} i precedides de la paraula else.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n} else {\nAcció3;\n}\nAcció4;     3. Estructura encadenada o múltiple (if/else if/ else) A vegades es dóna la situació que no volem decidir només entre dos camins d\u0026rsquo;execució, sinó que el problema ens requereix escollir entre diferents camins, així serà necessari introduir la figura del else if(). Comportament:\n En aquest cas el programa avalua la primera expressió booleana que es troba, si és certa executa el bloc d\u0026rsquo;instruccions que hi pertany. Però si l\u0026rsquo;avaluació és falsa anirà a la següent expressió booleana que es trobarà en un bloc else if(). I així consecutivament fins a la última. S\u0026rsquo;ha de tenir en compte que és important la prioritat en l\u0026rsquo;avaluació de les diferents expressions booleanes. Si s\u0026rsquo;avalua a cert en alguna expressió booleana JA NO avalua els següents casos, entra dins el bloc d\u0026rsquo;instruccions, s\u0026rsquo;executen les instruccions pertinents, i surt de l\u0026rsquo;estructura de control sense avaluar la resta de casos (podrien avaluar-se també a cert, per això és important la prioritat alhora d\u0026rsquo;establir els casos). Si s\u0026rsquo;introdueix un bloc else i cap expressió booleana s\u0026rsquo;avalua a cert, s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions corresponents a l\u0026rsquo;else.     Codi Diagrama de flux     Acció0;\nif ( cond1 ) {\nAcció1;\n} else if (cond2) {\nAcció2;\n}else if (cond3) {\nAcció3;\n}else if (cond4) {\nAcció4;\n}else {\nAcció5;\n}\nAcció6;     4. Sentència switch (switch) Aquesta estructura és útil quan en funció del valor d\u0026rsquo;una variable es poden executar camins d\u0026rsquo;instruccions diferents. Per exemple podríem pensar en un menú d\u0026rsquo;una app on tenim diferents opcions o un comandament a distància de la tele. Consideracions:\n En aquest cas s\u0026rsquo;avalua a == EL VALOR de la variable en qüestió i definirem les instruccions pertinents en cada cas. A l\u0026rsquo;inici d\u0026rsquo;aquesta estructura comença amb un switch seguida de la variable que volem avaluar entre parèntesi: switch (variable). Tot seguit, i entre claus {}, definim tots els casos que es volen tractar d\u0026rsquo;aquesta variable. Per a cada cas existeix un bloc case valor: amb tots els casos possibles. Si volem executar un bloc d\u0026rsquo;instruccions en cas que no es trobi cap dels valors desitjats per la variable sempre tenim el bloc default: que ens permet fer la mateixa funció que \u0026ldquo;l\u0026rsquo;else\u0026rdquo; en les estructures anteriors. En cada bloc case és necessari acabar-lo amb un break; necessari per a que ens surti de l\u0026rsquo;estructura switch. És una estructura que podríem simular amb una estructura encadenada o múltiple, la única diferència respecte a l\u0026rsquo;anterior és que en aquest cas, si no posem el break, sí que permetria executar més d\u0026rsquo;un case diferent.     Codi Diagrama de flux     Acció0;\nswitch ( expressio ) {\ncase valor1:\nAcció1;\nbreak;\ncase valor2:\nAcció2;\nbreak;\ncase valor3:\nAcció3;\nbreak;\ncase valor4:\nAcció4;\nbreak;\ndefault:\nAcció5;\n} Acció6;     5. Combinació d\u0026rsquo;estructures Moltes vegades els problemes que ens trobem a la vida real requereix de la composició de diferents estructures de control, així doncs es podria donar el cas que tinguéssim diferents estructures de control unes dins d\u0026rsquo;altres de forma jerarquitzada.\nExemple: En l\u0026rsquo;època actual de Coronavirus, donat els cribatges de PCRs per detectar casos positius ens interessaria detectar quins són els assimptomàtics. Així doncs m\u0026rsquo;invento un algorisme que permeti filtrar aquelles persones que ens interessa per realitzar les proves. És necessari que donades unes quantes dades ens digui si cal que faci alguna de les proves o no.\n Volem analitzar les persones entre 18 i 40 anys, d\u0026rsquo;aquestes es farà la prova bàsica de PCR, però les noies embarassades no realitzaran aquesta bàsica sinó que faran una prova més avançada. Pel que fa a les persones majors de 40 anys els hi realitzarem una prova avançada de PCR i un test d\u0026rsquo;esforç físic.  Exemples  Crea un programa on es mostri el resultat de sumar dos nombres sempre que la suma de tots dos sigui inferior o igual a 15. (exemple estructura simple)  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int suma = num1 + num2; if( suma \u0026lt;= 15) { System.out.println(num1+num2); }  Crea un programa que permeti a dir, donats dos nombres per l\u0026rsquo;usuari, si són múltiples l\u0026rsquo;un a l\u0026rsquo;altre. (exemple estructura composta)  System.out.println(\u0026quot;Entra el 1r nombre\u0026quot;); int num1 = sc.nextInt(); System.out.println(\u0026quot;Entra el 2n nombre\u0026quot;); int num2 = sc.nextInt(); if(num1%num2 == 0 || num2%num1 == 0){ System.out.println(\u0026quot;Són divisors\u0026quot;); } else { System.out.println(\u0026quot;No són divisors\u0026quot;); }  Creeu un programa que permeti introduir dos nombres i realitzar una operació sobre la base de l\u0026rsquo;nombre de codi, 1, 2 o 3 permeti restar, multiplicar o dividir els dos nombres i mostrar el resultat per pantalla.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int opcio = sc.nextInt(); if(opcio==1)System.out.println(num1 - num2); else if(opcio == 2) System.out.println(num1 * num2); else if(opcio == 3) System.out.println(num1 / num2); else System.out.println(\u0026quot;Opcio no correcta.\u0026quot;);  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int codi = sc.nextInt(); int resultat=0; if(codi==1) { resultat = operand1 - operand2; }else if(codi==2){ resultat = operand1 * operand2; }else if(codi==3){ resultat = operand1 / operand2; }else{ System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat);  El mateix exemple anterior però ara amb un switch.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int codi = sc.nextInt(); int resultat=0; switch(codi) { case 1: resultat = operand1 - operand2; break; case 2: resultat = operand1 * operand2; break; case 3: resultat = operand1 / operand2; break; default: System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat); switch(codi) { case 1: case 2: case 3: System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot; + resultat); }  Crea un programa que donats 4 números indiqui si els números són iguals i quin d\u0026rsquo;ells és el menor i major nombre de tots ells. El programa a més haurà de mostrar per pantalla el resultat de restar el major pel menor d\u0026rsquo;ells i el resultat de multiplicar els altres dos.  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int num3 = sc.nextInt(); int num4 = sc.nextInt(); int max = num1; int min = num1; int mult; /** * * Són iguals?? */ if(num1 == num2 \u0026amp;\u0026amp; num1 == num3 \u0026amp;\u0026amp; num1 == num4) System.out.println(\u0026quot;Són iguals\u0026quot;); else System.out.println(\u0026quot;No són iguals\u0026quot;); /** * PROBLEMA DEL MAJOR MENOR 5 OPCIONS * */ //OPCIO 1 força bruta if(num2\u0026gt;num1 \u0026amp;\u0026amp; num2\u0026gt;num3 \u0026amp;\u0026amp; num2\u0026gt;num4)max = num2; else if(num3\u0026gt;num1 \u0026amp;\u0026amp; num3\u0026gt;num2 \u0026amp;\u0026amp; num3\u0026gt;num4) max = num3; else if(num4\u0026gt;num1 \u0026amp;\u0026amp; num4\u0026gt;num2 \u0026amp;\u0026amp; num4\u0026gt;num3) max = num4; if(num2\u0026lt;num1 \u0026amp;\u0026amp; num2\u0026lt;num3 \u0026amp;\u0026amp; num2\u0026lt;num4)min = num2; else if(num3\u0026lt;num1 \u0026amp;\u0026amp; num3\u0026lt;num2 \u0026amp;\u0026amp; num3\u0026lt;num4) min = num3; else if(num4\u0026lt;num1 \u0026amp;\u0026amp; num4\u0026lt;num2 \u0026amp;\u0026amp; num4\u0026lt;num3) min = num4; //OPCIO 2 comparem el max amb tots i el min amb tots individualment max = num1; if(num2\u0026gt;max) max = num2; if(num3\u0026gt;max) max = num3; if(num4\u0026gt;max) max = num4; min = num1; if(num2\u0026lt;min) min = num2; if(num3\u0026lt;min) min = num3; if(num4\u0026lt;min) min = num4; //OPCIO 3 a Semifinals comparant! int max1,max2, min1,min2; if(num1\u0026gt; num2)max1 = num1; else max1 = num2; if(num3 \u0026gt; num4) max2 = num3; else max2=num4; if(max1 \u0026gt; max2) max = max1; else max=max2; if(num1 \u0026lt; num2)min1 = num1; else min1 = num2; if(num3 \u0026lt; num4) min2 = num3; else min2=num4; if(min1 \u0026gt; min2) min = min1; else min=min2; //OPCIO 4 semifinals math.max math.min max1 = Math.max(num1,num2); max2 = Math.max(num3,num4); max = Math.max(max1,max2); min1 = Math.min(num1,num2); min2 = Math.min(num3,num4); min = Math.min(min1,min2); //OPCIO 5 math.max i math.min max = Math.max (Math.max(num1,num2), Math.max(num3,num4)); min = Math.min (Math.min(num1,num2), Math.min(num3,num4)); System.out.println(max-min); //Segona part de l'activitat on es realitza la multiplicacio amb els que no són major i menor if( (max==num1 \u0026amp;\u0026amp; min==num2) || (max==num2 \u0026amp;\u0026amp; min==num1))mult=num3 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num1))mult=num2 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num1))mult=num2 * num3; else if( (max==num2 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num2))mult=num1 * num4; else if( (max==num2 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num2))mult=num1 * num3; else if( (max==num3 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num3))mult=num1 * num2; //Solució utilitzant Math.mix i Math.max per extreure valors que no siguin ni màxim ni mínim. int min3 = Math.min (Math.max(num1,num2), Math.max(num3,num4)); int max3 = Math.max (Math.min(num1,num2), Math.min(num3,num4)); int mult2 = min3 * max3;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/iteratiu/",
	"title": "Estructura iterativa",
	"tags": [],
	"description": "",
	"content": "Estructura iterativa L\u0026rsquo;estructura de control iterativa permet reproduir un bloc d\u0026rsquo;instruccions un nombre de vegades determinat.\nMentre es compleixi una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet executar un bloc d\u0026rsquo;instruccions determinat. Anomenarem bucle el bloc d\u0026rsquo;instruccions que es repeteixen i iteració a cadascuna de les vegades que es repeteix.\n Característiques generals:  Tots els bucles tenen:\n Una precondició: Estat abans d\u0026rsquo;entrar al bucle Una postcondició:Estat al sortir de bucle Una expressió booleana: mentre es compleixi l\u0026rsquo;expressió booleana s\u0026rsquo;itera el bucle, un cop l\u0026rsquo;expressió booleana s\u0026rsquo;avalua a fals es \u0026ldquo;surt\u0026rdquo; del bucle i es continua amb l\u0026rsquo;execució de les instruccions següents. Variable de control: Ens serveix per controlar el nombre d\u0026rsquo;iteracions. Aquesta variable pot estar englobada en un dels següents grups:  acumulador: guardem en una variable una operació concreta. comptador: augmentem o disminuïm una variable \u0026ldquo;comptant\u0026rdquo; iteracions. booleana: pot ser simplement una variable booleana que es manipuli dins el bucle.     Un bucle necessita:\n1. Una condició de sortida: cal que l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals per sortir del bucle, sinó provocarem un bucle infinit.\n2. La variable de control ens ha d\u0026rsquo;acostar pas a pas a complir amb la condició de sortida del bucle.\n3. Dins el bucle acostumen a ver instruccions amb l\u0026rsquo;objectiu de buscar un resultat.\n Existeixen diferents estructures iteratives.\n While For Do while Combinació d\u0026rsquo;estructures  1. While L\u0026rsquo;estructura bàsica d\u0026rsquo;un bucle while en Java és:\nwhile(expressió booleana){ Instruccions del bucle }  Com ja s\u0026rsquo;ha explicat, mentre s\u0026rsquo;avaluï l\u0026rsquo;expressió booleana a cert s\u0026rsquo;executaran totes les instruccions contingudes en les claus {}. Quan es deixi de complir l\u0026rsquo;expressió booleana el fil d\u0026rsquo;execució sortirà del bucle i continuarà amb la següent instrucció que hi hagi després.\nConsideracions:\n Si l\u0026rsquo;expressió no avalua a una expressió booleana donarà un error de compilació. Si no s\u0026rsquo;apliquen mecanismes que modifiquen el comportament de l\u0026rsquo;expressió booleana aconseguirem un bucle infinit.     Codi Diagrama de flux     Acció1;\nwhile ( cond ) {\nAcció2;\n}\nAcció4;     2. For El for és una estructura que permet realitzar recorreguts a un conjunt de dades de forma simple. Ens permet condensar la funcionalitat de bucle en una sola línia. Per exemple podem recorre els nombres del 1 al 10 de la següent manera:\nfor(int i=1; i \u0026lt;= 10; i++){ System.out.println(i); }  Com s\u0026rsquo;observa, dins dels parèntesi \u0026ldquo;()\u0026rdquo; tenim tres instruccions separades per \u0026ldquo;;\u0026rdquo; :\n Inicialització d\u0026rsquo;una variable iteradora abans d\u0026rsquo;entrar al bucle (int i=1). Després tenim l\u0026rsquo;expressió booleana igual com posaríem en un bucle while (i\u0026lt;=10). Finalment tenim el pas que ens assegura que el bucle acaba (i++).  Així doncs\nfor (inicialització Iterador; Expressió booleana; Modificació Iterador)\n Qualsevol bucle while es pot transformar en un bucle for i viceversa.\n Així doncs, l\u0026rsquo;exemple anterior si el transformem en un while queda de la següent manera:\nint i=1; //Inicialització variable while( i \u0026lt;= 10 ){ //Expressió booleana System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }  3. Do while Aquesta estructura no és gaire utilitzada i és similar a l\u0026rsquo;estructura while. La diferència és que en el while abans de realitzar cap iteració es comprova l\u0026rsquo;expressió booleana, en canvi amb el do while primer es realitzar una iteracio i després es comprova l\u0026rsquo;expressió booleana. A efectes pràctics si estem segurs que existeix almenys una iteració es pot usar aquesta estructura.\nEl cas anterior fet en do while seria:\nint i=1; //Inicialització variable do { System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }while( i \u0026lt;= 10 ); //Expressió booleana     Codi Diagrama de flux     Acció1;\ndo {\nAcció2;\n} while ( cond );\nAcció3;     4. Combinació d\u0026rsquo;estructures Moltes vegades els nostres programes requereixen de més d\u0026rsquo;un bucle encadenat, per exemple quan resseguim una matriu de dades. Imagineu-vos un programa que escanegi un tauler d\u0026rsquo;escacs, no només ha de llegir files, sinó que també ha de llegir columnes, així doncs l\u0026rsquo;estructura seria la següent:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } }  En l\u0026rsquo;exemple anterior per cada posició ièssima es recorre el bucle 8 vegades per cada j. Així per cada fila recorrem totes les columnes. Si mirem l\u0026rsquo;execució del bucle obtenim:\nPosició 1 1 Posició 1 2 Posició 1 3 Posició 1 4 Posició 1 5 Posició 1 6 Posició 1 7 Posició 1 8 Posició 2 1 Posició 2 2 Posició 2 3 Posició 2 4 Posició 2 5 Posició 2 6 Posició 2 7 Posició 2 8 Posició 3 1 Posició 3 2 Posició 3 3 ... Posició 8 8  En aquest cas estem parlant de dos bucles que són independents entre ells. Ja que per cada bucle interior no té afectació en l\u0026rsquo;exterior.\nPerò a vegades és necessari que els bucles siguin dependents, en aquest cas sí que hi hauria afectació. Modifiquem el programa anterior perquè per exemple enlloc de mostrar tot el tauler de posicions només vull mostrar aquelles que es troben per sobre de la diagonal:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ if(i \u0026lt; j) { System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } } }  En aquest cas, si executeu veureu que només mostra la meitat superior de posicions. Això és així perquè en el bucle interior realitzem una operació que DEPÈN de la variable i que pertany al primer bucle, per tant el bucle interior depèn de l\u0026rsquo;exterior.\nExemples  Fer un programa que llegeixi dos nombre enters n 1 i n 2 amb n 1 \u0026lt; n 2 i escrigui tots els nombres enters dins l’interval [n 1 , n 2 ] en ordre creixent. Aquest és un exemple de recorregut on la variable n1 fa de comptador.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); while(n1\u0026lt;=n2) { System.out.println(n1); n1++; }  Fer un programa que llegeixi dos nombre enters n 1 i n 2 amb n 1 \u0026lt; n 2 i escrigui els nombres enters parells que hi ha dins l’interval [n 1 , n 2 ] en ordre creixent. El nombre zero es considera parell.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); for(int i=n1; i \u0026lt;= n2; i++) { if(i%2==0)System.out.println(i); } //2naOpcio (meitat d'iteracions) if(n1%2!=0)n1++; while(n1\u0026lt;=n2) { System.out.println(n1); n1 = n1+2; }  Fer un programa que llegeixi el valor de la base, un nombre enter i l’exponent, un nombre enter no negatiu, i escrigui el valor de la potència a b . No emprar la funció Math.pow(). En aquest cas resultat fa d' acumulador d\u0026rsquo;un resultat que es mostra al final.  int base = sc.nextInt(); int exponent = sc.nextInt(); int i = 0; int resultat = 1; while(i \u0026lt; exponent) { resultat = resultat * base; i++; } System.out.println(resultat);  Fer un programa que llegeixi un nombre enter i escrigui si és un nombre primer o no. Un nombre enter és primer si es més gran que 1 i només és divisible per 1 i per ell mateix.  /* Fixeu-vos amb l'expressió booleana del bucle, en aquest cas es fa ús d'una variable booleana per sortir del bucle i no continuar iterant, en cas que ja haguem descobert la solució i no sigui necessari continuar iterant. */ System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); //inicialitzo variables,index=n/2 i analitzem tots els possibles divisors de n/2 fins a 1. boolean esPrimer = true; int index = n/2; //En la condició del bucle,si trobem un divisor ja no cal que continuem buscant i acabem while(index \u0026gt; 1 \u0026amp;\u0026amp; esPrimer){ if(n % index == 0) esPrimer=false; index--; } //Escrivim solucio String sol = (!esPrimer)? \u0026quot;NO és primer\u0026quot; : \u0026quot;És primer\u0026quot; ; System.out.println(sol);  Fer un programa que llegeixi un nombre enter i escrigui si és capicua o no.Considerarem també capicues els nombres enters d\u0026rsquo;una xifra.  System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); int valorInicial = n; int capicua = 0; while(n\u0026gt;0){ capicua = capicua*10; capicua = capicua + n%10; System.out.println(capicua); n = n/10; } System.out.println(capicua); if(valorInicial == capicua) System.out.println(n+ \u0026quot;és un nombre capicua\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/cadenescaracters/",
	"title": "Tractament cadena de caràcters",
	"tags": [],
	"description": "",
	"content": "Thanks to the simplicity of Hugo, this page is as empty as this theme needs requirements.\nJust download latest version of Hugo binary (\u0026gt; 0.25) for your OS (Windows, Linux, Mac) : it\u0026rsquo;s that simple.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/",
	"title": "Programació estructuada",
	"tags": [],
	"description": "",
	"content": "Què és la programació estructurada? La programació estructurada és un paradigma de programació en el qual les instruccions de codi s\u0026rsquo;executen de forma ordenada utilitzant només tres estructures: seqüencial, condicional i repetitiva.\n S\u0026rsquo;anomena estructura a la manera en què diferents parts es combinen per construir un tot. Un programa tindrà l\u0026rsquo;estructura corresponent a la forma en què les diferents accions individuals o avaluacions parcials es combinen per construir el programa en el seu conjunt.\nEls fonaments de l\u0026rsquo;anomenada programació estructurada es van establir a principis dels anys seixanta i es van consolidar amb els treballs de Dijkstra, Bohm.. El resum dels seus postulats és el següent: \u0026ldquo;es diu que un programa és estructurat si s\u0026rsquo;expressa únicament mitjançant combinacions de les estructures bàsiques\u0026rdquo;:\n seqüencial condicional iterativa  Estructura bàsica: Totes les estructures de control tenen un únic punt d\u0026rsquo;entrada i un únic punt de sortida.\nTot seguit repassarem les tres estructures de control: seqüencials, condicionals i iteratives en Java.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/",
	"title": "Estructures compostes",
	"tags": [],
	"description": "",
	"content": "Fins ara hem treballat amb estructures de dades simples. A mesura que tractem problemes més complexos es fa necessari agrupar i tractar les dades com un únic conjunt, això són el que s\u0026rsquo;anomenen els objectes, l\u0026rsquo;encapsulament de dades en una mateixa estructura. Així doncs en el següent capítol analitzarem:\n Arrays unidimensional: conjunt de dades del mateix tipus dins una dimensió. Arrays bidimensionals: conjunt de dades del mateix tipus dins de dues dimensions. (Taula) Cadena de caràcters: conjunt de caràcters que s\u0026rsquo;agrupen en una estructura que s\u0026rsquo;anomena String.   "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/",
	"title": "M03 Programació DAM",
	"tags": [],
	"description": "",
	"content": "M03 Programació DAM En aquesta pàgina web trobareu els apunts del M03. Programació DAM. La web està realitzada utilitzant un Framework Web(Hugo), hostatjada a Github i es fa ús de Github Pages.\nTot seguit es mostra la calendarització i les hores de les UFs que s\u0026rsquo;imparteixen en aquest mòdul de 1r de DAM. Fixeu-vos que l\u0026rsquo;ordre de realització de les UFs és: UF1, UF2, UF4 i UF3. La UF4 segueix a la UF2, ja que pedagògicament té més sentit realitzar-la després d\u0026rsquo;aquesta UF.\n   UF dates hores     UF1: Programació estructurada 15/09/20 - 11/12/20 85h   UF2: Disseny modular 14/12/20 - 05/02/21 50h   UF4: Programació orientada a objectes (POO) 06/02/21 - 23/04/21 68h   UF3: Fonaments de fitxers 24/04/21 - 25/05/21 30h    L\u0026rsquo;índex de continguts que veurem és:\n UF1: Programació estructurada  Estructura d\u0026rsquo;un programa  Introducció Metodologies de Software Tipus de Llenguatges   Tipus de dades Algorísmia Programació estructurada  Estructura sequencial Estructura condicional Estructura iterativa   Estructures compostes  Arrays Unidimensionals Arrays Bidimensionals Tractament cadena de caràcters      UF2: Disseny modular\nUF4: Programació orientada a objectes (POO)\nUF3: Fonaments de fitxers\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]