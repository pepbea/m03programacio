[
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arrayunidimensional/",
	"title": "Arrays Unidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que conté una col·lecció de dades del mateix tipus.\n La biblioteca de classes de Java inclou una classe auxiliar que s\u0026rsquo;anomena java.util.Arrays i conté funcions molt útils per utilitzar amb arrays: Java Oracle Classe Arrays\nPropietats\n Els arrays s\u0026rsquo;utilitzen com a contenedors per guardar dades relacionades (enlloc de declarar variables per separat per cada un dels elements de l\u0026rsquo;array). Totes les dades incluïdes a l\u0026rsquo;array són del mateix tipus. Es poden crear arrays d\u0026rsquo;enters (int, long), de reals(float, double), però en un mateix array no es poden mesclar dades de tipus diferents. En els arrays estàtics el tamany s\u0026rsquo;estableix quan es crea l\u0026rsquo;array (amb l\u0026rsquo;operador new, igual que qualsevol altre objecte). Als elements de l\u0026rsquo;array si accedirà a través de la posició que ocupa dins el conjunt d\u0026rsquo;elements de l\u0026rsquo;array.  Exemple Per exemple podríem necessitar les edats d\u0026rsquo;una classe per efectuar-ne un tractament especial. Fins ara el que podíem fer és declarar tantes variables enteres com alumnes hi hagi per tal de guardar-ne l\u0026rsquo;edat:\nint edatAlumne1 = 29; int edatAlumne2 = 26; int edatAlumne3 = 18; ... int edatAlumne30 = 28;  Com podeu observar, si escaléssim el problema anterior i enlloc de 30 necessitéssim les edats dels 700 estudiants de l\u0026rsquo;institut, la declaració de variables seria una feina feixuga i amb un alt índex d\u0026rsquo;equivocar-nos, a més no permetria mantenir i modificar el programa de forma àgil. Per això hi ha les estructures de dades d\u0026rsquo;un mateix tipus. Una manera de guardar 700 edats dins una mateixa estructura seria aquesta:\n//Declarem una posició de memòria on hi ha una referència a un array int[] edatsAlumnes; //Aquest array és estàtic, per això abans d'usar-lo ens reservem en memòria el nombre d'enters que necessitem edatsAlumnes = new int[700]; //Omplim les edats dels alumnes for(int i = 0; i \u0026lt; edatsAlumnes.length; i++) edatsAlumnes[i] = sc.nextInt();  Declaració array En les línies anteriors hem observat que per crear un objecte array, és necessari fer servir la paraula reservada new, amb això el que fem és reservar en memòria l\u0026rsquo;espai necessari per allotjar la informació. En el següent exemple creem un array estàtic que l\u0026rsquo;anomeno arrayEstatic de 12 posicions.\nint[] arrayEstatic = new int[12]; //També es podria fer de la següent manera: int arrayEstatic[] = new int[12];  Fixeu-vos que en el primer exemple he fet la declaració i la reserva d\u0026rsquo;espais dels enters en instruccions separades, en canvi en aquest últim exemple ho he fet tot junt en una única línia.\nPer accedir a la posició enèssima de l\u0026rsquo;array ho puc fer de la següent manera arrayEstatic[n].\nEls Indexs d\u0026rsquo;un array comencen en la posició 0, no en la 1. L\u0026rsquo;últim element de l\u0026rsquo;array es troba a la posició llargària de l\u0026rsquo;array - 1. Així doncs en l\u0026rsquo;exemple anterior el primer enter de l\u0026rsquo;arrayEstatic es troba en la posició arrayEstatic[0] mentre que l\u0026rsquo;últim en la posició arrayEstatic[11]. Hem de tenir en compte que l'índex no pot ser un valor negatiu, i que per exemple podria ser un càlcul numèric o fent ús de variables arrayEstatic[i + 1]\n És important entendre que un cop declaro un arrayEstatic, es reserva en memòria espai per guardar el tipus de dades * Tamany de l'array. En l\u0026rsquo;exemple anterior es demana al programa que ens reservi espai per a 12 enters consecutius. Aquests enters no tenen un valor definit (al ser enters Java els hi posa un 0, si fossin booleans el valor per defecte seria false), per tant cal que els inicialitzem un valor per utilitzar-los.\nint index = 4; int array[index + 1]++;  En aquest exemple s\u0026rsquo;observa com inicialitzem un índex a 4, s\u0026rsquo;accedeix a l\u0026rsquo;element amb índex 5 de l\u0026rsquo;array, és la posició 6 (recordeu que el 0 és la primera posició de l\u0026rsquo;array) i en l\u0026rsquo;enter de la posició 6 n\u0026rsquo;augmentem el valor en una unitat.\nLongitud Al ser una estructura estàtica la longitud de l\u0026rsquo;array no es pot variar i es defineix quan es crea (amb el new). Per tal d\u0026rsquo;obtenir el seu valor en Java utilitzarem la funció length:\nSystem.out.println(\u0026quot;La longitud de l'array és \u0026quot; + array.length);  Una altra inicialització Una altra manera d\u0026rsquo;inicialitzar un array és directament definint els seus elements:\nint[] array2 = {10, 20, 54, -2, 76 };  Si a aquest array2 imprimissim el seu valor de array2.length el resultat seria 5. De forma que s\u0026rsquo;hauria declarat i reservat la memòria directament.\nRecorregut i manipulació d\u0026rsquo;arrays Normalment ens trobarem amb problemes on cal accedir a arrays i efectuar-ne un tractament determinat. Per exemple, ens podríem trobar el següent problema:\n Com ho faríem per guardar en un array els 10 primers números parells?\n //declaració i creació de l'array\tint[] llista = new int[10]; //modificació el valor dels elements de l'array for(int i=0; i\u0026lt;llista.length; i++) { llista[i] = i*2; }\t//Imprimim els valors 0 2 4 6 8 10 12 14 16 18 for(int i=0; i\u0026lt;llista.length; i++) { System.out.print(llista[i] + \u0026quot; \u0026quot;); }  Es pot observar com mitjançant l\u0026rsquo;índex i s\u0026rsquo;accedeix a tots els elements de l\u0026rsquo;array i se\u0026rsquo;n va modificant el seu valor.\nOrdenació arrays Una altra funcionalitat corrent és l\u0026rsquo;ordenació de arrays. En Java existeix una funció que ordena els elements d\u0026rsquo;un array, més endavant l\u0026rsquo;estudiarem amb deteniment.\nArrays.sort(vector);  Existeixen molts algorismes diferents capaços d\u0026rsquo;ordenar els elements d\u0026rsquo;un array, tots ells tenen la seva lògica i obeeixen a casuïstiques diferents, i per tant també tenen costos de còmput diferent. En la següent web podrem observar simulacions de diferents algorismes en un llenguatge de pseudocodi i com evoluciona cada array fins a la seva ordenació: Visualgo\nCerca d\u0026rsquo;un element dins l\u0026rsquo;array La cerca d\u0026rsquo;un element dins un array és un problema típic. No és el mateix tenir l\u0026rsquo;array ordenat que l\u0026rsquo;array desordenat:\n Si l\u0026rsquo;array està desordenat farem un recorregut buscant l\u0026rsquo;element, si no el troba s\u0026rsquo;arriba al final de l\u0026rsquo;array, si el troba sortim de l\u0026rsquo;array abans de la seva finalització. Si l\u0026rsquo;array està ordenat, a diferència de l\u0026rsquo;anterior, no cal que busquem fins al final de l\u0026rsquo;array, un cop \u0026ldquo;em passi\u0026rdquo; de l\u0026rsquo;element que estic buscant ja no cal que continuï, és una manera d\u0026rsquo;optimitzar la cerca.  Cerca en array desordenat:\ndouble[] array = {2, 5.5, 9.1, 1, 2.9, 8, 5.5, 55.4, 2.6, 5.45, 7}; //Definim variable booleana per saber si s'ha trobat el valor boolean trobat = false; //Índex int i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length) \u0026amp;\u0026amp; (!trobat)) { if (array[i] == 8) { trobat = true; } i = i + 1; } //S’ha trobat? String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Cerca en array ordenat:\ndouble[] array = {2, 5.5, 8, 9.1, 10.4, 12.9, 18, 25.5, 55.4}; //Definim variable booleana per saber si s'ha trobat el valor boolean trobat = false; //Definim variable booleana per saber si ens hem passat ja de l'element boolean passat=false; //Índex int i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length) \u0026amp;\u0026amp; (!trobat) \u0026amp;\u0026amp; (!passat)) { if (array[i] == 8) { trobat = true; } if (array[i] \u0026gt; 8) { passat = true; } i = i + 1; } //S’ha trobat? String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Bucle for millorat per arrays Per tal d\u0026rsquo;efectuar el recorregut en un array java ens permet aquesta expressió reduïda de bucles for. Per exemple, els bucles següents són equivalents:\nfor(int i=0; i\u0026lt;array.length; i++) { int valor = array[i]; System.out.println(valor); } for(int valor: array) { System.out.println(valor); }  La versió adaptada del bucle for es pot fer servir amb qualsevol tipus d\u0026rsquo;array (String, int, boolean, etc.).\nMètodes més usats de la classe java.util.Arrays Arrays.sort(array); // Ordena els elements Arrays.equals(array1, array2); // Comprova si els dos arrays són iguals Arrays.fill(array, val) //Omple el vector v amb el valor \u0026quot;val\u0026quot; Arrays.toString(array) // Retorna una cadena que representa el contingut del vector Arrays.binarySearch(array, k) // Busca el valor k dins del vector array (que prèviament ha estat ordenat)  Exemples  Exemple de diferents maneres per omplir de valors un array i imprimir-lo per línia de comandes:  //Crear Array int primerArray[] = new int[7]; //Omplir de valors amb for i després amb while for(int i=0; i \u0026lt; primerArray.length; i++){ primerArray[i] = sc.nextInt(); } int i=0; while(i \u0026lt; primerArray.length){ primerArray[i] = sc.nextInt(); i++; } //Mostrar valors amb toString amb bucle for i bucle for millorat Arrays.toString(primerArray); for( i=0; i \u0026lt; primerArray.length; i++){ System.out.println(primerArray[i]); } for( int valor : primerArray){ System.out.println(valor); } //Ús de la funció fill de la classe Arrays que consisteix en omplir totes les posicions d'un array amb el mateix valor Arrays.fill(primerArray,7); for(i=0; i \u0026lt; primerArray.length; i++){ primerArray[i] = 7; }  Còpia d\u0026rsquo;arrays  int[] llista = {1,2,3,4}; //llita i llistaCopia apunten al mateix array ja que són referències int[] llistaCopia = llista; //Fent ús de clone. En aquest cas llista i llistaCopia SON DOS ARRAYS IGUALS I INDEPENDENTS llistaCopia = llista.clone(); //còpia manual dels elements\tfor(i=0; i \u0026lt; llista.length; i++){ llistaCopia[i] = llista[i]; } System.out.println(\u0026quot;Contingut de l'array 'llista'\u0026quot;); for(int valor : llista) System.out.println(valor); System.out.println(\u0026quot;Contingut de l'array 'llistaCopia'\u0026quot;); for(int valor : llistaCopia) System.out.println(valor);  Cerca d\u0026rsquo;un element dins un array (exemple del màxim)  primerArray = new int[]{-1, -2, -3, -4}; int max = 0; for(i=0; i \u0026lt; primerArray.length; i++){ if(max\u0026lt;primerArray[i]) max = primerArray[i]; }  Sumar els elements d\u0026rsquo;un array valor a valor i guardar-lo en un altre array  int vector1[] = new int[10]; int vector2[] = new int[10]; //falta introduir els valors en vector1 i vector2 int suma[] = new int[10]; for( i=0; i\u0026lt;suma.length;i++){ suma[i] = vector1[i] + vector2[i]; }  Cerca dicotòmica  //Tamany vector System.out.println(\u0026quot;De quants elements vols el vector?\u0026quot;); int llargada = sc.nextInt(); //Creem i posem elements aleatoris entre 0 i 100 dins el vector i l'ordenem int [] vector = new int[llargada]; for(int i=0; i\u0026lt;llargada;i++) vector[i] = (int)(Math.random()*100); Arrays.sort(vector); //Imprimim vector System.out.println(Arrays.toString(vector)); //Quin element vols buscar? System.out.println(\u0026quot;Quin element vols buscar?\u0026quot;); int nombreBuscat = sc.nextInt(); //inicialitzem index inferior i superior i declarem element central int elementCentral; int inferior=0; int superior=llargada-1; //inicialment no s'ha trobat l'element boolean trobat = false; int iteracions = 0; //mentre element inferior no rebassi el superior continuem explorant while(inferior\u0026lt;=superior \u0026amp;\u0026amp; !trobat){ //Augmentem nombre iteracions iteracions++; //busquem quin és l'element central elementCentral=(superior+inferior)/2; //Imprimim l'estat actual System.out.println(\u0026quot;Iteracio: \u0026quot; + iteracions + \u0026quot; Inferior:\u0026quot; + inferior + \u0026quot; Superior:\u0026quot; + superior + \u0026quot; Element Central:\u0026quot; + vector[elementCentral] + \u0026quot; A buscar:\u0026quot; + nombreBuscat); for(int i=inferior; i \u0026lt;= superior; i++) System.out.print(vector[i]+\u0026quot; \u0026quot;); System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;\u0026quot;); //Si el trobem posem trobat a true per sortir del bucle i anunciem que l'hem trobat if(vector[elementCentral]==nombreBuscat){ trobat=true; System.out.println(\u0026quot;L'element \u0026quot;+nombreBuscat+\u0026quot; està dins l'array\u0026quot;); } //Sinó actualitzem index, caldrà actualitzar o bé el superior en cas que el nombre buscat sigui inferior a l'actual, o bé l'inferior en cas contrari. else if(nombreBuscat \u0026lt; vector[elementCentral] ){ superior=elementCentral-1; } else { inferior=elementCentral+1; } } //Si no el trobem ho anunciem if(!trobat)System.out.println(\u0026quot;L'element no es troba en el vector\u0026quot;); /** * Comparem amb... * CERCA LINEAL * **/ inferior=0; superior=llargada-1; //inicialment no s'ha trobat l'element trobat = false; iteracions = 0; //mentre element inferior no rebassi el superior continuem explorant while(inferior\u0026lt;=superior \u0026amp;\u0026amp; !trobat) { //Augmentem nombre iteracions iteracions++; //Imprimim l'estat actual System.out.println(\u0026quot;Iteracio: \u0026quot; + iteracions + \u0026quot; Inferior:\u0026quot; + inferior + \u0026quot; Superior:\u0026quot; + superior + \u0026quot; Element Actual:\u0026quot; + vector[inferior] + \u0026quot; A buscar:\u0026quot; + nombreBuscat); for (int i = inferior; i \u0026lt;= superior; i++) System.out.print(vector[i] + \u0026quot; \u0026quot;); System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;\u0026quot;); //Si el trobem posem trobat a true per sortir del bucle i anunciem que l'hem trobat if (vector[inferior] == nombreBuscat) { trobat = true; System.out.println(\u0026quot;L'element \u0026quot; + nombreBuscat + \u0026quot; està dins l'array\u0026quot;); } //Miro el següent element inferior++; } //Si no el trobem ho anunciem if(!trobat)System.out.println(\u0026quot;L'element no es troba en el vector\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/",
	"title": "Estructura d’un programa",
	"tags": [],
	"description": "",
	"content": "En aquest apartat realitzarem una introducció sobre què és un programa informàtic, quines metodologies de Software hi ha al mercat alhora de treballar i analitzarem diferents classificacions dels llenguatges de programació:\n Introducció Metodologies de Software Tipus de Llenguatges  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/introducciodissenymodular/",
	"title": "Introducció Disseny Modular",
	"tags": [],
	"description": "",
	"content": "El paradigma de programació utilitzat fins ara ha estat el de la programació estructurada, consistent en tractar de desenvolupar programes més fiables i fàcils de mantenir mitjançant la utilització exclusiva de 3 estructures de control: la seqüencial, l\u0026rsquo;alternativa i la iterativa.\nQuan els programes comencen a créixer i es tornen difícils de resoldre en conjunt per la seva gran envergadura, la programació estructurada afavoreix la divisió del problema en parts més petites que poden ser abordades més fàcilment per separat. Es tracta del principi de \u0026ldquo;divideix i guanyaràs\u0026rdquo;.\nLa programació funcional, en el marc conceptual què estem tractant, consisteix justament en aplicar aquesta tècnica de divideix i venceràs per separar un programa en parts més senzilles, anomenades funcions.\nProgramació funcional: dividir un programa en funcions específiques dins del mateix arxiu. Programació modular: consisteix a agrupar en arxius separats un conjunt de funcions més genèriques i que guardin alguna relació entre elles amb la finalitat que puguin ser reutilitzades entre programes.\n 1. Subprogrames i mòduls El concepte de subprograma s’utilitza normalment per identificar un conjunt d’instruccions que conjuntament desenvolupen una tasca concreta i que pot ser (o no) necessària en diferents llocs del programa. El concepte de mòdul es destina normalment a identificar grans apartats d’una aplicació\n2. Accions, funcions i mètodes Els subprogrames es classifiquen en:\n  Acció és un conjunt d’instruccions amb un objectiu comú, que pot necessitar o no dades externes per a la seva execució i que NO retorna cap resultat a qui l\u0026rsquo;ha cridat.\n  Funció és un conjunt d’instruccions amb un objectiu comú, que pot necessitar o no dades externes per a la seva execució i que Retorna un resultat a qui l’ha cridat.\n  El llenguatge Java és orientat a objectes, i per tant tot s\u0026rsquo;encapsula dins de classes. En aquest context les accions i funcions s\u0026rsquo;implementen amb una estructura definida dins d\u0026rsquo;una classe i anomenada mètode.\nQuan codifiquem un mètode tindrem els següents elements:\n  Signatura o capçalera del mètode: Està composta per:\n El nom del mètode. Els arguments del mètode: ens informen de quins paràmetres obtenim per tal de poder usar dins el mètode. Si el llenguatge de programació usa tipus de dades, com Java, també ens especificarà de quin tipus de dades és cadascun d\u0026rsquo;aquests arguments. Tipus de dada que retorna el mètode: només s\u0026rsquo;especificarà si el llenguatge de programació usa tipus de dades, com Java.    Cos del mètode: Defineix l\u0026rsquo;algoritme que executarà el mètode. Dins del cos del mètode hi haurà el retorn del mètode on es posarà quina dada es retorna (si és que es retorna alguna dada).\n  Quan parlem de la crida a un mètode, ens referim a fer ús d\u0026rsquo;aquesta mètode des d\u0026rsquo;un altre mètode (ja sigui des de la mateixa classe o no).\nExemple de funció i acció Si per exemple tenim la següent funció:\npublic static int sumaFuncio(int a, int b){ int resultat; resultat = a + b; return resultat; }   La signatura és: public static int sumaFuncio(int a, int b) El nom suma Els arguments: (int a, int b) Tipus de dades que retorna int El cos són les tres instruccions de dins la funció.  Com podem comprovar l\u0026rsquo;anterior mètode es una funció ja que retorna un enter. Si volguéssim canviar aquesta funció per una acció (subprograma que no retorna cap valor) ho faríem de la següent manera:\npublic static void sumaAccio(int a, int b){ int resultat; resultat = a + b; System.out.println(resultat); }  Fixeu-vos que hem canviat int -\u0026gt; void i ara ja no retornem res, sinó que ho escrivim per pantalla.\nSi volem efectuar la crida dins el main del nostre programa faríem el següent per una funció i per una acció:\npublic static void main(String args[]){ int res = sumaFuncio(2,3); System.out.println(res); sumaAccio(2,3); }  3. Accessibilitat de les variables Les variables globals són les variables tals que el seu àmbit de validesa i disponibilitat és total, és a dir, es poden utilitzar, actualitzant-les o no, des del programa principal i des de tots els subprogrames. No és aconsellable l\u0026rsquo;ús de variables globals. Les definim just després de la declaració de la classe, per ex:\npublic class Main{ public static int variableGlobal; ...  Una variable local és aquella que està declarada dins d’un subprograma. L’àmbit d’ús de les variables locals és el subprograma en què s’han definit. L’àmbit d’existència d’una variable és la part de la classe en què la variable pot ser referenciada o s’hi pot accedir pel seu nom.\nEn Java, quan declarem una variable, aquesta és accessible només dins l\u0026rsquo;estructura on es declarada. En el cas dels arguments, només són visibles en el mètode en el qual s\u0026rsquo;usen. Posem un exemple:\npublic double m2km (double m) { double km; km = m / 1000; return km; }  En aquest cas les variables m i km només són accessibles dins del mètode m2km.\nUn altre exemple:\npublic int sumElements (int[] array) { int sum = 0; for(int i = 0; i \u0026lt; array.length; i++) sum = sum + array[i]; return sum; }  Les variables sum i array només són accessibles dins del mètode sumElements, però la variable i només és visible dins del for.\n4. Pas per valor o per referència Arguments o paràmetres Els arguments o paràmetres formals són les dades que apareixen a la signatura de la funció.\nEls paràmetres o paràmetres actuals són les dades transferides en la crida d\u0026rsquo;una funció.\nTransferència per valor o per referència:\n  En la transferència per valor, el valor del paràmetre actual es copia en una altra posició de memòria, a la qual es pot accedir pel nom del paràmetre formal. Aquesta NO ÉS la variable inicial, n\u0026rsquo;és una còpia del seu valor en una altra posició de memòria.\n  En la transferència per referència, el subprograma rep *l’adreça de memòria en què es troba el paràmetre actual, a la qual es pot accedir llavors pel nom del paràmetre formal. Per això en manipular una variable passada per referència es modifica l\u0026rsquo;original ja que actua sobre la MATEIXA posició de memòria.\n  A Java, les dades simples es passen per valor i les compostes (com els arrays o els Strings) es passen per referència.\n Exemple: Pas per valor o per referència Pas de paràmetres per valor o per referència. En aquest exemple es veu la diferència de passar un valor o de passar la referència on es troba aquest valor.\npublic class Parametres { // Paràmetres passats per valor perquè són de tipus simple public static void intercanvi(int a, int b) { System.out.println(\u0026quot;Dins del mètode intercanvi:\u0026quot;); System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); int temp = a; a = b; b = temp; System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); } // Paràmetres passats per referència perquè és de tipus compost (un objecte) public static void intercanviArray(int[] v) { System.out.println(\u0026quot;Dins del mètode intercanviArray:\u0026quot;); System.out.println(\u0026quot;v[0] = \u0026quot; + v[0]); System.out.println(\u0026quot;v[1] = \u0026quot; + v[1]); int temp = v[0]; v[0] = v[1]; v[1] = temp; System.out.println(\u0026quot;v[0] = \u0026quot; + v[0]); System.out.println(\u0026quot;v[1] = \u0026quot; + v[1]); } // Main() public static void main(String[] args) { // // Exemple de pas de paràmetres per valor // System.out.println(\u0026quot;PER VALOR\u0026quot;); int x = 5; int y = 10; System.out.println(\u0026quot;x = \u0026quot; + x); System.out.println(\u0026quot;y = \u0026quot; + y); System.out.println(\u0026quot;Cridem intercanvi(x, y)\u0026quot;); intercanvi(x, y); System.out.println(\u0026quot;Tornem del mètode intercanvi(x, y)\u0026quot;); System.out.println(\u0026quot;x = \u0026quot; + x); System.out.println(\u0026quot;y = \u0026quot; + y); System.out.println(); // // Exemple de pas de paràmetres per referència // System.out.println(\u0026quot;PER REFERÈNCIA\u0026quot;); int[] array = {25, 50}; System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(\u0026quot;Cridem intercanviArray(array)\u0026quot;); intercanviArray(array); System.out.println(\u0026quot;Tornem del mètode intercanviArray(array)\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(); // //Un altre exemple de pas per valor // System.out.println(\u0026quot;PER VALOR\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(\u0026quot;Cridem intercanvi(array[0], array[1])\u0026quot;); intercanvi(array[0], array[1]); System.out.println(\u0026quot;Tornem del mètode intercanvi(array[0], array[1])\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); } }  Observació: les cadenes (tipus String) són objectes, però són immutbales, per tant no poden canviar el seu valor\n5. Mètodes Estàtics o no estàtics Els mètodes no estàtics (o mètodes) són aquells que depenen d\u0026rsquo;un objecte i que per tant s\u0026rsquo;invoquen a partir de la instanciació d\u0026rsquo;un objecte.\n Posem un exemple, imaginem aquest mètode de la classe Conversor:\npublic double m2km (double m) { double km; km = m / 1000; return km; }  Per cridar aquesta mètode des d\u0026rsquo;un altre mètode faríem:\nConversor conv = new Conversor(); double kilometers; kilometers = conv.m2km(325012);  Els mètodes estàtics són aquells que no depenen d\u0026rsquo;un objecte i que per tant s\u0026rsquo;invoquen a partir de la classe.\n Posem un exemple, imaginem aquest mètode de la classe Arithmetic:\npublic static int sum (int a, int b) { int s; s = a + b; return s; }  Per cridar aquesta mètode des d\u0026rsquo;un altre mètode:\nint res; res = Arithmetic.suma(2,3);  Exemples Exemple1: Funció suma senzilla Realitzem la suma de dos nombres dins una funció i en retornem el resultat al programa principal:\npublic class Suma { public static void main(String[] args) { int res; int num = 25; // Exemples d'ús d'un mètode res = suma(2, 3); System.out.println(\u0026quot;suma = \u0026quot; + res); res = suma(num, 10); System.out.println(\u0026quot;suma = \u0026quot; + res); res = suma(res, num); System.out.println(\u0026quot;suma = \u0026quot; + res); } // Mètode que fa la suma de dos nombres enters public static int suma (int a, int b) { int s; s = a + b; return s; } }  Exemple2: Paràmetres del programa\npublic class ProvaArgs { /** * Imprimeix per pantalla tots els paràmetres passats en l'execució del programa * @param args Paràmetres al executar el programa */ public static void main(String[] args) { for (int i=0; i\u0026lt;args.length; i++) { System.out.println(\u0026quot;Paràmetre \u0026quot; + i + \u0026quot; = \u0026quot; + args[i]); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/1propositiblocs/",
	"title": "Introducció",
	"tags": [],
	"description": "",
	"content": "Breus definicions inicials Programació informàtica: És el procés d\u0026rsquo;escriure, provar, depurar/solucionar problemes, i mantenir el codi font de programes.\n Programa: Conjunt d\u0026rsquo;instruccions d’un llenguatge de programació, ordenades d\u0026rsquo;una manera determinada, que l’ordinador és capaç d’entendre i executar per resoldre un problema. L\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre unes normes sintàctiques i semàntiques que permeten realitzar multitud de funcions diferents.\n Instrucció: És una cadena de símbols d\u0026rsquo;un alfabet, formada d\u0026rsquo;acord amb certes regles sintàctiques que el processador (o el compilador) entén, i que finalment seran interpretades i executades pel processador.\n Llenguatge informàtic: Conjunt d\u0026rsquo;instruccions que ordenades d\u0026rsquo;una determinada manera generen un codi que l\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre per realitzar una determinada tasca.\n Dada: Unitat d\u0026rsquo;informació que utilitzen els programes informàtics per ser tractada (llegir, modificar, eliminar, crear, transformar\u0026hellip;).\n Codi font: Codi que els humans poden entendre i manipular per tal de crear i modificar els diferents programes informàtics. En Java els fitxers que contenen codi font són fitxers amb extensió .java\n Codi màquina: Una vegada el codi font és escrit pels humans es transforma en un altre fitxer (compilació) que genera un altre fitxer/codi que està a més baix nivell i que enten la màquina. En Java els fitxers convertits a codi màquina són els fitxers executables, són diferents per cada plataforma, per això diem que java és un llenguatge multiplataforma, perquè el mateix codi font el podem executar en plataformes diferents.\n Procés d\u0026rsquo;execució d\u0026rsquo;un programa Els programes informàtics donen solució a una determinada necessitat o problemàtica. A partir d\u0026rsquo;un problema determinat dissenyem un conjunt de passos determinats, ordenats i finits que ens aporta la solució (algorisme). La implementació d\u0026rsquo;aquests passos amb un llenguatge de programació genera un codi que dóna lloc al programa informàtic final.\nAixí doncs el programa té un iniciador, executa una sèrie d\u0026rsquo;instruccions que solucionen un problema determinat i existeix un punt de finalització quan es troba l\u0026rsquo;estat que soluciona el problema.\nEn aquest procés es possible que tinguem dades d\u0026rsquo;entrada (input: dades necessàries per executar un codi determinat), i també és possible que tinguem dades de sortida (output: dades que desitgem retornar o mostrar quan s\u0026rsquo;acaba l\u0026rsquo;execució del codi).\nTot el codi que hem escrit i que posem a executar l\u0026rsquo;anomenarem procés (codi en execució).\nCas particular de Java Tot seguit veiem què passa amb el programa HolaMon.java escrit en Java. És el primer programa que s\u0026rsquo;acostuma a mostrar de qualsevol llenguatge de programació. L\u0026rsquo;únic que fa aquest programa és escriure per pantalla \u0026ldquo;Hola Mundo\u0026rdquo;.\nSi us fixeu en la següent il·lustració es mostra tot el procés de compilació. Inicialment tenim el codi font del fitxer HolaMundo.java escrit pel programador. El següent pas és transformar aquest fitxer en un codi intermig que és el bytecode que permetrà ser transportat a qualsevol plataforma. Aquest codi intermig és un fitxer .class que ens assegura que el procés de compilació del fitxer .java s\u0026rsquo;ha executat correctament, en java s\u0026rsquo;utilitza la comanda javac per poder obtenir-lo. javac HolaMundo.java Amb aquesta instrucció \u0026ldquo;es compila\u0026rdquo; el programa i genera un HolaMundo.class.\nUn cop tenim el fitxer .class, executant la comanda java HolaMundo obtenim l\u0026rsquo;execucio del nostre programa sobre la plataforma on estiguem, per això en la imatge següent el codi màquina que s\u0026rsquo;executa amb Win32 serà diferent que el que interpreta MacOS ja que són SO\u0026rsquo;s diferents i obeeixen a instruccions diferents.\nEn el següent exemple es pot veure com seria un fitxer .java que es llegeix i s\u0026rsquo;enten amb llenguatge humà. A continuació, en el procés de compilació, es genera el fitxer .class, aquí ja els humans no entenem el contingut del fitxer ja que està en hexadecimal, i finalment quan executem el programa es genera un fitxer en codi màquina amb una tira de 0s i 1s que són les instruccions que necessita la CPU en cada plataforma per ser executat. Aquest últim fitxer serà diferent en cada plataforma d\u0026rsquo;execució (Linux, Windows, MacOS\u0026hellip;)\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/introducciopoo/",
	"title": "Introducció a la POO",
	"tags": [],
	"description": "",
	"content": "Com hem observat, a mesura que tenim problemes més complexes és necessari fer ús de tècniques que ens ajudin a programar d\u0026rsquo;una forma més senzilla, d\u0026rsquo;aquesta manera hem passat de la programació estructurada a la programació modular. Continuant en aquest procés ara toca fer el salt per conèixer la programació orientada a objectes (POO). Com ja hem vist dins el món de la programació hi ha una sèrie de paradigmes que repassem tot seguit.\nUn paradigma és una forma de representar i manipular el coneixement. Representa un enfocament particular o filosofia per a la construcció del programari.\n En l\u0026rsquo;apartat d' Estructura d\u0026rsquo;un programa -\u0026gt; Tipus de llenguatges s\u0026rsquo;aprofundeix en els diferents paradigmes de programació.\n1. Paradigma de Programació orientada a objectes Es fonamenta en la manera en que els éssers humans percebem i entenem els objectes del nostre món\n Exemple:\nJoan Maria Que tenen en comú el Joan i la Maria? Els dos són persones.\nMitjançant un procés de generalització sabem que els dos objectes Joan i Maria pertanyen a la mateixa classe persona.\nMitjançant aquesta abstracció identifiquem molts exemples de la mateixa plantilla. Així doncs sabem que tots aquests exemples tenen les característiques comunes d\u0026rsquo;una plantilla persona.\nAprofundim ara en els nostres exemples de Persona: Joan i Maria.\n          Atributs\n- Nom\n- Estatura\n- Pes\n- Color cabell\n- Color ulls\n- Edat\n- Sexe\n- Té un nas\nMètodes\n- Somriu\n- Parla\n- Dorm\n- Pensa\n- Menja    Atributs\n- Nom\n- Estatura\n- Pes\n- Color cabell\n- Color ulls\n- Edat\n- Sexe\n- Té un nas\nMètodes\n- Somriu\n- Parla\n- Dorm\n- Pensa\n- Menja    Com podem observar tant en Joan com la Maria tenen una sèrie de característiques comunes (atributs) i un comportament comú (mètodes) ja que els dos es poden classificar dins la mateixa categoria de persones.\nLa POO consisteix en fer servir aquesta manera natural de pensar en objectes com a mecanisme per a organitzar millor el nostre codi i poder desenvolupar, mantenir i ampliar aplicacions de software amb un alt grau de complexitat.\nCaracterístiques generals de POO Abstracció Es tracta de centrar-se en “el què fa” més que no en el “com ho fa”.\n Com hem vist en l\u0026rsquo;exemple anterior, sabem que dos objectes diferents com el Joan i la Maria tenen unes característiques i un comportament comú, d\u0026rsquo;aquí hem deduït per abstracció que formen part del mateix conjunt de persones. Així doncs l\u0026rsquo;abstracció ens permet aïllar aquella part que ens interessa del conjunt. Ex:\n No és necessari saber de mecànica de bicicletes per aprendre a anar en bicicleta. No és necessari conèixer què fan exactament les funcions del kernel de linux per usar-les. No ens cal conèixer en profunditat com funciona el rentaplats per usar-lo. Tots els exemples anteriors són casos en els que fem ús d\u0026rsquo;un instrument sense coneixer-lo a fons.  De fet, ja hem fet ús de l\u0026rsquo;abstracció en la UF2. Les accions i funcions que heu creat encapsulen línies de codi, quan fem crides a aquestes funcions s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions definides dins aquests blocs. De la mateixa manera quan definiu els mòduls/classes podeu crear funcions privades que utilitzeu pel funcionament del vostre programa però que NO seran accessibles des del programa principal.\nIgual com ja hem vist en la UF2, l\u0026rsquo;abstracció permet que qualsevol objecte el poguem reutilitzar en qualsevol situació. Per exemple, l\u0026rsquo;objecte cotxe vist anteriorment el podem fer servir en una aplicació de carreres però també per a una altra de mobilitat sostenible. El que tenen en comú és que identifiquem el mateix objecte en ambdues aplicacions(característiques i comportament).\nEncapsulament Es refereix a l\u0026rsquo;ocultació d\u0026rsquo;informació de forma que les dades internes d\u0026rsquo;un objecte són ocultes al món exterior, tal sols sabem què podem fer amb ell.\n Per exemple, quan escrivim per pantalla amb el mètode “sc.nextInt()”, sols sabem que ens retorna un enter però no sabem com és la implementació d\u0026rsquo;aquest mètode per dins, ni tampoc coneixem les seves variables internes.\nModularitat es refereix a la forma en que els elements es POO es troben organitzats en mòduls (paquets en Java) facilitant l\u0026rsquo;encapsulació i abstracció de la informació.\n Jerarquia S\u0026rsquo;ordenen els objectes de forma que s\u0026rsquo;estableixen relacions entre ells. Serveix per especificar aquelles característiques d\u0026rsquo;un objecte necessàries per la nostra aplicació.\n La jerarquia s\u0026rsquo;estableix mitjançant herència. Per exemple, podem definir objectes vehicle (amb matrícula, cavalls, etc..) i també objectes camions que hereten les característiques de vehicle i n\u0026rsquo;afegeixen d\u0026rsquo;altres (pes màxim, etc\u0026hellip;).\nPolimorfisme Defineix la possibilitat de tenir mètodes iguals però amb implementacions diferents segons de l\u0026rsquo;objecte que la faci servir.\n Un bon exemple de polimorfisme és l\u0026rsquo;operador +. Si l\u0026rsquo;apliquem a dos enters ens retorna la suma d\u0026rsquo;aquests, mentre que si l\u0026rsquo;apliquem a dos strings ens els concatena, per tant, donat el mateix operador, el comportament és diferent, és un element sobrecarregat i que adopta diferent funció depenent dels tipus que el rodegen. En POO passa el mateix, podem tenir un mètode que faci una funció diferent depenent de quin objecte l\u0026rsquo;implementa.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arraybidimensional/",
	"title": "Arrays Bidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays bidimensional: és una estructura d\u0026rsquo;array de dues dimensions. També s\u0026rsquo;entén com un vector de vectors. Es coneix amb el nom de matriu. És una col·lecció d\u0026rsquo;elements del mateix tipus disposats en dues dimensions.\n En aquest cas al tenir dues dimensions en forma de taula, la primera dimensió ens indica les files i la segona les columnes.\nDeclaració A l\u0026rsquo;igual que amb els arrays unidimensionals existeix la part de declarar una referència a la matriu i tot seguit quan cridem el new reservem en memòria l\u0026rsquo;espai on allotjar la informació.\nEn l\u0026rsquo;exemple següent creem una matriu d\u0026rsquo;enters que l\u0026rsquo;anomenem balances de 11 x 6 posicions guardem en memòria 66 enters de forma consecutiva i ordenats per files i columnes.\nPer tal d\u0026rsquo;accedir a un element cal indicar ara dos índexs, un per les files i un per les columnes, si per exemple volgués accedir a l\u0026rsquo;element situat a la 4 fila i 5a columna ho faríem amb balances[3][4]\nint[][] balances = new int[11][6]; int valor = balances[3][4];  Una altra forma de declarar una matriu és amb els valors directament igual com ja havíem vist en l\u0026rsquo;array unidimensional. Per exemple, la següent matriu conté 3 files i 2 columnes:\nint[][] matriu = {13,25},{34,78},{0,-3}};  S\u0026rsquo;observen 3 files i cadascuna conté els valors entre {}, les files entre sí estan separades per una coma.\nLongitud Al igual que els vectors les matrius també poden fer ús de l\u0026rsquo;atribut length. El que passa que si provem d\u0026rsquo;imprimir matriu.length observarem que mostra el total de files que conté la matriu. Java organitza la informació com un vector de vectors, així que si volem saber el length d\u0026rsquo;una columna cal que fem el següent matriu[i].length.\nFuncionalitat    Funcionalitat Sintaxi Exemples     Declaració d\u0026rsquo;un array 2D tipus[][] nom; int[][] matriu1; double[][] matriu2;   Creació d\u0026rsquo;un array de n files i m columnes nom = new tipus[n][m]; matriu1 = new int [3][2]; matriu2 = new double[5][5];   Declaració d\u0026rsquo;un array 2D inicialitzat tipus[][] nom ={{elem01,\u0026hellip;,elem0n},{elem11,\u0026hellip;,elem1n},\u0026hellip;,{elemm1,\u0026hellip;,elemmn}} int[][] matriu1={{13,25},{34,78},{0,-3}};   Accés a l\u0026rsquo;element de la fila i i columna j nom[i][j] int a = matriu1[1][0];\ndouble m = matriu2[5][8];    Recorregut Per fer un recorregut d\u0026rsquo;un array bidimensional o matriu utilitzarem 2 bucles anidats. Això ens permetrà tenir dos índexos, un per les files i un per les columnes. Per exemple:\nint rows = 10; int cols = 10; int[][] myArray = new int[rows][cols]; for (int i = 0; i \u0026lt; rows; i++){ for (int j = 0; j \u0026lt; cols; j++){ myArray[i][j] = 0; } }  Cerca De la mateixa manera que treballàvem la cerca d\u0026rsquo;un element dins un vector, en les matrius funciona igual, només que ara toca realitzar la cerca en dos bucles anidats. En aquest cas, quan es troba l\u0026rsquo;element (si es troba) cal sortir dels dos bucles.\nEn el següent exemple busquem el 0 dins una matriu de nombres aleatoris:\nboolean trobat=false; int matriu[][] = new int[10][12]; //Introduim valors aleatoris for (int i = 0; i \u0026lt; matriu.length; i++){ for(int j = 0; j \u0026lt; matriu[i].length; j++){ matriu[i][j] = (int) (Math.random() * 100); } } for (int i = 0; i \u0026lt; matriu.length \u0026amp;\u0026amp; !trobat; i++){ for(int j = 0; j \u0026lt; matriu[i].length \u0026amp;\u0026amp; !trobat; j++){ if( matriu[i][j]==0) trobat=true; } } String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Exemple Busquem l\u0026rsquo;element màxim i mínim d\u0026rsquo;una matriu:\nint max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; //RECORREM FILES for(int i=0; i\u0026lt;matriu.length;i++) { //RECORREM COLUMNES for (int j = 0; j \u0026lt; matriu[i].length; j++) { //BUSQUEM ELEMENT MES GRAN i MES PETIT if(matriu[i][j] \u0026gt; max) max = matriu[i][j]; if(matriu[i][j] \u0026lt; min) min = matriu[i][j]; } } System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;MAX: \u0026quot;+max); System.out.println(\u0026quot;MIN: \u0026quot;+min);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/metodologiatopdown/",
	"title": "Metodologia Top Down",
	"tags": [],
	"description": "",
	"content": "Metodologia Top Down: L\u0026rsquo;aplicació de la programació funcional en el desenvolupament d\u0026rsquo;un programa, dóna lloc a 2 tipus de fluxos de disseny oposats:\n  Disseny Top-Down: consisteix a resoldre un problema complex dividint successivament en parts cada vegada més elementals fins que siguin fàcilment abordables per separat. Normalment s\u0026rsquo;aplica a la fase de disseny.\n  Disseny Bottom-Up: consisteix en partir de blocs (funions) elementals i anar unint-los per aconseguir resoldre un problema. Normalment s\u0026rsquo;aplica a la fase d\u0026rsquo;implementació.\n  Entre els múltiples avantatges de la programació funcional, es poden citar:\n Afavoreix la reutilització del codi. Permet una completa divisió de tasques entre els programadors. Facilita el manteniment i l\u0026rsquo;escalabilitat dels programes. Facilita la depuració i la verificació. Es complementa perfectament amb la programació estructurada. de fet normalment s\u0026rsquo;utilitzen juntes. Facilita el disseny descendent (top-down) i la filosofia divideix i guanyaràs, disminuint la complexitat dels programes. Millora la productivitat.  Exemple3: Programa amb diferents funcionalitats\nimport java.util.Arrays; import java.util.Scanner; public class Activitats { //Métode que retorna el màxim de 2 nombres. Retorna num1 si són iguals public static int maxim (int num1, int num2){ if(num1\u0026gt;=num2) return num1; else return num2; } //Métode que retorna el mínim de 2 nombres. Retorna num2 si són iguals public static int min (int num1, int num2){ if(num1\u0026gt;=num2)return num2; else return num1; } //Métode que donats 3 nombres, retorna una llista ordenada ascendent public static int[] ordena (int num1, int num2, int num3){ int[] llista = {num1,num2,num3}; Arrays.sort(llista); return llista;\t} //Métode que retorna el màxim de 3 nombres. public static int maxim3 (int num1, int num2, int num3){ int [] llista = ordena(num1, num2, num3); return llista[2]; } //Métode que retorna el mínim de 3 nombres. public static int min3 (int num1, int num2,int num3){ int [] llista = ordena(num1, num2, num3); return llista[0]; } //Métode que retorna el valor màxim d'una matriu. public static int minimMatriu (int[][] mat){ int files = mat.length; int columnes = mat[0].length; int maxim = 0; for(int i=0; i\u0026lt;files;i++){ for(int j=0; j\u0026lt;columnes;j++){ if(mat[i][j] \u0026gt; maxim)maxim = mat[i][j]; //maxim = maxim(maxim, mat[i][j]); } } return maxim; } //Métode que permet crear una matriu amb nombres aleatoris public static int[][] creaMatriu (){ int files = 3; int columnes = 3; int[][] matriu = new int[files][columnes]; for (int i = 0; i \u0026lt;files ; i++) { System.out.println(\u0026quot;\u0026quot;); for (int j = 0; j \u0026lt; columnes; j++) { matriu[i][j] = (int)(Math.random()*100); System.out.print(matriu[i][j] + \u0026quot; \u0026quot;); } } System.out.println(\u0026quot;\\n\u0026quot;); return matriu; } public static void main (String[] args){ Scanner sc = new Scanner(System.in); int opcio = 9; int num1, num2, num3; while(opcio!=0){ System.out.println(\u0026quot;\\n\\n\\n---Tria una opció---\\n\u0026quot;); System.out.println(\u0026quot;1. Màxim de dos nombres\u0026quot;); System.out.println(\u0026quot;2. Mínim de dos nombres\u0026quot;); System.out.println(\u0026quot;3. Màxim de tres nombres\u0026quot;); System.out.println(\u0026quot;4. Mínim de tres nombres\u0026quot;); System.out.println(\u0026quot;5. Ordena de forma ascendent tres nombres\u0026quot;); System.out.println(\u0026quot;6. Màxim valor d'una matriu\u0026quot;); System.out.println(\u0026quot;0. Sortir\\n\u0026quot;); System.out.println(\u0026quot;---Tria una opció---\\n\u0026quot;); opcio = sc.nextInt(); switch(opcio){ case 1: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;El màxim és: \u0026quot;+ maxim(num1,num2)); break; case 2: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;El mínim és: \u0026quot;+ min(num1,num2)); break; case 3: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix tercer valor\u0026quot;); num3 = sc.nextInt(); System.out.println(\u0026quot;El màxim és: \u0026quot;+ maxim3(num1,num2, num3)); break; case 4: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix tercer valor\u0026quot;); num3 = sc.nextInt(); System.out.println(\u0026quot;El mínim és: \u0026quot;+ min3(num1,num2, num3)); break; case 5: System.out.println(\u0026quot;Introdueix primer valor\u0026quot;); num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix segon valor\u0026quot;); num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix tercer valor\u0026quot;); num3 = sc.nextInt(); int[] llista = ordena(num1,num2,num3); System.out.print(\u0026quot;L'ordre ascendent dels tres valors és:\u0026quot;); for(int i=0; i\u0026lt;llista.length; i++){ System.out.print(llista[i]+\u0026quot; \u0026quot;);\t} break; case 6: System.out.println(\u0026quot;Aquesta és la matriu:\u0026quot;); int maxim = minimMatriu(creaMatriu()); System.out.println(\u0026quot;El màxim valor de la matriu és: \u0026quot;+ maxim); break; case 0: System.out.println(\u0026quot;Programa finalitzat\u0026quot;); break; } } sc.close(); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/sequencial/",
	"title": "Estructura seqüencial",
	"tags": [],
	"description": "",
	"content": "Estructura seqüencial En l\u0026rsquo;estructura seqüencial permet descomposar un problema en instruccions que s\u0026rsquo;executaran de la primera a la última seguint un ordre de forma incondicional.\n L' assignació consisteix en donar un valor a una variable. \u0026ldquo;Guardar\u0026rdquo; una informació en una variable, que segurament serà tractada i/o consultada més endavant.\n    Codi Diagrama de flux     Acció1;\nAcció2;\nAcció3;\nAcció4;     Estructura bàsica L\u0026rsquo;estructura bàsica de qualsevol programa en Java anirà dins una \u0026ldquo;classe\u0026rdquo; amb un fitxer .java, amb la següent plantilla:\npublic class Main { public static void main(String[] args) { } }  Java executarà tot el que trobi dins les claus del main anterior.\nComentaris Tot el que es posa entre comentaris serveix per documentar el codi en cas que sigui necessari i Java ho interpreta com a comentaris i no ho executa com si fossin instruccions. Existeixen comentaris per:\n Una fila. En aquest cas utilitzarem \u0026ldquo;// Comentari\u0026rdquo; Més d\u0026rsquo;una fila, el comentari anirà entre \u0026ldquo;/* Comentari vàries línies */\u0026rdquo;  public class Main { public static void main(String[] args) { //Comentari d'una sola línia /* Comentari de més d'una línia */ } }  Inputs Per tal d\u0026rsquo;introduir valors al nostre programa (inputs), inicialment, farem servir la classe Scanner, cal declarar-la a dalt del programa i crear un objecte Scanner, per exemple li direm sc. Aquest objecte ens permetrà introduir informació pel teclat.\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enter32bits = sc.nextInt(); long enter64bits = sc.nextLong(); float decimal = sc.nextFloat(); double decimalGran = sc.nextDouble(); boolean boolea = sc.nextBoolean(); String cadenaCaracters = sc.next(); String cadenaCaractersFinalLinia = sc.nextLine(); } }  Outputs Per tal de treure valors per la línia de comandes (outputs) el que farem serà usar System.out.print i si volem un salt de línia System.out.println\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Pots escriure el teu nom per línia de comandes?\u0026quot;); String nom = sc.nextLine(); System.out.print(\u0026quot;Hola! \u0026quot;); System.out.print(\u0026quot;El meu nom és \u0026quot; + nom); } }  Exemples  Llegeix dos nombres reals i escriu la seva suma, resta, producte i quocient.  float operand1 = sc.nextFloat(); float operand2 = sc.nextFloat(); float suma = operand1 + operand2; float resta = operand1 - operand2; float multiplicacio = operand1 * operand2; float divisio = operand1 / operand2; float modul = operand1 % operand2;  Llegeix el preu d\u0026rsquo;un producte, l\u0026rsquo;IVA (en %) i el descompte (en %) a aplicar. Escriu el preu final del producte.  float preu = sc.nextFloat(); int iva = sc.nextInt(); int descompte = sc.nextInt(); float preuAmbIva = preu + preu * iva / 100; float preuAmbIvaIDescompte = preuAmbIva - preuAmbIva * descompte / 100; System.out.println(\u0026quot;Preu final:\u0026quot; + preuAmbIvaIDescompte);  Calcula l\u0026rsquo;àrea lateral i el volum d\u0026rsquo;un cilindre recte, introduint per teclat els valors del radi i l\u0026rsquo;altura. V =pi⋅r2⋅h AL=2⋅pi⋅r⋅h  float radi = sc.nextFloat(); float altura = sc.nextFloat(); double areaLateral = 2 * Math.PI * radi * altura; double volum = Math.PI * Math.pow(radi,2) * altura; System.out.println(\u0026quot;Area lateral:\u0026quot; + areaLateral + \u0026quot; Volum:\u0026quot; + volum);  Llegeix un nombre enter no negatiu i un altre nombre enter no negatiu que indica la posició de les seves xifres i escriu la xifra que ocupa aquesta posició. Les unitats estan a la posició 1, les desenes a la posició 2, etc.  int nombre = sc.nextInt(); int posicio = sc.nextInt(); double potencia = Math.pow(10,posicio-1); double nombreRetallat = nombre / potencia; int nombreBuscat = (int)nombreRetallat % 10; System.out.println(\u0026quot;el dígit \u0026quot; +posicio+ \u0026quot; del nombre \u0026quot; + nombre + \u0026quot; és: \u0026quot;+ nombreBuscat);  Llegeix un nombre enter de segons i escriu el nombre d’hores, minuts i segons equivalents en format h:m:s.  int segonsTotals = sc.nextInt(); int hores = segonsTotals / 3600; int segonsRestants = segonsTotals % 3600; int minuts = segonsRestants / 60; int segons = segonsRestants % 60; System.out.println(hores + \u0026quot;:\u0026quot; + minuts + \u0026quot;:\u0026quot; + segons);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/implementaci%C3%B3-en-poo/",
	"title": "Implementació bàsica de POO",
	"tags": [],
	"description": "",
	"content": "Definicions          Classe\n Una classe és la definició d\u0026rsquo;un objecte real.\nÉs l\u0026rsquo;element que descriu els components d\u0026rsquo;un objecte de manera general. En ell hi queden especificats quines característiques té l\u0026rsquo;objecte (atributs) i quines accions pot realitzar (mètodes). És la plantilla que ens servirà per crear objectes.   Objecte\n Un objecte és una instància d\u0026rsquo;una classe. Diem que hem creat o instanciat un objecte quan donem valors i fem servir els components definits a la classe.   Atribut\n Un atribut és una característica concreta d\u0026rsquo;un objecte. Es defineix com les variables del programes estructurats, és a dir, definint tipus de dades i nom.   Mètode\n Els mètodes defineixen quines funcionalitats o accions pot realitzar la classe. Reflecteixen les operacions que es poden fer sobre els atributs.    Exemple Un exemple podria ser una classe jugadorFutbol que tingués:\n atributs: nom, edat, pes, posició, nacionalitat, etc. mètodes: marcaGols, esLesiona, protestaArbitre, canviaPosicio, etc.  I amb aquesta classe jugadorFutbol definida podríem tenir diferents jugadors, per tant hi instanciaríem diferents objectes:\n Leo Messi, 33 anys, 65kg, davanter, argentí. Andres Iniesta, 36 anys, 67kg, centrecampista, espanyol.   Intanciem la primera classe Definirem la classe Persona i un mètode que ens faci saludar aquesta persona mostrant un missatge per pantalla.\npackage exemple1.versio1; public class Persona { public void saluda() { System.out.println(\u0026quot;Hola, sóc una persona\u0026quot;); } }  Observacions:\n A la línia 1 tenim la declaració del package. Per conveni, el nom dels packages s\u0026rsquo;ha d\u0026rsquo;escriure en minúscules. A la línia 3 tenim la declaració de la classe. La paraula reservada public serveix per especificar l’àmbit (o accés o visibilitat) de la classe. De moment, totes les classes seran públiques. Fixeu-vos que la primera lletra és majúscula i la resta del nom de la classe en minúscula. A la línia 5 tenim la declaració del mètode. És un mètode públic això ens indica que té visibilitat en altres classes i per tant pot ser cridat des d\u0026rsquo;elles. També s\u0026rsquo;observa que la signatura del mètode no porta la paraula static, això voldrà dir que si es vol cridar aquest mètode necessitarem abans crear una instància de Persona.  Recordem que la JVM busca en la classe que executem un mètode main com a punt d\u0026rsquo;inici de l\u0026rsquo;execució, en la classe Persona no hi és, si proveu d\u0026rsquo;executar-lo el compilador de Java retorna un error conforme no ha trobat un mètode main. Cal doncs que definim aquest mètode main ja sigui a la pròpia classe Persona o una altra classe. En l\u0026rsquo;exemple següent s\u0026rsquo;ha generat una classe nova per testejar Persona capaç de crear-ne una instància i cridar al mètode saluda.\npackage exemple1.versio1; public class PersonaTest { public static void main(String[] args) { Persona persona = new Persona(); persona.saluda(); } }  Observacions:\n A diferència del mètode saluda, el mètode main de PersonaTest és static, això vol dir que no necessita de la instància de la classe PersonaTest per ser cridat. En la línia 6 es crea un objecte nou de la classe Persona, aquest objecte és instanciat en una variable que s\u0026rsquo;anomena persona. El tipus de persona és Persona que ara mateix no té cap atribut i només conté un mètode capaç de saludar. El mètode Persona() que es crida quan s\u0026rsquo;instancia l\u0026rsquo;objecte s\u0026rsquo;anomena constructor i el veurem més endavant. A continuació, com que ja tenim un objecte instanciat de Persona, ja podem cridar tots aquells mètodes no-statics que tingui aquesta persona, com per exemple saluda.  Crida amb paràmetres Efectuem un petit canvi a l\u0026rsquo;activitat anterior i definim el mètode saluda amb un paràmetre d\u0026rsquo;entrada que simbolitzi el nom de la persona i que demanarem per teclat en PersonaTest. Les dues classes quedarien de la següent manera:\npackage exemple1.versio2; public class Persona { public void saluda(String nom) { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom); } }  package exemple1.versio2; import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona que saluda: \u0026quot;); String nomPersona = sc.nextLine(); Persona persona = new Persona(); persona.saluda(nomPersona); } }  Sobre les classes utilitzades en PersonaTest:\n Usem Scanner, per això l\u0026rsquo;importem, ja que sinó no el tindríem visible. També estem cridant String i System, les dues pertanyents al paquet java.lang. Java ja les ha incorporades implícitament per això les podem usar sense declarar-ne l\u0026rsquo;import. Finalment estem creant objectes de la classe Persona. Com que PersonaTest i Persona es troben en el mateix directori, que correspon al mateix package, ja és visible i no cal importar-la tampoc.  Variables d\u0026rsquo;instància (atributs de classe) Com ja hem vist en la UF2 les variables locals es declaren dins un àmbit de visibilitat, ja sigui dins un mètode o d\u0026rsquo;una determinada estructura de control (while/for), estan actives dins aquest àmbit, després desapareixen.\nDins de cada classe hi ha les anomenades variables d\u0026rsquo;instància o atributs de la classe. Aquests poden ser instanciats en la creació de l\u0026rsquo;objecte i estan actius durant la vida d\u0026rsquo;aquest objecte. Cada objecte de la classe manté una còpia d\u0026rsquo;aquests camps amb els seus respectius valors.\nGetters \u0026amp; Setters En la definició de qualsevol classe existeixen uns mètodes particulars que ens ajuden a interactuar amb els atributs dins la classe:\n Getters: són mètodes que ens permeten accedir al contingut d\u0026rsquo;una variable d\u0026rsquo;instància. Setters: són mètodes que ens permeten modificar el contingut d\u0026rsquo;una variable d\u0026rsquo;instància.  Les classes en Java estan estructurades sota el principi d\u0026rsquo;encapsulació. Declarant les variables d\u0026rsquo;instància com a privades (podríem haver-les fet públiques) encapsulem (amaguem) la variable. Així, aquesta variable sols es pot modificar des del nostre mètode setNomVariable (setter). Evitem modificacions accidentals des de qualsevol lloc del programa.\nAixí doncs la manera de minimitzar errors i a la vegada d\u0026rsquo;ocultar el tipus de les variables (la qual cosa ens dóna flexibilitat si en un futur existeixen modificacions en l\u0026rsquo;estructura de dades de la pròpia classe) és creant els atributs de classe com a privats i implementar els seus mètodes get i set públics. L\u0026rsquo;accés des de fora la classe a aquesta variable serà a través dels mètodes. Així per a cada atribut de classe implementarem un getter i un setter.\nReprenem l\u0026rsquo;exemple anterior i afegim dues variables de classe a Persona: nom i edat, afegim degudament els seus getters \u0026amp; setters i en comprovem el funcionament en el PersonaTest creant dos exemples de Persona diferents.\npackage exemple1.versio2; public class Persona { private String nom; private int edat; public String getNom(){ return nom; } public int getEdat(){ return edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; } public void saluda() { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom + \u0026quot; i tinc \u0026quot; + anys + \u0026quot;anys\u0026quot;); } }  package exemple1.versio2; import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String nomPersona1 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String edat1 = sc.nextInt(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String nomPersona2 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String edat2 = sc.nextInt(); sc.close(); Persona persona1 = new Persona(); Persona persona2 = new Persona(); persona1.setNom(nomPersona1); persona1.setEdat(edat1); persona2.setNom(nomPersona2); persona2.setEdat(edat2); System.out.println(\u0026quot;El nom de la persona1 es: \u0026quot;+persona1.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona1.getEdat()); System.out.println(\u0026quot;El nom de la persona2 es: \u0026quot;+persona2.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona2.getEdat()); persona1.saluda(); persona2.saluda(); } }  Observacions:\n El getNom i getEdat retornen el valor de la variable d\u0026rsquo;instància d\u0026rsquo;un objecte determinat. Per la seva banda setNom i SetEdat modifiquen el contingut de la variable d\u0026rsquo;instància pertinent. Fixem-nos que saluda() ja no té com a paràmetre d\u0026rsquo;entrada el nom ja que l\u0026rsquo;agafa de la pròpia classe. L\u0026rsquo;atribut de classe és privat i per tant no és accessible des de fora la classe (s\u0026rsquo;accedeix mitjançant el getNom) però sí que ho és desde dins la pròpia classe, en saluda().  Constructors "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/2metodologiessoftware/",
	"title": "Metodologies de Software",
	"tags": [],
	"description": "",
	"content": "El programari no es fabrica com qualsevol altre producte clàssic, sinó que es desenvolupa seguint una sèrie d\u0026rsquo;etapes. D\u0026rsquo;aquí sorgeix el concepte d\u0026rsquo;enginyeria de programari, que consisteix en l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria per obtenir desenvolupaments que optimitzin l\u0026rsquo;efectivitat i els costos.\nEls processos d\u0026rsquo;enginyeria de programari comprenen per tant, diverses etapes, que constitueixen el que s\u0026rsquo;anomena el cicle de vida del programari. Per dur a terme aquestes fases és necessari partir d\u0026rsquo;un enfocament amb el qual iniciar el procés de enginyeria. Un cop iniciat, s\u0026rsquo;ha d\u0026rsquo;utilitzar una metodologia amb unes eines que permetin completar les diferents etapes de l\u0026rsquo;cicle.\nEn l\u0026rsquo;actualitat, l\u0026rsquo;enfocament més estandaritzat és l\u0026rsquo;orientació a objectes. la creació el 1998 de l\u0026rsquo;estàndard UML (Unified Modeling Language) per a la definició de problemes i el desenvolupament de llenguatges de programació com Java o C ++ pel desenvolupament i integració de solucions, són els principals causants que aquest enfocament s\u0026rsquo;estigui consolidant.\nQuè és l\u0026rsquo;enginyeria del software? De l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria a l\u0026rsquo;programari sorgeixen els processos de desenvolupament de programari. Aquest procés es defineix com \u0026ldquo;aquell en què les necessitats de l\u0026rsquo;usuari són traduïdes en requisits de programari, aquests requisits transformats en disseny, i el disseny implementat en codi, que és provat, documentat i certificat pel seu ús operatiu\u0026rdquo; [Jacobson, 1998].\n Característiques del software  S\u0026rsquo;ha invertit la demanda i el preu respecte al HW. El Software es un producte lògic que es desenvolupa, no es construeix com la resta de productes. La gestió de costos es centra en l\u0026rsquo;enginyeria, amb la qual difereix d\u0026rsquo;altres projectes d\u0026rsquo;enginyeria. El Software no es deteriora amb el temps, però sí és necessari un manteniment. La reutilització de productes software creixent. Existeixen restriccions de recursos en el desenvolupament de software, de forma que és necessari assegurar-ne la qualitat per obtenir un software: documentat, fiable, eficient i amb una bona interfície gràfica.  Cicles de desenvolupament del software. Tipus de cicles Anomenem cicle de vida del software al temps necessari per la producció d\u0026rsquo;un projecte software desde la recopilació de requisits fins a l\u0026rsquo;entrega final del producte. El cicle de vida inclou una sèrie d\u0026rsquo;etapes que pot canviar en funció del model, la metodologia i l\u0026rsquo;autor. Existeixen varis tipus de cicles de vida que passem a comentar.\nModel en cascada o lineal Es tracta d\u0026rsquo;un model molt genèric i que estableix una sèrie de fases o etapes, que han de ser seguides en un ordre seqüencial, ja que cada fase genera entrades i documentació per a la següent fase. Les fases d\u0026rsquo;un cicle de vida en cascada segueixen el següent esquema:\nLes característiques del model són:\n Cada etapa s\u0026rsquo;inicia un cop acabada l\u0026rsquo;anterior. Ajuda a la planificació temporal i el càlcul de costos, a causa de la seqüencialitat i estructura lògica de les etapes. Hi ha una realimentació en el manteniment.  Quant als inconvenients que s\u0026rsquo;han detectat, aquests són:\n Es tracta d\u0026rsquo;un model rígid, sense robustesa ni adaptabilitat als problemes a resoldre. Hi ha dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials, ja que aquests solen venir donats per persones alienes al coneixement del cicle de desenvolupament de programari. Els errors solen detectar-se molt tard, el que implica que el cost per solucionar l\u0026rsquo;error sigui molt més gran. El manteniment es realitza mitjançant petites actualitzacions o \u0026ldquo;pegats\u0026rdquo;. Torna a aplicar cadascuna de les fases del cicle al programari ja existent, sense crear un de nou.  Fases:\n Anàlisi de sistema: el sistema de programari forma part sobre un sistema major amb el qual es relaciona. S\u0026rsquo;analitza el sistema en el seu conjunt per treure objectius que han de ser abordables pel programari. Anàlisi de requisits: definint funcions a realitzar, dades, comportament, i interacció entre elements funcionals. Disseny: a partir de requisits dissenyem els components de programari, estructures de dades, mòduls, procediments, algoritmes i interfícies\u0026hellip; Codificació: a partir d\u0026rsquo;informació generada implementem sistema, codifiquem procediments en un llenguatge de programació. Prova: validem i verifiquem que els requisits establerts pel client es realitzen correctament. Manteniment: la producció de programari no finalitza amb el lliurament, ha de ser revisat i reajustat quan això sigui necessari.  Cicle de vida prototipat Aquest model tracta de solucionar problemes del model en cascada, en concret les dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials. El client sol definir els objectius generals del programari, però no acostuma a tenir en compte tots els requisits reals que ha de tenir una aplicació. Al mateix temps, el desenvolupador pot no arribar a entendre què vol el client. Per tal de solucionar això, un cicle basat en prototips pot ser un millor enfocament.\nLes característiques d\u0026rsquo;aquest model són:\n Client i desenvolupador defineixen una sèrie d\u0026rsquo;objectius globals, dels quals s\u0026rsquo;identifiquen els requisits, amb els quals es realitza un disseny ràpid, i amb aquest, la creació d\u0026rsquo;un prototip. El prototip és avaluat per l\u0026rsquo;usuari, qui pot veure les deficiències del prototip, a partir de les quals es redefineixen els requisits. Es van construint nous prototips, amb els quals el client pot anar polint els requisits de programari, al mateix temps que el desenvolupador pot comprendre millor el que ha de fer. Aquestes interaccions finalitzen quan el prototip satisfà les necessitats del client.  Inconvenients d\u0026rsquo;aquest tipus de cicle de vida:\n És un procés molt lent. Si es desitja generar un programari de qualitat no n\u0026rsquo;hi ha prou que un prototip sigui com l\u0026rsquo;anterior amb uns petits ajustos, sinó que es requereix crear el producte de nou. això succeeix fonamentalment amb els primers prototips de cada desenvolupament. El client veu cada prototip com una versió de programari final, sense prendre consciència que cada prototip únicament ajuda a aclarir els requisits, i per tant, és generat des del principi, per aconseguir una robustesa en el desenvolupament. Els primers prototips que es rebutgen suposen un cost addicional, ja que amb prou feines poden emprar-se per al mateix desenvolupament ni poden ser reutilitzats per a altres.  Cicles de vida evolutius El programari és un producte que va evolucionant per això els desenvolupadors necessiten un nou model de cicle de vida, que permeti que les funcionalitats del programari puguin anar canviant amb el temps. El model en cascada assumeix que es lliura un producte una vegada acabades totes les fases del procés, sense considerar possibles evolucions. Tampoc es té en compte l\u0026rsquo;evolució en el model de prototips, en que aquests es dissenyen per ajudar al client a comprendre els requisits, però no per disposar de versions a millorar.\nLa solució la presenten els cicles de vida evolutius, que amb una estructura iterativa, permeten als enginyers desenvolupar versions cada vegada més completes del programari.\nCicle de vida incremental Aquest model combina el model lineal seqüencial amb la filosofia de creació de prototips. Per a això, va generant seqüències lineals de desenvolupament al mateix temps que cada seqüència lineal produeix un \u0026ldquo;increment\u0026rdquo; en el programari, el qual va progressant.\nEl primer increment sol ser un desenvolupament que tan sols incorpora els requisits i funcionalitats més bàsiques. Les versions successives consisteixen en modificacions de cada versió anterior, a la qual s\u0026rsquo;afegeixen noves funcionalitats i modificacions, es van lliurant les diferents versions o increments d\u0026rsquo;acord es van acabant. A diferència del prototipat, cada increment aprofita la versió anterior, i és una versió del producte final a falta d\u0026rsquo;algunes funcionalitats. L\u0026rsquo;esquema que segueix aquest tipus de cicle de vida és el següent:\nAquest tipus de cicle de vida és molt avantatjós des del punt de vista de costos temporals i flexibilitat en la planificació del projecte. Els primers increments no requereixen molt personal, mentre que per als següents es poden anar afegint més o menys funcionalitats segons la quantitat de personal de què es disposi o bé segons que es disposi o no de determinats recursos.\nCicle de vida en espiral És un procés evolutiu que combina la interactivitat del prototipat amb els aspectes sistemàtics del model en cascada. Cada volta de l\u0026rsquo;espiral consta de les mateixes fases que el cicle en cascada:\n Planificació: determina objectius, requisits i restriccions de el projecte. Anàlisi de risc: analitza alternatives, identifica i resol riscos Enginyeria: desenvolupament del producte. Avaluació de client: es valoren els resultats obtinguts.  Segueix les directrius del model PDCA (Plan Develop Check Act) de Demming, i segueix la filosofia del moviment Agile resumit en el Manifiesto Agile, una de les seves implementacions més conegudes és SCRUM.\nEl principal avantatge del model en espiral és que és el més adequat per projectes amb riscs. Com el programari va evolucionant, el desenvolupador i client poden anar comprenent cada vegada millor els riscos conforme es va passant per diferents nivells d\u0026rsquo;evolució. El mecanisme utilitzat per minimitzar riscos es basa en poder incorporar el prototipat en qualsevol etapa d\u0026rsquo;evolució del producte.\nDavant d\u0026rsquo;aquest avantatge, es troba l\u0026rsquo;inconvenient de requerir una alta habilitat en els enginyers per avaluar riscos. L\u0026rsquo;èxit depèn molt d\u0026rsquo;ella, ja que un risc no descobert pot donar lloc a problemes.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2tipusdades/",
	"title": "Tipus de dades i operadors",
	"tags": [],
	"description": "",
	"content": "Tipus de dades En el llenguatge Java incorpora tipus de dades diferents d\u0026rsquo;acord amb la seva naturalesa: no és el mateix un nombre, que un text o un valor verdader/fals per exemple. Aquests tipus de dades els classifiquem en tipus de dades primitius i tipus de dades de classe:\n Primitius: són les dades simples que coneixem com a nombres, text, etc. i que ens defineix de forma primitiva el llenguatge. Classe: són tipus de dades més complexos que es creen a partir dels mateixos tipus de classe o de tipus primitius.  Tipus Primitius En Java podem diferenciar els següents tipus de dades primitius:\n Numèrics:  Enters: byte, short, int i long Reals: float, double   Textuals:  chars   Lògics:  boolean    La diferència entre els nombres enters i reals és que els nombres enters no contenen decimals (ex: 2 | 3 | 25) i els nombres reals reserven espai pels decimals (ex: 4,45 | 6,82 | 3,141592). Tot seguit us mostro una taula de rangs:\n   Nom Longitud Rangs de valors     byte 8 bits De -27 a 27 -1   short 16 bits De -215 a 215 -1   int 32 bits De -231 a 231 -1   long 64 bits De -263 a 263 -1   float 32 bits    double 64 bits    char 16 bits     Els valors que admet una variable de tipus booleà és: true o false. Un valor booleà és molt comú en el camp informàtic on moltes vegades cal prendre una decisió que es pot avaluar en \u0026ldquo;veritat\u0026rdquo; o \u0026ldquo;fals\u0026rdquo;.\nExemple d\u0026rsquo;assignació de valors Declarem i assignem un valor a les variables:\nboolean valorBoolea = true; int valorEnter = 50; float valorDecimal = 50.3; char lletra =’v’;  En aquest cas primer declarem les variables i després li assignem un valor:\nboolean valorBoolea; valorBoolea = true; int valorEnter; valorEnter = 50; float valorDecimal; valorDecimal = 50.3; char lletra; lletra =’v’;  Operadors Operadors aritmètics Són les operacions que avaluen una operació i retornen un resultat numèric.\n   Operació Operador     Suma +   Resta -   Multiplicació *   Divisió /   Mòdul %    Altres operadors\nExisteixen altres formes que simplifiquen l\u0026rsquo;escriptura alhora de fer operacions senzilles. Seria el cas dels comptadors. D\u0026rsquo;aquesta manera existeixen expressions com:\nint comptador = 0; comptador = comptador + 1; //es pot fer de forma més simple int comptador = 0; comtpador++; //Les dues expressions següents també són equivalents i s'aplica a tots els operadors aritmètics: int comptador = 0; comptador = comptador + 10; comptador =+ 10; comptador = comptador - 10; comptador =- 10; comptador = comptador * 10; comptador =* 10; comptador = comptador / 10; comptador =/ 10;  Recordem l\u0026rsquo;ordre de prioritat en les operacions aritmètiques:\n 1r Parèntesi () 2n Multiplicacions, divisioons i mòdul * / % 3r Sumes i restes + -  Operadors lògics i relacionals Són les operacions que avaluen una expressió i retornen un resultat booleà (true o false).\nOperadors lògics\n   A B !A A \u0026amp;\u0026amp; B A || B     true true false true true   true false false false true   false true true false true   false false true false false    Operadors relacionals\nAquests operadors els podem aplicar a diferents tipus de dades i s\u0026rsquo;avalua l\u0026rsquo;expressió a un booleà (true o false).\n   Operació Signe Exemple1 Resultat1 Exemple2 Resultat2     Major \u0026gt; 5 \u0026gt; 3 true 3 \u0026gt; 5 false   Major o igual \u0026gt;= 5 \u0026gt;= 5 true 5 \u0026gt;= 3 true   Menor \u0026lt; 5 \u0026lt; 5 false 3 \u0026lt; 2 false   Menor o igual \u0026lt;= 6 \u0026lt;= 5 false 4 \u0026lt;= 5 true   Igual == \u0026lsquo;c\u0026rsquo; == \u0026rsquo;d' false 5 == 3 false   No igual != \u0026lsquo;c\u0026rsquo; != \u0026rsquo;d' true 5 != 5 false    Prioritat\nLa prioritat alhora d\u0026rsquo;avaluar expressions que contenen operadors aritmètics, relacionals i lògics és:\n 1r. Es realitzen els càlculs aritmètics. 2n. S\u0026rsquo;avaluen les operacions relacionals de \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 3r. S\u0026rsquo;avaluen les operacions relacionals de == != 4rt. S\u0026rsquo;avaluen les negacions lògiques ! 5è. S\u0026rsquo;avaluen les operacions de conjunció \u0026amp;\u0026amp; 6è. S\u0026rsquo;avaluen les operacions de disjunció ||  Les operacions anteriors s\u0026rsquo;avaluen sempre d\u0026rsquo;esquerra a dreta.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/3tipusllenguatges/",
	"title": "Tipus de Llenguatges",
	"tags": [],
	"description": "",
	"content": "Els llenguatges de programació es poden classificar a partir de diferents criteris\n Segons la proximitat al nucli. Segons el paradigma de programació. Segons la traducció a codi màquina. Segons la generació.  1. Segons la proximitat al nucli La proximitat al nucli queda determinat per saber en quin moment s\u0026rsquo;executa aquest llenguatge. Poden ser llenguatges d\u0026rsquo;alt nivell, dins el sistema de capes, molt allunyat del nucli, o llenguatges de baix nivell propers al nucli.\n Els llenguatges de programació es poden classificar segons la seva proximitat al llenguatge màquina:\n   Llenguatges de baix nivell     Llenguatge de programació pròxim al nucli de la màquina i que només entén la màquina.   Es composa per codi binari (símbols 0 i 1).   És el llenguatge més bàsic i també més difícil d\u0026rsquo;entendre pels humans ja que totes les instruccions són tires de 0s i 1s.   És un llenguatge molt lligat a l\u0026rsquo;arquitectura de la màquina.   S\u0026rsquo;utilitzen adreces de memòria per fer referència a les dades.   Les instruccions tenen un format rígid.       Llenguatges ensambladors     Separen les característiques del maquinari de la tasca de programació.   Es substitueixen els codis numèrics per representacions textuals equivalents a les instruccions màquina que representen.   Segueixen tenint una forta relació amb els llenguatges màquina però permeten utilitzar adreces simbòliques i incloure línies de comentaris.       Llenguatges d\u0026rsquo;alt nivell     Alliberen el programador de tasques tedioses i complexes que frenen la productivitat i l\u0026rsquo;eficiència.   Tenen un gran nivell d\u0026rsquo;abstracció que fa innecessari el coneixement de l\u0026rsquo;arquitectura de la màquina.   Les instruccions s\u0026rsquo;expressen per caràcters alfanumèrics; permeten definir variables; disposen d\u0026rsquo;instruccions molt ponents de tipus aritmètic, lògiques, tractament de caràcters, etc .; són fàcils de corregir i actualitzar i fàcils d\u0026rsquo;aprendre.   Per contra, no són tant conscients en quant a consum de recursos.    2. Segons el paradigma de programació Un paradigma de programació és un enfoc particular/filosofia pel disseny i construcció de codi. Depenent de cada context resulta més idoni utilitzar-ne un o altre\n A grans trets diferenciarem entre\n  Llenguatges imperatius: - Descriu la programació com una seqüència instruccions o ordres que canvien l\u0026rsquo;estat d\u0026rsquo;un programa. - Formen part d\u0026rsquo;aquest tipus molts llenguatges d\u0026rsquo;alt nivell i d\u0026rsquo;ús general: python, c, java, c++ etc. - Es fixen en el COM es desenvolupa el codi (com s\u0026rsquo;aconsegueix un objectiu pas a pas). - En aquest paradigma s\u0026rsquo;inclouen altres paradigmes com el modular, orientació a objectes, concurrent, etc.\n  Llenguatges declaratius: - Es fixen en QUÈ descriu (declara la solució), es basa en les propietats de la solució buscada. - No es coneix l\u0026rsquo;algorisme usat per trobar aquesta solució. - No es coneix el rendiment i/o eficiència del codi a priori - Molt útil en la resolució de problemes i situacions determinades. - En aquest paradigma s\u0026rsquo;inclouen els paradigmes funcional, lògic i no procedimental.\n  Com a subtipus dels anteriors destaquem:\n   Programació estructurada   Utilitza únicament seqüències, instruccions condicionals i instruccions repetitives. Es tracta en la UF1 de M03 Programació.\n    Programació modular   El programa es dissenya per parts(mòduls). Es tracta en la UF2 de M03 Programació.\n    Programació orientada a objectes   Programació basada en la comunicació i el pas de missatges entre objectes (estructures amb atributs i mètodes). Es tracta en la UF4 de M03 Programació.\n    Programació concurrent   Útil quan hem de realitzar diverses accions a la vegada i utilitzant recursos compartits. Es tracta en M09 Programació de serveis.\n    Programació funcional   Tot el codi es basa en funcions, des de l\u0026rsquo;expressió mínima a qualsevol estructura complexa. Exemple d\u0026rsquo;aquest paradigma és el llenguatge Lisp o Haskel.\n    Programació lògica   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog.\n \n3. Segons la traducció a codi màquina Els llenguatges de programació poden tenir diferents tractaments fins a ser executats, així diferenciem els llenguatges interpretats, compilats i els híbrids.\n Desde que un programa és escrit i és executat per la màquina hi ha un seguit de passos que cal tenir presents:\n Anàlisi (lèxic, sintàtic i semàntic) Traducció(generació i optimització de codi)  Depenent de com es realitza aquesta traducció tenim llenguatges compilats i interpretats:\n   Llenguatges compilats     Una vegada el codi és analitzat es genera el codi objecte d\u0026rsquo;acord amb les característiques del compilador del llenguatge. Depenent del tipus de compilador l\u0026rsquo;objecte pot ser directament executable o necessita altres passos previs com l\u0026rsquo;acoblament, l\u0026rsquo;enllaçat i la càrrega (Com per exemple el llenguatge C).   Per tal de flexibilitzar el codi, els compiladors treballen amb biblioteques de mòduls objecte. Per incloure-les en el codi màquina final s\u0026rsquo;ha d\u0026rsquo;usar un enllaçador que retorna un únic programa executable.   Els programes objecte s\u0026rsquo;executen molt més ràpidament que els interpretats ja que estan optimitzats per uns determinats recursos HW, però no permet transportar codi objecte entre diferents plataformes d\u0026rsquo;execució.   Exemples de llenguatges els traductors són compiladors són FORTRAN, COBOL, C, PASCAL, ADA \u0026hellip;       Llenguatges interpretats     En aquest cas es duu a la vegada el procés de traducció i el d\u0026rsquo;execució. La seva forma de treball és anar analitzant instruccions de codi del programa font, generant el codi màquina corresponent i executant.   Són més lents que els compilats, per contra, són fàcilment transportables entre diferents màquines, ja que és el propi programa font el que es mou.   Exemples de llenguatge interpretat són PROLOG, i SQL, Javascript, Python, etc.       Llenguatges híbrids     Aprofiten el millor d\u0026rsquo;ambdós mons com Java o Visual Studio .NET. Són capaços de compilar el codi a un llenguatge intermedi denominat bytecode en JAVA i MSI en .NET, que després són interpretats per una màquina virtual (MVJ o .NET Framework), així aconsegueixen una substancial millora en el rendiment i mantenen la característica de transportabilitat entre diferents plataformes    4. Segons la generació Depenent de quan es va crear el llenguatge s\u0026rsquo;emmarca en unes necessitats i usos concrets que han donat lloc a generacions. Són seqüencials en el temps.\n    Primera generació   Són els que corresponen als llenguatges ja vistos de baix nivell o llenguatges màquina.\n    Segona generació   Són aquells que pertanyen als llenguatges assembladors.\n    Tercera generació   A la tercera generació pertanyen aquells llenguatges estructurats que seguien un ordre alhora d\u0026rsquo;executar les instruccions. Llenguatges com C, pascal, cobol, etc.\n    Quarta generació   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog. Els llenguatges de quarta generació, són els més propers a la sintaxi de la llengua humana, i s\u0026rsquo;acostumen a utilitzar en les creacions de bases de dades o com a llenguatges de programació dels llenguatges o sistemes d\u0026rsquo;autor. Són llenguages no procedimentals com SQL que permeten definir quins seran els resultats finals sense necessitat de preocupar-se per saber com fer-ho.\n    Cinquena generació   Amb la incorporació i expansió dels llenguatges orientats a objectes i amb la generalització de l\u0026rsquo;ús de les GUI, és possible abarca problemes de major abstracció. Alguns exemples són Java, C++, etc. S\u0026rsquo;ha generalitzat tant els IDEs de desenvolupament com els CLIs per cada servei/llenguatge.\n \n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3algor%C3%ADsmia/",
	"title": "Algorísmia",
	"tags": [],
	"description": "",
	"content": "Què és un algorisme? Un algorisme és un mètode per resoldre un PROBLEMA, són un conjunt d\u0026rsquo;operacions finites i ordenades que s\u0026rsquo;han de seguir per a la resolució d\u0026rsquo;un problema.\n Característiques dels algorismes\nLes característiques bàsiques d\u0026rsquo;un algorisme són:\n Ordenat. Cada instrucció té una posició dins el conjunt. Precís. Cada instrucció és unívoca i obeeix a un objectiu. Definit. Si es segueix un algorisme dues vegades, s\u0026rsquo;ha d\u0026rsquo;obtenir el mateix resultat cada vegada. Finit. L\u0026rsquo;algorisme ha d\u0026rsquo;acabar en algun moment, per tant, tindrà un nombre finit de passos. Un bon disseny algorítmic contindrà tres parts: Entrada (Input), Procés (Tractament de la informació) i Sortida (Output).  Pseudocodi El pseudocodi és un llenguatge informal d’alt nivell que usa les convencions i l’estructura d’un llenguatge de programació, però que està orientat a ser entès pels humans.\n Diagrama de flux Un diagrama de flux de control consisteix en una subdivisió de passes seqüencials, d’acord amb les sentències i estructures de control d’un programa, que mostra els diferents camins que pot seguir un programa a l’hora d’executar les seves instruccions. Cada passa s’associa a una figura geomètrica específica.\n Complexitat ciclomàtica La Complexitat ciclomàtica (en anglès, Cyclomatic Complexity) és una mètrica de programari en enginyeria de programari que proporciona una mesura quantitativa de la complexitat lògica d\u0026rsquo;un programa. Consisteix en comptar el nombre de camins necessaris per tal d\u0026rsquo;anar de la primera a la última instrucció passant per tots els camins possibles i cobrint tots els casos.\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/desenvolupamentpoo/",
	"title": "Desenvolupament de POO",
	"tags": [],
	"description": "",
	"content": "Definició En el context de la programacio una llibreria es un conjunt de codi re-utilitzable, encapsulat d\u0026rsquo;alguna manera (paquets, classes, moduls, dll, \u0026hellip;) i documentat adequadament.\n En el cas de Java tenim llibreries de classes i les seves propietats. Per exemple podriem considerar la classe Math, que ens proporciona un conjunt de funcions matematiques, una llibreria en si mateixa. Ex:  int x = -15; int y = Math.abs(x);   Tambe tenim paquets com java.util que agrupen de forma organitzada un conjunt de classes amb unes funcionalitats comunes (utilitats). Veieu mes exemples de les llibreries del SDK a la última pagina del document. import java.util.Scanner;  import java.util.Scanner;  Llibreries de classes: paquets  Una llibreria de classes, o package (paquet) en Java, es un conjunt de classes vinculades entre elles d’acord a algun criteri tematic o d’organitzacio del seu codi. Els paquets s\u0026rsquo;organitzen de forma jerarquica, de manera que podem crear sub-paquets dins d\u0026rsquo;altres paquets: paquet1.paquet2.paquetn Els noms dels packages s’escriuen tots en minúscula i separant paquets i sub-paquets per un punt. Totes les classes de Java pertanyen a algun package. En cas de no incloure cap sentencia package, es considera que aquella classe pertany a un package especial anomenat per defecte (default package). Donada una classe, aquesta únicament pot pertanyer a un paquet. Donat un paquet, a dintre seu mai hi poden haver dues classes amb el mateix nom.  Inclusio de classes dins d\u0026rsquo;un paquet  Per incloure una classe dins d\u0026rsquo;un paquet nomes cal incloure la següent sentencia al inici del fitxer de codi font, abans de qualsevol altra instruccio: package nomdelpaquet Ús de classes d\u0026rsquo;altres paquets Per usar classes definides en altres paquets cal usar la sentencia import:  import nomdelpaquet.Classe; import nomdelpaquet.*; package dam.uf2; import java.util.*; public class ComptaChar { ...  Estructura dels fitxers dins dels paquets  Els arxius .class pertanyents a paquets i subpaquets han d\u0026rsquo;estar organitzats de manera adequada perque tant el compilador com la maquina virtual de Java puguin utilitzar-los. Cada paquet es situa en un directori. Cada sub-paquet s\u0026rsquo;ubica en un directori de nivell inferior, i així successivament. El nom de cada directori ha de ser el del propi paquet.  Paquets bàsics del JDK (Java Development Kit)  java.lang: es el paquet principal i el compilador l’incorpora de manera automatica (no cal importar-lo). Conte les classes basiques de Java, incloent-hi el tractament de cadenes de caracters, el maneig de nombres i funcions matematiques, l’acces als recursos del sistema, i la programacio multiarea. java.io: controla les operacions d’entrada i sortida i els arxius. java.util: conte classes i metodes de proposits molt diversos, com ara generacio de nombres aleatoris (Random), tractament d\u0026rsquo;arrays (Arrays), propietats del sistema, etc. java.net: dona suport a les comunicacions TCP/IP. Inclou les classes que fan referencia a la comunicacio en xarxa. java.applet: conte nomes la classe applet que permet el desenvolupament d’aplicacions incrustades en pagines HTML. java.awt: conte les classes i els metodes de l’Abstract Windows Toolkit, independents del sistema, per al maneig de la interfície d’usuari. java.awt.image: conte classes i metodes independents del sistema, neces- saris per al maneig de grafics i imatges. java.awt.peer: com que les classes i els metodes son específics de cada sistema, java.awt.peer conte les classes necessaries per connectar els components defi- nits en el paquet java.awt amb els components correctes de cada sistema.  Exemple Si tenim un projecte amb el següent arbre de fitxers:\nL\u0026rsquo;estructura que necessitem en cada fitxer per poder veure la resta de fitxers és la següent:\n En el Main.java principal necessitem importar els dos fitxers que no tenim al mateix directori:  import classes.classes2.Funcions2; import classes.Funcions;   Per emprar Funcions3 desde Main no ens cal indicar-hi res ja que es troba al mateix directori i per tant ja és visible per Main.\n  Funcions es troba dins el package classes, per això en el Main cal importar-lo i en Funcions.java cal indicar-li a quin package pertany:\n  package classes;  De la mateixa manera Funcions2 es troba dins el package classes.classes2, per això en el Main cal importar-lo i en Funcions3.java cal indicar-li a quin package pertany:  package classes.classes2;  Aquí teniu l'enllaç al projecte: Projecte imports/package\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/condicional/",
	"title": "Estructura condicional",
	"tags": [],
	"description": "",
	"content": "Estructura condicional L\u0026rsquo;estructura de control condicional o alternativa permet prendre una decisió en un moment determinat sobre quines instruccions s\u0026rsquo;han d\u0026rsquo;executar. Donada una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet decidir entre un o varis camins d\u0026rsquo;execució.\n Existeixen diferents tipus d\u0026rsquo;estructura condicional.\n Estructura simple (if) Estructura composta (if/else) Estructura encadenada (if/else if/else) Sentència switch (switch) Combinació d\u0026rsquo;estructures  1. Estructura simple (if) Aquesta és la forma bàsica. Consisteix en una estructura en la qual si l' avaluació lògica és certa s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions, en cas contrari s\u0026rsquo;ometen aquestes instruccions. Consideracions:\n L\u0026rsquo;expressió lògica ha d\u0026rsquo;anar precedida de la paraula if i entre parèntesi (). Les instruccions que s\u0026rsquo;han d\u0026rsquo;executar es situen a continuació dins de les claus {}. Només s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions contingut entre {} quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a cert.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n}\nAcció3;     2. Estructura composta (if/else) La diferència respecte el cas anterior és que ara quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals també s\u0026rsquo;executarà un bloc d\u0026rsquo;instruccions.\n Aquestes instruccions aniran contingudes dins de parèntesis {} i precedides de la paraula else.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n} else {\nAcció3;\n}\nAcció4;     3. Estructura encadenada o múltiple (if/else if/ else) A vegades es dóna la situació que no volem decidir només entre dos camins d\u0026rsquo;execució, sinó que el problema ens requereix escollir entre diferents camins, així serà necessari introduir la figura del else if(). Comportament:\n En aquest cas el programa avalua la primera expressió booleana que es troba, si és certa executa el bloc d\u0026rsquo;instruccions que hi pertany. Però si l\u0026rsquo;avaluació és falsa anirà a la següent expressió booleana que es trobarà en un bloc else if(). I així consecutivament fins a la última. S\u0026rsquo;ha de tenir en compte que és important la prioritat en l\u0026rsquo;avaluació de les diferents expressions booleanes. Si s\u0026rsquo;avalua a cert en alguna expressió booleana JA NO avalua els següents casos, entra dins el bloc d\u0026rsquo;instruccions, s\u0026rsquo;executen les instruccions pertinents, i surt de l\u0026rsquo;estructura de control sense avaluar la resta de casos (podrien avaluar-se també a cert, per això és important la prioritat alhora d\u0026rsquo;establir els casos). Si s\u0026rsquo;introdueix un bloc else i cap expressió booleana s\u0026rsquo;avalua a cert, s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions corresponents a l\u0026rsquo;else.     Codi Diagrama de flux     Acció0;\nif ( cond1 ) {\nAcció1;\n} else if (cond2) {\nAcció2;\n}else if (cond3) {\nAcció3;\n}else if (cond4) {\nAcció4;\n}else {\nAcció5;\n}\nAcció6;     4. Sentència switch (switch) Aquesta estructura és útil quan en funció del valor d\u0026rsquo;una variable es poden executar camins d\u0026rsquo;instruccions diferents. Per exemple podríem pensar en un menú d\u0026rsquo;una app on tenim diferents opcions o un comandament a distància de la tele. Consideracions:\n En aquest cas s\u0026rsquo;avalua a == EL VALOR de la variable en qüestió i definirem les instruccions pertinents en cada cas. A l\u0026rsquo;inici d\u0026rsquo;aquesta estructura comença amb un switch seguida de la variable que volem avaluar entre parèntesi: switch (variable). Tot seguit, i entre claus {}, definim tots els casos que es volen tractar d\u0026rsquo;aquesta variable. Per a cada cas existeix un bloc case valor: amb tots els casos possibles. Si volem executar un bloc d\u0026rsquo;instruccions en cas que no es trobi cap dels valors desitjats per la variable sempre tenim el bloc default: que ens permet fer la mateixa funció que \u0026ldquo;l\u0026rsquo;else\u0026rdquo; en les estructures anteriors. En cada bloc case és necessari acabar-lo amb un break; necessari per a que ens surti de l\u0026rsquo;estructura switch. És una estructura que podríem simular amb una estructura encadenada o múltiple, la única diferència respecte a l\u0026rsquo;anterior és que en aquest cas, si no posem el break, sí que permetria executar més d\u0026rsquo;un case diferent.     Codi Diagrama de flux     Acció0;\nswitch ( expressio ) {\ncase valor1:\nAcció1;\nbreak;\ncase valor2:\nAcció2;\nbreak;\ncase valor3:\nAcció3;\nbreak;\ncase valor4:\nAcció4;\nbreak;\ndefault:\nAcció5;\n} Acció6;     5. Combinació d\u0026rsquo;estructures Moltes vegades els problemes que ens trobem a la vida real requereix de la composició de diferents estructures de control, així doncs es podria donar el cas que tinguéssim diferents estructures de control unes dins d\u0026rsquo;altres de forma jerarquitzada.\nExemple: En l\u0026rsquo;època actual de Coronavirus, donat els cribatges de PCRs per detectar casos positius ens interessaria detectar quins són els assimptomàtics. Així doncs m\u0026rsquo;invento un algorisme que permeti filtrar aquelles persones que ens interessa per realitzar les proves. És necessari que donades unes quantes dades ens digui si cal que faci alguna de les proves o no.\n Volem analitzar les persones entre 18 i 40 anys, d\u0026rsquo;aquestes es farà la prova bàsica de PCR, però les noies embarassades no realitzaran aquesta bàsica sinó que faran una prova més avançada. Pel que fa a les persones majors de 40 anys els hi realitzarem una prova avançada de PCR i un test d\u0026rsquo;esforç físic.  Exemples  Crea un programa on es mostri el resultat de sumar dos nombres sempre que la suma de tots dos sigui inferior o igual a 15. (exemple estructura simple)  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int suma = num1 + num2; if( suma \u0026lt;= 15) { System.out.println(num1+num2); }  Crea un programa que permeti a dir, donats dos nombres per l\u0026rsquo;usuari, si són múltiples l\u0026rsquo;un a l\u0026rsquo;altre. (exemple estructura composta)  System.out.println(\u0026quot;Entra el 1r nombre\u0026quot;); int num1 = sc.nextInt(); System.out.println(\u0026quot;Entra el 2n nombre\u0026quot;); int num2 = sc.nextInt(); if(num1%num2 == 0 || num2%num1 == 0){ System.out.println(\u0026quot;Són divisors\u0026quot;); } else { System.out.println(\u0026quot;No són divisors\u0026quot;); }  Creeu un programa que permeti introduir dos nombres i realitzar una operació sobre la base de l\u0026rsquo;nombre de codi, 1, 2 o 3 permeti restar, multiplicar o dividir els dos nombres i mostrar el resultat per pantalla.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int opcio = sc.nextInt(); if(opcio==1)System.out.println(num1 - num2); else if(opcio == 2) System.out.println(num1 * num2); else if(opcio == 3) System.out.println(num1 / num2); else System.out.println(\u0026quot;Opcio no correcta.\u0026quot;);  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int codi = sc.nextInt(); int resultat=0; if(codi==1) { resultat = operand1 - operand2; }else if(codi==2){ resultat = operand1 * operand2; }else if(codi==3){ resultat = operand1 / operand2; }else{ System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat);  El mateix exemple anterior però ara amb un switch.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); int operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); int operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); int codi = sc.nextInt(); int resultat=0; switch(codi) { case 1: resultat = operand1 - operand2; break; case 2: resultat = operand1 * operand2; break; case 3: resultat = operand1 / operand2; break; default: System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat); switch(codi) { case 1: case 2: case 3: System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot; + resultat); }  Crea un programa que donats 4 números indiqui si els números són iguals i quin d\u0026rsquo;ells és el menor i major nombre de tots ells. El programa a més haurà de mostrar per pantalla el resultat de restar el major pel menor d\u0026rsquo;ells i el resultat de multiplicar els altres dos.  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int num3 = sc.nextInt(); int num4 = sc.nextInt(); int max = num1; int min = num1; int mult; /** * * Són iguals?? */ if(num1 == num2 \u0026amp;\u0026amp; num1 == num3 \u0026amp;\u0026amp; num1 == num4) System.out.println(\u0026quot;Són iguals\u0026quot;); else System.out.println(\u0026quot;No són iguals\u0026quot;); /** * PROBLEMA DEL MAJOR MENOR 5 OPCIONS * */ //OPCIO 1 força bruta if(num2\u0026gt;num1 \u0026amp;\u0026amp; num2\u0026gt;num3 \u0026amp;\u0026amp; num2\u0026gt;num4)max = num2; else if(num3\u0026gt;num1 \u0026amp;\u0026amp; num3\u0026gt;num2 \u0026amp;\u0026amp; num3\u0026gt;num4) max = num3; else if(num4\u0026gt;num1 \u0026amp;\u0026amp; num4\u0026gt;num2 \u0026amp;\u0026amp; num4\u0026gt;num3) max = num4; if(num2\u0026lt;num1 \u0026amp;\u0026amp; num2\u0026lt;num3 \u0026amp;\u0026amp; num2\u0026lt;num4)min = num2; else if(num3\u0026lt;num1 \u0026amp;\u0026amp; num3\u0026lt;num2 \u0026amp;\u0026amp; num3\u0026lt;num4) min = num3; else if(num4\u0026lt;num1 \u0026amp;\u0026amp; num4\u0026lt;num2 \u0026amp;\u0026amp; num4\u0026lt;num3) min = num4; //OPCIO 2 comparem el max amb tots i el min amb tots individualment max = num1; if(num2\u0026gt;max) max = num2; if(num3\u0026gt;max) max = num3; if(num4\u0026gt;max) max = num4; min = num1; if(num2\u0026lt;min) min = num2; if(num3\u0026lt;min) min = num3; if(num4\u0026lt;min) min = num4; //OPCIO 3 a Semifinals comparant! int max1,max2, min1,min2; if(num1\u0026gt; num2)max1 = num1; else max1 = num2; if(num3 \u0026gt; num4) max2 = num3; else max2=num4; if(max1 \u0026gt; max2) max = max1; else max=max2; if(num1 \u0026lt; num2)min1 = num1; else min1 = num2; if(num3 \u0026lt; num4) min2 = num3; else min2=num4; if(min1 \u0026gt; min2) min = min1; else min=min2; //OPCIO 4 semifinals math.max math.min max1 = Math.max(num1,num2); max2 = Math.max(num3,num4); max = Math.max(max1,max2); min1 = Math.min(num1,num2); min2 = Math.min(num3,num4); min = Math.min(min1,min2); //OPCIO 5 math.max i math.min max = Math.max (Math.max(num1,num2), Math.max(num3,num4)); min = Math.min (Math.min(num1,num2), Math.min(num3,num4)); System.out.println(max-min); //Segona part de l'activitat on es realitza la multiplicacio amb els que no són major i menor if( (max==num1 \u0026amp;\u0026amp; min==num2) || (max==num2 \u0026amp;\u0026amp; min==num1))mult=num3 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num1))mult=num2 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num1))mult=num2 * num3; else if( (max==num2 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num2))mult=num1 * num4; else if( (max==num2 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num2))mult=num1 * num3; else if( (max==num3 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num3))mult=num1 * num2; //Solució utilitzant Math.mix i Math.max per extreure valors que no siguin ni màxim ni mínim. int min3 = Math.min (Math.max(num1,num2), Math.max(num3,num4)); int max3 = Math.max (Math.min(num1,num2), Math.min(num3,num4)); int mult2 = min3 * max3;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/iteratiu/",
	"title": "Estructura iterativa",
	"tags": [],
	"description": "",
	"content": "Estructura iterativa L\u0026rsquo;estructura de control iterativa permet reproduir un bloc d\u0026rsquo;instruccions un nombre de vegades determinat.\nMentre es compleixi una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet executar un bloc d\u0026rsquo;instruccions determinat. Anomenarem bucle el bloc d\u0026rsquo;instruccions que es repeteixen i iteració a cadascuna de les vegades que es repeteix.\n Característiques generals:  Tots els bucles tenen:\n Una precondició: Estat abans d\u0026rsquo;entrar al bucle Una postcondició:Estat al sortir de bucle Una expressió booleana: mentre es compleixi l\u0026rsquo;expressió booleana s\u0026rsquo;itera el bucle, un cop l\u0026rsquo;expressió booleana s\u0026rsquo;avalua a fals es \u0026ldquo;surt\u0026rdquo; del bucle i es continua amb l\u0026rsquo;execució de les instruccions següents. Variable de control: Ens serveix per controlar el nombre d\u0026rsquo;iteracions. Aquesta variable pot estar englobada en un dels següents grups:  acumulador: guardem en una variable una operació concreta. comptador: augmentem o disminuïm una variable \u0026ldquo;comptant\u0026rdquo; iteracions. booleana: pot ser simplement una variable booleana que es manipuli dins el bucle.     Un bucle necessita:\n1. Una condició de sortida: cal que l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals per sortir del bucle, sinó provocarem un bucle infinit.\n2. La variable de control ens ha d\u0026rsquo;acostar pas a pas a complir amb la condició de sortida del bucle.\n3. Dins el bucle acostumen a ver instruccions amb l\u0026rsquo;objectiu de buscar un resultat.\n Existeixen diferents estructures iteratives.\n While For Do while Combinació d\u0026rsquo;estructures  1. While L\u0026rsquo;estructura bàsica d\u0026rsquo;un bucle while en Java és:\nwhile(expressió booleana){ Instruccions del bucle }  Com ja s\u0026rsquo;ha explicat, mentre s\u0026rsquo;avaluï l\u0026rsquo;expressió booleana a cert s\u0026rsquo;executaran totes les instruccions contingudes en les claus {}. Quan es deixi de complir l\u0026rsquo;expressió booleana el fil d\u0026rsquo;execució sortirà del bucle i continuarà amb la següent instrucció que hi hagi després.\nConsideracions:\n Si l\u0026rsquo;expressió no avalua a una expressió booleana donarà un error de compilació. Si no s\u0026rsquo;apliquen mecanismes que modifiquen el comportament de l\u0026rsquo;expressió booleana aconseguirem un bucle infinit.     Codi Diagrama de flux     Acció1;\nwhile ( cond ) {\nAcció2;\n}\nAcció4;     2. For El for és una estructura que permet realitzar recorreguts a un conjunt de dades de forma simple. Ens permet condensar la funcionalitat de bucle en una sola línia. Per exemple podem recorre els nombres del 1 al 10 de la següent manera:\nfor(int i=1; i \u0026lt;= 10; i++){ System.out.println(i); }  Com s\u0026rsquo;observa, dins dels parèntesi \u0026ldquo;()\u0026rdquo; tenim tres instruccions separades per \u0026ldquo;;\u0026rdquo; :\n Inicialització d\u0026rsquo;una variable iteradora abans d\u0026rsquo;entrar al bucle (int i=1). Després tenim l\u0026rsquo;expressió booleana igual com posaríem en un bucle while (i\u0026lt;=10). Finalment tenim el pas que ens assegura que el bucle acaba (i++).  Així doncs\nfor (inicialització Iterador; Expressió booleana; Modificació Iterador)\n Qualsevol bucle while es pot transformar en un bucle for i viceversa.\n Així doncs, l\u0026rsquo;exemple anterior si el transformem en un while queda de la següent manera:\nint i=1; //Inicialització variable while( i \u0026lt;= 10 ){ //Expressió booleana System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }  3. Do while Aquesta estructura no és gaire utilitzada i és similar a l\u0026rsquo;estructura while. La diferència és que en el while abans de realitzar cap iteració es comprova l\u0026rsquo;expressió booleana, en canvi amb el do while primer es realitzar una iteracio i després es comprova l\u0026rsquo;expressió booleana. A efectes pràctics si estem segurs que existeix almenys una iteració es pot usar aquesta estructura.\nEl cas anterior fet en do while seria:\nint i=1; //Inicialització variable do { System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }while( i \u0026lt;= 10 ); //Expressió booleana     Codi Diagrama de flux     Acció1;\ndo {\nAcció2;\n} while ( cond );\nAcció3;     4. Combinació d\u0026rsquo;estructures Moltes vegades els nostres programes requereixen de més d\u0026rsquo;un bucle encadenat, per exemple quan resseguim una matriu de dades. Imagineu-vos un programa que escanegi un tauler d\u0026rsquo;escacs, no només ha de llegir files, sinó que també ha de llegir columnes, així doncs l\u0026rsquo;estructura seria la següent:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } }  En l\u0026rsquo;exemple anterior per cada posició ièssima es recorre el bucle 8 vegades per cada j. Així per cada fila recorrem totes les columnes. Si mirem l\u0026rsquo;execució del bucle obtenim:\nPosició 1 1 Posició 1 2 Posició 1 3 Posició 1 4 Posició 1 5 Posició 1 6 Posició 1 7 Posició 1 8 Posició 2 1 Posició 2 2 Posició 2 3 Posició 2 4 Posició 2 5 Posició 2 6 Posició 2 7 Posició 2 8 Posició 3 1 Posició 3 2 Posició 3 3 ... Posició 8 8  En aquest cas estem parlant de dos bucles que són independents entre ells. Ja que per cada bucle interior no té afectació en l\u0026rsquo;exterior.\nPerò a vegades és necessari que els bucles siguin dependents, en aquest cas sí que hi hauria afectació. Modifiquem el programa anterior perquè per exemple enlloc de mostrar tot el tauler de posicions només vull mostrar aquelles que es troben per sobre de la diagonal:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ if(i \u0026lt; j) { System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } } }  En aquest cas, si executeu veureu que només mostra la meitat superior de posicions. Això és així perquè en el bucle interior realitzem una operació que DEPÈN de la variable i que pertany al primer bucle, per tant el bucle interior depèn de l\u0026rsquo;exterior.\nExemples  Fer un programa que llegeixi dos nombre enters n 1 i n 2 amb n 1 \u0026lt; n 2 i escrigui tots els nombres enters dins l’interval [n 1 , n 2 ] en ordre creixent. Aquest és un exemple de recorregut on la variable n1 fa de comptador.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); while(n1\u0026lt;=n2) { System.out.println(n1); n1++; }  Fer un programa que llegeixi dos nombre enters n 1 i n 2 amb n 1 \u0026lt; n 2 i escrigui els nombres enters parells que hi ha dins l’interval [n 1 , n 2 ] en ordre creixent. El nombre zero es considera parell.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); for(int i=n1; i \u0026lt;= n2; i++) { if(i%2==0)System.out.println(i); } //2naOpcio (meitat d'iteracions) if(n1%2!=0)n1++; while(n1\u0026lt;=n2) { System.out.println(n1); n1 = n1+2; }  Fer un programa que llegeixi el valor de la base, un nombre enter i l’exponent, un nombre enter no negatiu, i escrigui el valor de la potència a b . No emprar la funció Math.pow(). En aquest cas resultat fa d' acumulador d\u0026rsquo;un resultat que es mostra al final.  int base = sc.nextInt(); int exponent = sc.nextInt(); int i = 0; int resultat = 1; while(i \u0026lt; exponent) { resultat = resultat * base; i++; } System.out.println(resultat);  Fer un programa que llegeixi un nombre enter i escrigui si és un nombre primer o no. Un nombre enter és primer si es més gran que 1 i només és divisible per 1 i per ell mateix.  /* Fixeu-vos amb l'expressió booleana del bucle, en aquest cas es fa ús d'una variable booleana per sortir del bucle i no continuar iterant, en cas que ja haguem descobert la solució i no sigui necessari continuar iterant. */ System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); //inicialitzo variables,index=n/2 i analitzem tots els possibles divisors de n/2 fins a 1. boolean esPrimer = true; int index = n/2; //En la condició del bucle,si trobem un divisor ja no cal que continuem buscant i acabem while(index \u0026gt; 1 \u0026amp;\u0026amp; esPrimer){ if(n % index == 0) esPrimer=false; index--; } //Escrivim solucio String sol = (!esPrimer)? \u0026quot;NO és primer\u0026quot; : \u0026quot;És primer\u0026quot; ; System.out.println(sol);  Fer un programa que llegeixi un nombre enter i escrigui si és capicua o no.Considerarem també capicues els nombres enters d\u0026rsquo;una xifra.  System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); int valorInicial = n; int capicua = 0; while(n\u0026gt;0){ capicua = capicua*10; capicua = capicua + n%10; System.out.println(capicua); n = n/10; } System.out.println(capicua); if(valorInicial == capicua) System.out.println(n+ \u0026quot;és un nombre capicua\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/llibreries/",
	"title": "Llibreries",
	"tags": [],
	"description": "",
	"content": "Definició En el context de la programacio una llibreria es un conjunt de codi re-utilitzable, encapsulat d\u0026rsquo;alguna manera (paquets, classes, moduls, dll, \u0026hellip;) i documentat adequadament.\n En el cas de Java tenim llibreries de classes i les seves propietats. Per exemple podriem considerar la classe Math, que ens proporciona un conjunt de funcions matematiques, una llibreria en si mateixa. Ex:  int x = -15; int y = Math.abs(x);   Tambe tenim paquets com java.util que agrupen de forma organitzada un conjunt de classes amb unes funcionalitats comunes (utilitats). Veieu mes exemples de les llibreries del SDK a la última pagina del document. import java.util.Scanner;  import java.util.Scanner;  Llibreries de classes: paquets  Una llibreria de classes, o package (paquet) en Java, es un conjunt de classes vinculades entre elles d’acord a algun criteri tematic o d’organitzacio del seu codi. Els paquets s\u0026rsquo;organitzen de forma jerarquica, de manera que podem crear sub-paquets dins d\u0026rsquo;altres paquets: paquet1.paquet2.paquetn Els noms dels packages s’escriuen tots en minúscula i separant paquets i sub-paquets per un punt. Totes les classes de Java pertanyen a algun package. En cas de no incloure cap sentencia package, es considera que aquella classe pertany a un package especial anomenat per defecte (default package). Donada una classe, aquesta únicament pot pertanyer a un paquet. Donat un paquet, a dintre seu mai hi poden haver dues classes amb el mateix nom.  Inclusio de classes dins d\u0026rsquo;un paquet  Per incloure una classe dins d\u0026rsquo;un paquet nomes cal incloure la següent sentencia al inici del fitxer de codi font, abans de qualsevol altra instruccio: package nomdelpaquet Ús de classes d\u0026rsquo;altres paquets Per usar classes definides en altres paquets cal usar la sentencia import:  import nomdelpaquet.Classe; import nomdelpaquet.*; package dam.uf2; import java.util.*; public class ComptaChar { ...  Estructura dels fitxers dins dels paquets  Els arxius .class pertanyents a paquets i subpaquets han d\u0026rsquo;estar organitzats de manera adequada perque tant el compilador com la maquina virtual de Java puguin utilitzar-los. Cada paquet es situa en un directori. Cada sub-paquet s\u0026rsquo;ubica en un directori de nivell inferior, i així successivament. El nom de cada directori ha de ser el del propi paquet.  Paquets bàsics del JDK (Java Development Kit)  java.lang: es el paquet principal i el compilador l’incorpora de manera automatica (no cal importar-lo). Conte les classes basiques de Java, incloent-hi el tractament de cadenes de caracters, el maneig de nombres i funcions matematiques, l’acces als recursos del sistema, i la programacio multiarea. java.io: controla les operacions d’entrada i sortida i els arxius. java.util: conte classes i metodes de proposits molt diversos, com ara generacio de nombres aleatoris (Random), tractament d\u0026rsquo;arrays (Arrays), propietats del sistema, etc. java.net: dona suport a les comunicacions TCP/IP. Inclou les classes que fan referencia a la comunicacio en xarxa. java.applet: conte nomes la classe applet que permet el desenvolupament d’aplicacions incrustades en pagines HTML. java.awt: conte les classes i els metodes de l’Abstract Windows Toolkit, independents del sistema, per al maneig de la interfície d’usuari. java.awt.image: conte classes i metodes independents del sistema, neces- saris per al maneig de grafics i imatges. java.awt.peer: com que les classes i els metodes son específics de cada sistema, java.awt.peer conte les classes necessaries per connectar els components defi- nits en el paquet java.awt amb els components correctes de cada sistema.  Exemple Si tenim un projecte amb el següent arbre de fitxers:\nL\u0026rsquo;estructura que necessitem en cada fitxer per poder veure la resta de fitxers és la següent:\n En el Main.java principal necessitem importar els dos fitxers que no tenim al mateix directori:  import classes.classes2.Funcions2; import classes.Funcions;   Per emprar Funcions3 desde Main no ens cal indicar-hi res ja que es troba al mateix directori i per tant ja és visible per Main.\n  Funcions es troba dins el package classes, per això en el Main cal importar-lo i en Funcions.java cal indicar-li a quin package pertany:\n  package classes;  De la mateixa manera Funcions2 es troba dins el package classes.classes2, per això en el Main cal importar-lo i en Funcions3.java cal indicar-li a quin package pertany:  package classes.classes2;  Aquí teniu l'enllaç al projecte: Projecte imports/package\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/cadenescaracters/",
	"title": "Tractament cadena de caràcters",
	"tags": [],
	"description": "",
	"content": " Un String és una classe que permet treballar amb cadenes de caràcters. La classe String de Java ens dóna moltes funcionalitats que ens permeten realitzar moltes tasques d\u0026rsquo;una forma senzilla.\n La funció sobre la classe String la trobareu a: Java Oracle Classe String\nInicialització La manera de declarar i inicialitzar aquest objecte és com en els tipus primitius. Amb la variable String diem que la variable str i strBuit emmagatzemen un String i a continuació s\u0026rsquo;hi assigna un valor. En el cas del valor \u0026quot;\u0026quot; assignem un String buit.\nString str = \u0026quot;El primer string\u0026quot;; String strBuit = \u0026quot;\u0026quot;;  Funcionalitats interessants /* longitud del string STR.LENGTH() */ System.out.println(\u0026quot;longitud \u0026quot; + str.length()); /* Caràcter en la posició pos de str. STR.CHARAT(int) */ str = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;En la posició 4 hi ha: \u0026quot; + str.charAt(4)); System.out.println(\u0026quot;En la posició 11 hi ha: \u0026quot; + str.charAt(11)); /* Comença o acaba l'string en... STARTSWITH OR ENDSWITH */ str = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;comienza por El \u0026quot; + str.startsWith(\u0026quot;El\u0026quot;)); System.out.println(\u0026quot;termina por programa \u0026quot; + str.endsWith(\u0026quot;programa\u0026quot;)); /* Posició d'un caràcter dins un string STR.INDEXOF('x') Ocurrència a partir d'un cert caràcter STR.INDEXOF('x', pos) */ int pos = str.indexOf('p'); System.out.println(\u0026quot;posición de la letra p \u0026quot; + pos); //segona ocurrencia de p pos = str.indexOf('p', pos + 1); /* Comparació entre dos strings STR.COMPARETO(STRING2) */ str = \u0026quot;Pep\u0026quot;; System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Xavi\u0026quot;)); System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Gines\u0026quot;)); System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Pep\u0026quot;)); /* Substring amb UNA variable posicioInicial indica a a partir de quin caràcter volem recollir el substring fins al final. STR.SUBSTRING(posicioInicial) Substring amb Dues variables determinen quin substring obtindrem entre les dues posicions STR.SUBSTRING(posicioInicial, posicioFinal) */ str = \u0026quot;El lenguaje Java\u0026quot;; System.out.println(\u0026quot;Substring \u0026quot; + str.substring(12)); //Java System.out.println(\u0026quot;Substring \u0026quot; + str.substring(3, 11)); //lenguaje /* Eliminar espais en blanc STR.TRIM() */ str = \u0026quot; 12 \u0026quot;; System.out.println(\u0026quot;string original :\u0026quot; + str); System.out.println(\u0026quot;string sin espacios en blanco :\u0026quot; + str.trim()); /* Convertir array a String ARRAYS.TOSTRING(array) */ int[] arrayNumeric = {24, 2, 4, -12}; System.out.println(\u0026quot;número --\u0026gt; string \u0026quot; + Arrays.toString(arrayNumeric)); /* Convertir strings a enters i decimals INTEGER.PARSEINT(str.TRIM()); DOUBLE.VALUEOF(str).DOUBLEVALUE(); */ str = \u0026quot;12\u0026quot;; int numeroInt = Integer.parseInt(str.trim()); System.out.println(\u0026quot;string --\u0026gt; número \u0026quot; + numeroInt); str = \u0026quot;12.35 \u0026quot;; double numeroDouble = Double.valueOf(str).doubleValue(); System.out.println(\u0026quot;string --\u0026gt; número \u0026quot; + numeroDouble); /* Separar String en diferents cadenes str.SPLIT(\u0026quot; \u0026quot;); --\u0026gt; Separa les diferents paraules per espais */ String cadena = \u0026quot;Hola que tal com estas\u0026quot;; String[] vectorSeparat = cadena.split(\u0026quot; \u0026quot;); for (String a : vectorSeparat) System.out.println(a); /* EXEMPLE D'ÚS: De cada alumne volem obtenir el nom amb el format correcte i el dni. */ String alumnes = \u0026quot;\u0026quot; + \u0026quot;Nom; Cognoms; DNI\\n\u0026quot; + \u0026quot;xavi; sanChO; 111111a\\n\u0026quot; + \u0026quot;pep; beÀ; 222222b\\n\u0026quot;; String[] rows = alumnes.split(\u0026quot;\\n\u0026quot;); for (int i = 1; i \u0026lt; rows.length; i++) { String[] dades = rows[i].split(\u0026quot;;\u0026quot;); String nom = dades[0]; String cognoms = dades[1]; String nomComplet = nom + \u0026quot; \u0026quot; + cognoms; String[] partsNom = nomComplet.split(\u0026quot; \u0026quot;); String capitalitzat = \u0026quot;\u0026quot;; for (String part : partsNom) { String senseEspais = part.trim(); if (!senseEspais.equals(\u0026quot;\u0026quot;)) { String inicial = part.substring(0, 1).toUpperCase(); String resta = part.substring(1).toLowerCase(); capitalitzat += inicial + resta + \u0026quot; \u0026quot;; } } System.out.println(capitalitzat); String dni = dades[2].trim(); System.out.println(dni); }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/",
	"title": "Programació estructuada",
	"tags": [],
	"description": "",
	"content": "Què és la programació estructurada? La programació estructurada és un paradigma de programació en el qual les instruccions de codi s\u0026rsquo;executen de forma ordenada utilitzant només tres estructures: seqüencial, condicional i repetitiva.\n S\u0026rsquo;anomena estructura a la manera en què diferents parts es combinen per construir un tot. Un programa tindrà l\u0026rsquo;estructura corresponent a la forma en què les diferents accions individuals o avaluacions parcials es combinen per construir el programa en el seu conjunt.\nEls fonaments de l\u0026rsquo;anomenada programació estructurada es van establir a principis dels anys seixanta i es van consolidar amb els treballs de Dijkstra, Bohm.. El resum dels seus postulats és el següent: \u0026ldquo;es diu que un programa és estructurat si s\u0026rsquo;expressa únicament mitjançant combinacions de les estructures bàsiques\u0026rdquo;:\n seqüencial condicional iterativa  Estructura bàsica: Totes les estructures de control tenen un únic punt d\u0026rsquo;entrada i un únic punt de sortida.\nTot seguit repassarem les tres estructures de control: seqüencials, condicionals i iteratives en Java.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/recursivitat/",
	"title": "Recursivitat",
	"tags": [],
	"description": "",
	"content": " Definició Un subprograma és recursiu quan al llarg de la seva execució s’efectua alguna crida a si mateix.\nDes d’un punt de vista tècnic s’efectua una crida d’un programa a un altre programa, amb la particularitat de que aquest programa és el mateix.\n PARTS de la crida recursiva En una situació recursiva s’ha de pensar en:\n Quan acaba? Cas Base:   Solució senzilla No s’activa més recursió. En tot algorisme recursiu hi ha d’haver almenys un cas base  Com continua? Cas recurrent:   Efectuarem una crida a la mateixa funció per acostar-nos al cas base. Poden incloure’s passos addicionals a més de la crida recursiva  Avantatges  Què ofereix la recursivitat?\n  Codi elegant i senzill Solucions òptimes a problemes iteratius que computacionalment són complexos     Què NO ofereix la recursivitat?\n  Creació de moltes variables Guardem molta informació de crides a funció en memòria.    Com funciona? El procés d’execució recursiu consisteix en una cadena de generació de crides a la mateixa funció. En cada crida:\n Es reserva l’espai en memòria necessari per emmagatzemar els paràmetres i els objectes locals usats en el subprograma. Es reben els paràmetres i es cedeix l’execució d’instruccions al subprograma que comença a executar-se. A l’acabar la seva feina, allibera l’espai reservat, els identificadors locals deixen de tenir vigència i passa l’execució de la instrucció següent a la crida.  Comparativa Iteratiu vs Recursiu    Iteratiu Recursiu     Realitza una petició Realitza una petició   Repeteix el cos del bucle Repeteix les crides a mètodes recursius   Té una condició d’acabament Té una condició d’acabament   S’acaba quan es compleix la condició de continuació del bucle S’acaba quan la crida arriba al cas base, desencadenant una sequència de crides enrera   S’ha de complir la condició d’acabament S’ha de complir que s’arriba al cas base    TOT algorisme iteratiu es pot representar recursiu i tot algorisme recursiu es pot representar iteratiu\n Exemple factorial Iteratiu\nint factorial; int nombre = sc.nextInt(); for(int i=0; i \u0026lt; nombre; i++){ factorial = factorial * i; }  Recursiu\nint nombre = 5; 5 * factorial(4) 4 * factorial(3) 3 * factorial(2) 2 * factorial(1) 1; public int factorial (n){ if(n==1) return 1; else return n * factorial (n-1); }  Exemples Suma de dos nombres: public static int suma(int a, int b) { if (b == 0) return a; else if (a == 0) return b; else return 1 + suma(a, b - 1); }  Suma elements d'un vector: public static int sumaVector(int t[], int n){ if(n==0)return t[0]; else return t[n] + sumaVector(t,n-1); }  Cerca dicotòmica: public class CercaDicotomica { public static void main(String[] args) { CercaDicotomica programa = new CercaDicotomica(); programa.inici(); } public void inici() { int[] array = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}; int cercaDivuit = cercaDicotomica(array, 0, array.length-1, 18); int cercaCinc = cercaDicotomica(array, 0, array.length-1, 5); System.out.println(\u0026quot;Cerca del 18: \u0026quot; + cercaDivuit); System.out.println(\u0026quot;Cerca del 5: \u0026quot; + cercaCinc); } /** Cerca dicotòmica recursiva sobre un array d'enters. * * @param array On es fa la cerca * @param inici Posició inicial de la cerca * @param fi Posició final * @param valor Valor a cercar * @return Índex on és el valor, o -1 si no existeix */ public int cercaDicotomica(int[] array, int inici, int fi, int valor) { //CAS BASE: No s'ha trobat el valor if (inici \u0026gt; fi) return -1; //Es calcula la posició central entre els dos índexs de cerca int pos = inici + (fi - inici) / 2; //CAS RECURSIU: Si el valor es menor que la posició que s'ha mirat //llavors cal seguir cercant per la part \u0026quot;dreta\u0026quot; de l'array if (array[pos] \u0026gt; valor) return cercaDicotomica(array, inici, pos - 1, valor); //CAS RECURSIU: Si el valor és més gran que la posició que s'ha mirat //llavors cal seguir cercant per la part \u0026quot;esquerra\u0026quot; de l'array else if (array[pos] \u0026lt; valor) return cercaDicotomica(array, pos + 1, fi, valor); //CAS BASE: És igual, per tant, s'ha trobat else return pos; }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/dissenypoo/",
	"title": "Recursivitat",
	"tags": [],
	"description": "",
	"content": " Definició Un subprograma és recursiu quan al llarg de la seva execució s’efectua alguna crida a si mateix.\nDes d’un punt de vista tècnic s’efectua una crida d’un programa a un altre programa, amb la particularitat de que aquest programa és el mateix.\n PARTS de la crida recursiva En una situació recursiva s’ha de pensar en:\n Quan acaba? Cas Base:   Solució senzilla No s’activa més recursió. En tot algorisme recursiu hi ha d’haver almenys un cas base  Com continua? Cas recurrent:   Efectuarem una crida a la mateixa funció per acostar-nos al cas base. Poden incloure’s passos addicionals a més de la crida recursiva  Avantatges  Què ofereix la recursivitat?\n  Codi elegant i senzill Solucions òptimes a problemes iteratius que computacionalment són complexos     Què NO ofereix la recursivitat?\n  Creació de moltes variables Guardem molta informació de crides a funció en memòria.    Com funciona? El procés d’execució recursiu consisteix en una cadena de generació de crides a la mateixa funció. En cada crida:\n Es reserva l’espai en memòria necessari per emmagatzemar els paràmetres i els objectes locals usats en el subprograma. Es reben els paràmetres i es cedeix l’execució d’instruccions al subprograma que comença a executar-se. A l’acabar la seva feina, allibera l’espai reservat, els identificadors locals deixen de tenir vigència i passa l’execució de la instrucció següent a la crida.  Comparativa Iteratiu vs Recursiu    Iteratiu Recursiu     Realitza una petició Realitza una petició   Repeteix el cos del bucle Repeteix les crides a mètodes recursius   Té una condició d’acabament Té una condició d’acabament   S’acaba quan es compleix la condició de continuació del bucle S’acaba quan la crida arriba al cas base, desencadenant una sequència de crides enrera   S’ha de complir la condició d’acabament S’ha de complir que s’arriba al cas base    TOT algorisme iteratiu es pot representar recursiu i tot algorisme recursiu es pot representar iteratiu\n Exemple factorial Iteratiu\nint factorial; int nombre = sc.nextInt(); for(int i=0; i \u0026lt; nombre; i++){ factorial = factorial * i; }  Recursiu\nint nombre = 5; 5 * factorial(4) 4 * factorial(3) 3 * factorial(2) 2 * factorial(1) 1; public int factorial (n){ if(n==1) return 1; else return n * factorial (n-1); }  Exemples Suma de dos nombres: public static int suma(int a, int b) { if (b == 0) return a; else if (a == 0) return b; else return 1 + suma(a, b - 1); }  Suma elements d'un vector: public static int sumaVector(int t[], int n){ if(n==0)return t[0]; else return t[n] + sumaVector(t,n-1); }  Cerca dicotòmica: public class CercaDicotomica { public static void main(String[] args) { CercaDicotomica programa = new CercaDicotomica(); programa.inici(); } public void inici() { int[] array = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}; int cercaDivuit = cercaDicotomica(array, 0, array.length-1, 18); int cercaCinc = cercaDicotomica(array, 0, array.length-1, 5); System.out.println(\u0026quot;Cerca del 18: \u0026quot; + cercaDivuit); System.out.println(\u0026quot;Cerca del 5: \u0026quot; + cercaCinc); } /** Cerca dicotòmica recursiva sobre un array d'enters. * * @param array On es fa la cerca * @param inici Posició inicial de la cerca * @param fi Posició final * @param valor Valor a cercar * @return Índex on és el valor, o -1 si no existeix */ public int cercaDicotomica(int[] array, int inici, int fi, int valor) { //CAS BASE: No s'ha trobat el valor if (inici \u0026gt; fi) return -1; //Es calcula la posició central entre els dos índexs de cerca int pos = inici + (fi - inici) / 2; //CAS RECURSIU: Si el valor es menor que la posició que s'ha mirat //llavors cal seguir cercant per la part \u0026quot;dreta\u0026quot; de l'array if (array[pos] \u0026gt; valor) return cercaDicotomica(array, inici, pos - 1, valor); //CAS RECURSIU: Si el valor és més gran que la posició que s'ha mirat //llavors cal seguir cercant per la part \u0026quot;esquerra\u0026quot; de l'array else if (array[pos] \u0026lt; valor) return cercaDicotomica(array, pos + 1, fi, valor); //CAS BASE: És igual, per tant, s'ha trobat else return pos; }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arraylist/",
	"title": "ArrayList",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que conté una col·lecció de dades del mateix tipus i és dinàmica.\n La definició de la classe ArrayList java.util.ArrayList i de totes les seves funcionalitats la trobareu a: Java Oracle Classe ArrayList\nPropietats\n Un arrayList funciona de forma similar a un array estàtic, conté elements del mateix tipus, poden ser repetits i aquests elements estan ordenats. A diferència d\u0026rsquo;un array estàtic, en els ArrayList no és necessari definir el tamany de l\u0026rsquo;array en la seva creació. Es tracta d\u0026rsquo;una llista d\u0026rsquo;elements en els que podrem iterar-los, afegir-ne, modificar-los o eliminar-los.  Declaració\nEn la declaració indicarem de quin tipus és la llista entre \u0026lt;\u0026gt;. Per exemple per declarar un ArrayList d\u0026rsquo;enters:\nArrayList\u0026lt;Integer\u0026gt; arrayListEnters = new ArrayList();  Funcionalitats principals\nEn el següent exemple es veuen diferents mètodes (tots ells explicats en la declaració de Java Oracle) que permeten actuar a un ArrayList de la mateixa manera que un Array (.add(), .size(), .get()),en ell es genera un arrayList d\u0026rsquo;enters, s\u0026rsquo;entren valors i es fa un recorregut per l\u0026rsquo;estructura:\nScanner teclat = new Scanner(System.in); ArrayList\u0026lt;Integer\u0026gt; arrayDinamic = new ArrayList\u0026lt;Integer\u0026gt;(); int valor = 1; while (valor != 0) { System.out.println(\u0026quot;Introdueix valor\u0026quot;); valor = teclat.nextInt(); if (valor != 0) //Amb add() s'assignen nous valors a l'arrayList arrayDinamic.add(valor); } //.size() fa la mateixa funció que .length en els arrays estàtics for (int i = 0; i\u0026lt;arrayDinamic.size(); i++) //Per tal d'accedir als elements usarem .get(int pos), recordem que la primera posició és 0. System.out.println(\u0026quot;arrayDinamic.get(\u0026quot;+i+\u0026quot;) = \u0026quot;+arrayDinamic.get(i)); //altres funcions interessants són isEmpty o remove if(arrayDinamic.isEmpty()) System.out.println(\u0026quot;No existeix cap element dins l'arrayList, està buit\u0026quot;); //Eliminar un element per posició arrayDinamic.remove(i); teclat.close();  En aquesta pàgina trobareu uns quants exemples més d\u0026rsquo;ús d\u0026rsquo;ArrayList: ArrayList con ejemplos\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/",
	"title": "Dades Compostes",
	"tags": [],
	"description": "",
	"content": "Fins ara hem treballat amb estructures de dades simples. A mesura que tractem problemes més complexos es fa necessari agrupar i tractar les dades com un únic conjunt, això són el que s\u0026rsquo;anomenen els objectes, l\u0026rsquo;encapsulament de dades en una mateixa estructura. Així doncs en el següent capítol analitzarem:\n Arrays unidimensional: conjunt de dades del mateix tipus dins una dimensió. Arrays bidimensionals: conjunt de dades del mateix tipus dins de dues dimensions. (Taula) Cadena de caràcters: conjunt de caràcters que s\u0026rsquo;agrupen en una estructura que s\u0026rsquo;anomena String. ArrayList: Semblants als arrays unidimensionals, però amb les característiques que aporta la interfície List.   "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/programacioavancadapoo/",
	"title": "Disseny de POO",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6programaciomodular/",
	"title": "Programació Modular",
	"tags": [],
	"description": "",
	"content": "Una vegada hem conegut els fonaments de la programació estructurada, hem observat que a mesura que el programa creix en complexitat es fa necessari escriure moltes línies de codi, reutilitzant, a vegades, moltes parts. Per tal d\u0026rsquo;ordenar aquest codi és necessari agrupar-lo en diferents blocs i reutilitzar quan sigui possible. Així doncs treballarem:\n Introducció Disseny Modular : aprendrem a organitzar els mòduls que generem en Java en diferents llibreries/paquets. Metodologia Top-Down : observarem com desenvolupar petits aplicatius partint de l\u0026rsquo;origen i arribant a les parts més específiques. Llibreries : entendrem l\u0026rsquo;organització dels paquets i llibreries en un projecte. Recursivitat : coneixerem i jugarem amb la crida a funcions de forma recursiva.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/7poo/",
	"title": "Programació Orientada a Objectes",
	"tags": [],
	"description": "",
	"content": "Fins el moment hem vist les avantatges d\u0026rsquo;usar la programació modular en els nostres projectes. Ara entrem a analitzar perquè Java se l\u0026rsquo;anomena un llenguatge orientat a objectes i quins beneficis ens dóna per les nostres aplicacions.\n Introducció paradigma POO : coneixem què és la Programació orientada a objectes (POO) i quines característiques principals té. Implementació bàsica de POO : coneixem i implementem en Java les parts bàsiques de les que es composa una classe i les provem. Desenvolupament a partir de POO : aprendrem a combinar diferents classes que ens portin a la resolució de petits aplicatius. Programació Avançada de POO : aprendrem a usar característiques avançades sobre la programació orientada a objectes (Herència, classes abstractes, interfícies). Disseny de POO : usarem UML juntament amb el M5. Entorns, per tal de plasmar en diagrames aquell codi que definim en classes.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/",
	"title": "M03 Programació DAM",
	"tags": [],
	"description": "",
	"content": "M03 Programació DAM En aquesta pàgina web trobareu els apunts del M03. Programació DAM. La web està realitzada utilitzant un Framework Web(Hugo), hostatjada a Github i es fa ús de Github Pages.\nTot seguit es mostra la calendarització i les hores de les UFs que s\u0026rsquo;imparteixen en aquest mòdul de 1r de DAM. Fixeu-vos que l\u0026rsquo;ordre de realització de les UFs és: UF1, UF2, UF4 i UF3. La UF4 segueix a la UF2, ja que pedagògicament té més sentit realitzar-la després d\u0026rsquo;aquesta UF.\n   UF dates hores     UF1: Programació estructurada 15/09/20 - 11/12/20 85h   UF2: Disseny modular 14/12/20 - 05/02/21 50h   UF4: Programació orientada a objectes (POO) 06/02/21 - 23/04/21 68h   UF3: Fonaments de fitxers 24/04/21 - 25/05/21 30h    L\u0026rsquo;índex de continguts que veurem és:\n UF1: Programació estructurada  Estructura d\u0026rsquo;un programa  Introducció Metodologies de Software Tipus de Llenguatges   Tipus de dades Algorísmia Programació estructurada  Estructura sequencial Estructura condicional Estructura iterativa   Estructures compostes  Arrays Unidimensionals Arrays Bidimensionals Tractament cadena de caràcters      UF2: Disseny modular\nUF4: Programació orientada a objectes (POO)\nUF3: Fonaments de fitxers\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]