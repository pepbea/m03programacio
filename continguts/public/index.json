[
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/1herencia/",
	"title": "Herència i polimorfisme",
	"tags": [],
	"description": "",
	"content": "L\u0026rsquo;herència permet a una classe nova crear-se a partir d\u0026rsquo;una classe existent, aquesta característica permet crear una estructura jeràrquica de classes cada vegada més especialitzada. L\u0026rsquo;herència es basa en la reutilització de classes on es crea una classe nova incorporant atributs i mètodes de la classe pare. Els mètodes heretats poden ser sobreescrits i adoptar un comportament nou o ampliant-ne la seva funcionalitat. Aquesta reutilització permet estalviar molt de temps i adoptar components creats i ja testats.\n** Atribut final en l\u0026rsquo;herència**\nA vegades, pels requisits de la nostra aplicació no ens interessa que hi pugui haver una herència en una classe, en aquests casos indicaríem mitjançant l\u0026rsquo;atribut final. Per exemple si vull que Persona sigui una classe final i que per tant no es pugui extendre ho marcaria de la següent manera:\npublic final class Persona{ ... }  El mateix passa quan apliquem final a un mètode o a un atribut.\n En el cas del mètode si en la definició posem que és final no ens permetrà en subclasses sobreescriure\u0026rsquo;l, no el podrem modificar.  package paquet.exemplefinal; public class classeOrigen { public final void mostraInfo() { System.out.println(\u0026quot;mostraInfo\u0026quot;); } } package paquet.exemplefinal; public class classeFilla extends classeOrigen { public void mostraInfo() { System.out.println(\u0026quot;mostra una altra info\u0026quot;); } }  En aquest cas donaria un error de compilació ja que intentem sobreescriure un mètode que és definit com a final en la classe pare.\n En el cas d\u0026rsquo;un atribut final un cop inicialitzat no ens permetrà tornar-lo a modificar canviant-li el valor, s\u0026rsquo;utilitza per definir constants.  public class CanviVariable { private final int enter=1; public CanviVariable(int enter){ this.enter = enter; } } public class CanviVariable2 { public static void main(String[] args){ final int enter = 0; enter = 2; } }  Els casos anteriors donarien error ja que volem canviar el valor d\u0026rsquo;una variable que s\u0026rsquo;ha declarat final i ja té valor. En canvi, el cas següent no ens donaria cap error, ja que quan creem l\u0026rsquo;objecte donem valor per primer cop a aquesta variable, això sí, no li podrem canviar el valor en l\u0026rsquo;execució de tot el programa al ser final.\npublic class CanviVariable { private final int enter; public CanviVariable(int enter){ this.enter = enter; } }  Constructors i super\nQuan definim els mètodes constructors de les subclasses, és necessari primer cridar la constructora de la classe pare, això és possible gràcies a super() o super(parametres). Quan es crea un fill primer sempre es comença inicialitzant les variables del pare i després s\u0026rsquo;inicialitzen les del fill. Si no posem cap mètode super, per defecte intentarà buscar super() en el pare, si no existís hi hauria un error de compilació.\npublic class Persona{ String dni; public Persona(String dni){ this.dni = dni; } } public class Alumne extends Persona{ int matricula; public Alumne(String dni, int matricula){ super(dni); this.matricula = matricula; } } //Error de compilació ja que la constructora Persona() com a tal no existeix public class Alumne extends Persona{ int matricula; public Alumne(int matricula){ super(); this.matricula = matricula; } }  Exemple\nRealitzem un exemple de com seria una herència amb classe pare Producte i classe Filla ProducteDescompte.\npublic class Producte { protected String nom; protected double preu; public Producte(String nom, double preu) { this.nom = nom; this.preu = preu; } public void anunci() { System.out.println(\u0026quot;Hola sóc el producte \u0026quot; + nom); } public double valorProducte() { return preu; } } public class ProducteDescompte extends Producte { private int descompte; public ProducteDescompte(String nom, double preu, int descompte) { super(nom, preu); this.descompte = descompte; } @Override public void anunci() { super.anunci(); System.out.println( \u0026quot;Tinc un descompte de \u0026quot; + descompte+\u0026quot;%\u0026quot;); } @Override public double valorProducte() { return preu - (preu*descompte)/100; } public void rebaixaNouDescompte(int rebaixa){ this.descompte = this.descompte - rebaixa; } public void augmentaNouDescompte(int augment){ this.descompte = this.descompte + augment; } } public class Programa { public static void main(String[] args) { Producte p = new Producte(\u0026quot;Llapis\u0026quot;, 100.0); p.anunci(); System.out.println(\u0026quot;El preu del producte és \u0026quot; + p.valorProducte()); System.out.println(); ProducteDescompte p1 = new ProducteDescompte(\u0026quot;Llapis rebaixat\u0026quot;, 100.0, 10); p1.anunci(); System.out.println(\u0026quot;El preu d'un nou producte rebaixat és \u0026quot; + p1.valorProducte()); System.out.println(); p1.augmentaNouDescompte(10); p1.anunci(); System.out.println(\u0026quot;El preu del producte després de modificar la rebaixa és \u0026quot; + p1.valorProducte()); } }  Polimorfisme Polimorfisme (Polimorphism) és l\u0026rsquo;habilitat que té un mètode de proveïr un comportament determinat en funció de l\u0026rsquo;escala que ocupi en l\u0026rsquo;arbre jeràrquic. El mateix mètode dins una herència es pot comportar de diferent manera ja que té la capacitat de canviar el seu comportament gràcies a la sobreescriptura.\n La sobreescriptura ens permet modificar mètodes definits en la superclasse. Per tant ens permet canviar el comportament de mètodes que ja estan definits en la classe pare.\nSobreescriptura (Overriding). Principalment és la idea de re-implementar en la classe filla el mètode de la classe pare per tal d\u0026rsquo;adaptar o modificar-ne el comportament. S\u0026rsquo;entén amb la idea d\u0026rsquo;especificar el comportament de la classe pare en el fill.\n public class Persona { public void saluda(){ System.out.println(\u0026quot;Hola soc una persona\u0026quot;); } } public class Alumne extends Persona { public void saluda(){ System.out.println(super.saluda() + \u0026quot; i també sóc un alumne\u0026quot;); } }  Els mètodes toString, equals, són exemples de mètodes que sobreescrivim amb la idea de que adoptin un comportament diferent a com estan definits en java.lang.Object.\nSobrecàrrega. En aquest cas es parla de polimorfisme estàtic ja que definim el mateix mètode però amb paràmetres d\u0026rsquo;entrada diferents. De forma que el mateix mètode(amb diferents paràmetres) pot tenir un comportament diferent en la mateixa classe.\n Per exemple ens podríem trobar la sobrecàrrega en els constructors (poder construir un mateix objecte a partir de passar-li paràmetres diferents)\npublic Persona (){ this.nom = \u0026quot;desconegut\u0026quot;; this.edat = -1; } public Persona (String nom){ this.nom = nom; this.edat = -1; } public Persona (String nom, int edat){ this.nom = nom; this.edat = edat; }  Quan sobreescrivim un mètode podem utilitzar la paraula @Override sobre la definició del mètode per indicar-li a Java que sobreescrivim un mètode la superclasse.\nEx, sobreescrivim el comportament que ens dóna java.lang.Object per toString():\npublic class Enter{ int valor; @Override public String toString() { return \u0026quot;El valor d'Enter és:\u0026quot; + this.valor; } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/1herencia/1sealed/",
	"title": "Sealed Classes",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;herència permet a una classe nova crear-se a partir d\u0026rsquo;una classe existent. La nova classe (subclasse) \u0026ldquo;hereta\u0026rdquo; els atributs i mètodes de la classe primària, i a més a més, té la possibilitat d\u0026rsquo;incorporar nous atributs i mètodes específics a la subclasse.\n Aquesta particularitat permet crear una estructura jeràrquica de classes cada vegada més especialitzada. L\u0026rsquo;herència es basa en la reutilització de classes on es crea una classe nova incorporant atributs i mètodes de la classe pare. Els mètodes heretats poden ser sobreescrits i adoptar un comportament nou o ampliant-ne la seva funcionalitat. Aquesta reutilització permet estalviar molt de temps i adoptar components creats i ja testats.\nConceptes:\n Superclasse: Classe primària o existent en l\u0026rsquo;herència. Subclasse: classe nova i resultant d\u0026rsquo;aplicar herència a una altra classe. Especialització: Procés que permet estendre d\u0026rsquo;una classe pare a una classe filla, ampliant atributs i mètodes. Generalització: Procés de navegar de les classes filles a la classe pare. En la classe pare trobarem els atributs i mètodes comuns a totes les subclasses.  Herència simple\nJava permet l\u0026rsquo;herència simple: qualsevol classe només té una classe pare, no permet l\u0026rsquo;herència múltiple com sí permeten altres llenguatges de programació com el C++. Això ens planteja el problema que a vegades pels requisits de la nostra aplicació és necessari simular l\u0026rsquo;herència múltiple fent ús d\u0026rsquo;interfícies. Per a més informació: problema del diamant\nRelació \u0026ldquo;és un\u0026rdquo; vs \u0026ldquo;conté un\u0026rdquo;\nL\u0026rsquo;herència és una relació d\u0026rsquo;extensió d\u0026rsquo;una classe més específica respecte una classe genèrica, això ens porta a que la classe filla ÉS UNA classe pare, però amb les funcionalitats ampliades/exteses/modificades. A vegades quan es programa existeix el dubte de confondre aquesta relació amb una relació de composició CONTÉ UN, que erròniament entenguem com a subclasse \u0026ldquo;una part\u0026rdquo; de la classe principal. Un exemple seria el següent:\nCom podeu veure en l\u0026rsquo;herència es parteix d\u0026rsquo;un BaseVehicle, que a la vegada s\u0026rsquo;especialitza en un Truck, i a la vegada s\u0026rsquo;especialitza en un TacoTruck. TacoTruck \u0026ldquo;ÉS UN\u0026rdquo; BaseVehicle, TacoTruck és una extensió de BaseVehicle. En canvi Truck \u0026ldquo;CONTÉ UN\u0026rdquo; engine, engine és una part de Truck, no podria substituir l\u0026rsquo;engine per un truck i que es comporti de la mateixa manera.\nUna vegada es conceptualitza el problema a resoldre pots crear el teu arbre jeràrquic. Un exemple amb animals seria:\nImplementació Per tal d\u0026rsquo;indicar que una classe és una herència utilitzarem la paraula extends en la definició de la classe. Per exemple si tenim una classe pare Persona i dos classes filles Alumne i Professor, ho faríem de la següent manera:\npublic class Persona{ ... } public class Alumne extends Persona { ... } public class Professor extends Persona{ ... }  Si la superclasse no està al mateix package que la subclasse, s\u0026rsquo;ha d\u0026rsquo;importar la classe ja que sinó no en tindria visibilitat.\njava.lang.Object\nUna subclasse pot ser a la vegada superclasse d\u0026rsquo;altres classes i crear així un àrbre jeràrquic de classes. En Java totes les classes hereten d\u0026rsquo;una classe mare, la classe arrel de totes és java.lang.Object. Hi ha un conjunt de mètodes que tenen TOTES les classes de Java, inclús les que programeu vosaltres, aquí teniu la descripció de Java Oracle referent a la classe Object.\nTotes les classes per defecte extenen de java.lang.Object, per tant poden fer ús dels mètodes que conté aquesta classe, per exemple:\n toString(): retorna una definició dels atributs en forma de String, aquesta definició la podeu \u0026ldquo;sobreescriure i modificar i adaptar a les vostres necessitats\u0026rdquo;. equals(Object o): mètode per comparar l\u0026rsquo;Objecte o amb l\u0026rsquo;implícit(this), per defecte retorna true si es tracta del mateix objecte (mateixa referència) i false si no. Si volem comparar els atributs per comprovar que es tracta dels mateixos valors serà necessari \u0026ldquo;sobreescriure\u0026rdquo; el mètode i fer que adopti el comportament que volem, això passa per exemple amb el cas de la classe String, ens retorna true si els dos Strings tenen el mateix valor i no si fan referència al mateix objecte. clone(): s\u0026rsquo;utilitza per realitzar una còpia de l\u0026rsquo;objecte. Veurem altres maneres de realitzar còpies.  És el mateix posar en la definició extends Object que no posar-ho.\nfinal\nA vegades, pels requisits de la nostra aplicació no ens interessa que hi pugui haver una herència en una classe, en aquests casos indicaríem mitjançant l\u0026rsquo;atribut final. Per exemple si vull que Persona sigui una classe final i que per tant no es pugui extendre ho marcaria de la següent manera:\npublic final class Persona{ ... }  El mateix passa quan apliquem final a un mètode o a un atribut.\n En el cas del mètode si en la definició posem que és final no ens permetrà en subclasses sobreescriure\u0026rsquo;l, no el podrem modificar.  package paquet.exemplefinal; public class classeOrigen { public final void mostraInfo() { System.out.println(\u0026quot;mostraInfo\u0026quot;); } } package paquet.exemplefinal; public class classeFilla extends classeOrigen { public void mostraInfo() { System.out.println(\u0026quot;mostra una altra info\u0026quot;); } }  En aquest cas donaria un error de compilació ja que intentem sobreescriure un mètode que és definit com a final en la classe pare.\n En el cas d\u0026rsquo;un atribut final un cop inicialitzat no ens permetrà tornar-lo a modificar canviant-li el valor, s\u0026rsquo;utilitza per definir constants.  public class CanviVariable { private final int enter=1; public CanviVariable(int enter){ this.enter = enter; } } public class CanviVariable2 { public static void main(String[] args){ final int enter = 0; enter = 2; } }  Els casos anteriors donarien error ja que volem canviar el valor d\u0026rsquo;una variable que s\u0026rsquo;ha declarat final i ja té valor. En canvi, el cas següent no ens donaria cap error, ja que quan creem l\u0026rsquo;objecte donem valor per primer cop a aquesta variable, això sí, no li podrem canviar el valor en l\u0026rsquo;execució de tot el programa al ser final.\npublic class CanviVariable { private final int enter; public CanviVariable(int enter){ this.enter = enter; } }  Visibilitat\nFins el moment hem observat com els atributs i mètodes públics són accessibles des de fora de la pròpia classe i els que són privats són només accessibles desde dins la pròpia classe.\nAmb l\u0026rsquo;herència apareix la visibilitat protected, que permet tenir visibilitat d\u0026rsquo;atributs i mètodes situats en:\n la mateixa classe les seves subclasses altres classes del mateix package  Com s\u0026rsquo;observa existeix l\u0026rsquo;opció default quan no indiquem cap atribut de visibilitat, les classes declarades com a default tenen accés a totes les classes del propi package.\nSobreescriptura\nMés amunt hem comentat el concepte de sobreescriptura, aquesta és una de les característiques polimòrfiques que tenim amb els llenguatges POO.\nLa sobreescriptura ens permet modificar mètodes definits en la superclasse. Per tant ens permet canviar el comportament de mètodes que ja estan definits en la classe pare.\n Quan sobreescrivim un mètode podem utilitzar la paraula @Override sobre la definició del mètode per indicar-li a Java que sobreescrivim un mètode la superclasse.\nEx, sobreescrivim el comportament que ens dóna java.lang.Object per toString():\npublic class Enter{ int valor; @Override public String toString() { return \u0026quot;El valor d'Enter és:\u0026quot; + this.valor; } }  Constructors i super\nQuan definim els mètodes constructors de les subclasses, és necessari primer cridar la constructora de la classe pare, això és possible gràcies a super() o super(parametres). Quan es crea un fill primer sempre es comença inicialitzant les variables del pare i després s\u0026rsquo;inicialitzen les del fill. Si no posem cap mètode super, per defecte intentarà buscar super() en el pare, si no existís hi hauria un error de compilació.\npublic class Persona{ String dni; public Persona(String dni){ this.dni = dni; } } public class Alumne extends Persona{ int matricula; public Alumne(String dni, int matricula){ super(dni); this.matricula = matricula; } } //Error de compilació ja que la constructora Persona() com a tal no existeix public class Alumne extends Persona{ int matricula; public Alumne(int matricula){ super(); this.matricula = matricula; } }  Exemple\nRealitzem un exemple de com seria una herència amb classe pare Producte i classe Filla ProducteDescompte.\npublic class Producte { protected String nom; protected double preu; public Producte(String nom, double preu) { this.nom = nom; this.preu = preu; } public void anunci() { System.out.println(\u0026quot;Hola sóc el producte \u0026quot; + nom); } public double valorProducte() { return preu; } } public class ProducteDescompte extends Producte { private int descompte; public ProducteDescompte(String nom, double preu, int descompte) { super(nom, preu); this.descompte = descompte; } @Override public void anunci() { super.anunci(); System.out.println( \u0026quot;Tinc un descompte de \u0026quot; + descompte+\u0026quot;%\u0026quot;); } @Override public double valorProducte() { return preu - (preu*descompte)/100; } public void rebaixaNouDescompte(int rebaixa){ this.descompte = this.descompte - rebaixa; } public void augmentaNouDescompte(int augment){ this.descompte = this.descompte + augment; } } public class Programa { public static void main(String[] args) { Producte p = new Producte(\u0026quot;Llapis\u0026quot;, 100.0); p.anunci(); System.out.println(\u0026quot;El preu del producte és \u0026quot; + p.valorProducte()); System.out.println(); ProducteDescompte p1 = new ProducteDescompte(\u0026quot;Llapis rebaixat\u0026quot;, 100.0, 10); p1.anunci(); System.out.println(\u0026quot;El preu d'un nou producte rebaixat és \u0026quot; + p1.valorProducte()); System.out.println(); p1.augmentaNouDescompte(10); p1.anunci(); System.out.println(\u0026quot;El preu del producte després de modificar la rebaixa és \u0026quot; + p1.valorProducte()); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/1acces/",
	"title": "Accés a BBDOO",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/",
	"title": "AEA1. Programació Estructurada",
	"tags": [],
	"description": "",
	"content": "En aquesta primera part del temari introduirem que és un programa informàtic, en què consisteix la programació estructurada i concretament com ho treballarem a partir de Java, el llenguatge de programació que utilitzarem durant tot el mòdul. Els diferents apartats en els que es divideixen són:\n Introducció Entorn Java Algorisme Tipus de dades i variables  Primer programa Operadors aritmètics, lògics i relacionals Conversions de tipus   Què és la programació estructurada? Estructura sequencial Estructures de selecció Estructures de repetició i de salt Excepcions Depuració de codi i assercions  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/1estructuresestatiquesdinamiques/",
	"title": "Estructures estàtiques i dinàmiques",
	"tags": [],
	"description": "",
	"content": " Les estructures de dades són una eina que ens ofereix Java per guardar i organitzar dades de forma eficient, de manera que ens permeti manipular aquestes dades d\u0026rsquo;una manera òptima respecte a temps i memòria. Les estructures de dades s\u0026rsquo;utilitzen, principalment, pe reduir la complexitat del codi, sobretot en quan a temps d\u0026rsquo;execució.\n En Java diferenciem entre les estructures de dades estàtiques i dinàmiques.\nEstructures de dades Estàtiques Les estructures de dades estàtiques permeten reservar en memòria un espai fix on es guardarà la informació abans d\u0026rsquo;utilitzar-lo. Sí que permet modificar els valors que guardem dins una estructura estàtica però no el tamany que és fix des de l\u0026rsquo;inici. Exemples d\u0026rsquo;estructures estàtiques en java hi ha els arrays, les matrius, les variables, les cadenes de caràcters (String),etc.\nEstructures de dades Dinàmiques Les estructures dinàmiques defineixen inicialment amb quina estructura de dades treballaré i es va assignant memòria dinàmica a mesura que manipulem aquesta estructura, reservant nova memòria quan afegim elements i alliberant memòria quan en traiem. Exemples d\u0026rsquo;estructures dinàmiques en Java tenim totes les classes que deriven de Collections i que permeten definir les estructures típiques dinàmiques: llistes, conjunts, diccionaris, etc.\nLes estructures dinàmiques de dades permeten d\u0026rsquo;una forma senzilla crear les principals estructures de dades molt útils en problemes algorítmics: llistes, arbres, grafs, cues, piles, etc.\n Tot seguit pel que fa a estructures estàtiques analitzarem arrays unidimensionals (comunment dit array), arrays bidimensionals (matriu) i les cadenes de caràcters (Strings). Pel que fa a les estructures dinàmiques explicarem l\u0026rsquo;estructura que té Java de classificar totes les classes dins la interfície Collections i com existeix un polimorfisme paramètric i tipus (Generics) que permet definir l\u0026rsquo;estructura d\u0026rsquo;una estructura dinàmica sense necessitat d\u0026rsquo;especificar l\u0026rsquo;objecte que les conté. Treballarem amb un tipus de llista ArrayList, un tipus de conjunt HashSet i un tipus de diccionari HashMap.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/1acces/1estandard/",
	"title": "Estàndards",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/1fluxos/",
	"title": "Fluxos de dades (byte, char)",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/0funcionspasparametres/",
	"title": "Funcions i pas de paràmetres",
	"tags": [],
	"description": "",
	"content": "El paradigma de programació utilitzat fins ara ha estat el de la programació estructurada, consistent en tractar de desenvolupar programes més fiables i fàcils de mantenir mitjançant la utilització exclusiva de 3 estructures de control: la seqüencial, l\u0026rsquo;alternativa i la iterativa.\nQuan els programes comencen a créixer i es tornen difícils de resoldre en conjunt per la seva complexitat, és necessari optar per particionar el codi en porcions petites i estructurades que poden ser abordades més fàcilment per separat. Es tracta del principi de \u0026ldquo;divideix i guanyaràs\u0026rdquo;.\nLa programació funcional consisteix en aplicar aquesta tècnica de divideix i venceràs per separar un programa en parts més senzilles, anomenades funcions. És el pas previ a treballar amb la Programació Orientada a Objectes (POO).\nFunció Una funció es defineix com un conjunt d’instruccions que desenvolupen una tasca concreta i que pot ser (o no) necessària en diferents llocs del programa. Una funció té un conjunt d\u0026rsquo;instruccions que la defineixen i pot ser \u0026ldquo;executada\u0026rdquo; en diferents parts del nostre programa, cada vegada que es \u0026ldquo;crida\u0026rdquo; la mateixa.\n Les funcions poden necessitar o no dades externes que es passen com a paràmetres d\u0026rsquo;entrada i poden retornar o no un resultat a qui l\u0026rsquo;hagi cridat com a paràmetre de sortida.\nEl llenguatge Java segueix el paradigma de l\u0026rsquo;orientació a objectes, i per tant tot s\u0026rsquo;estructura a partir de classes. En aquest context les funcions s\u0026rsquo;implementen dins una estructura d\u0026rsquo;una classe i cada funció s\u0026rsquo;anomena mètode d\u0026rsquo;aquesta classe.\nQuan codifiquem un mètode tindrem els següents elements:\n  Signatura o capçalera del mètode: Està composta per:\n El nom del mètode. Els arguments del mètode: ens informen de quins paràmetres obtenim per tal de poder usar dins el mètode. Si el llenguatge de programació usa tipus de dades, com Java, també ens especificarà de quin tipus de dades és cadascun d\u0026rsquo;aquests arguments. Tipus de dada que retorna el mètode: només s\u0026rsquo;especificarà si la funció retorna un paràmetre, sinó en el cas de Java, si no retorna cap paràmetre el tipus serà void.    Cos del mètode: Defineix el bloc d\u0026rsquo;instruccions que executarà el mètode. Dins del cos del mètode hi haurà el retorn del mètode on es posarà quina dada es retorna (si és que es retorna alguna dada).\n  Quan parlem de la crida a un mètode, ens referim a fer ús d\u0026rsquo;aquest mètode des d\u0026rsquo;un altre mètode (ja sigui des de la mateixa classe o no).\nExemple de funció que retorna un valor i funció que no retorna un valor Si per exemple tenim la següent funció:\npublic static int sumaFuncioRetornaValor(int a, int b){ int resultat; resultat = a + b; return resultat; }   La signatura és: public static int sumaFuncioRetornaValor(int a, int b) El nom sumaFuncioRetornaValor Els arguments: (int a, int b) Tipus de dades que retorna int El cos són les tres instruccions de dins la funció.  Com podem comprovar l\u0026rsquo;anterior mètode es una funció ja que retorna un enter. Si volguéssim canviar aquesta funció per una altra que no retorni cap valor ho faríem de la següent manera:\npublic static void sumaFuncioNoRetornaValor(int a, int b){ int resultat; resultat = a + b; System.out.println(resultat); }  Fixeu-vos que hem canviat int -\u0026gt; void i ara ja no retornem res, sinó que ho escrivim per pantalla.\nSi volem efectuar la crida dins el main del nostre programa faríem el següent per una funció i per una acció:\npublic static void main(String args[]){ int res = sumaFuncioRetornaValor(2,3); System.out.println(res); sumaFuncioNoRetornaValor(2,3); }  Pas per valor o per referència Arguments o paràmetres Els paràmetres formals són les dades que apareixen a la signatura de la funció.\nEls paràmetres actuals són les dades transferides en la crida d\u0026rsquo;una funció.\nTransferència per valor o per referència:\n  En la transferència per valor, el valor del paràmetre actual es copia en una altra posició de memòria, a la qual es pot accedir pel nom del paràmetre formal. Aquesta NO ÉS la variable inicial, n\u0026rsquo;és una còpia del seu valor en una altra posició de memòria.\n  En la transferència per referència, el subprograma rep l’adreça de memòria en què es troba el paràmetre actual, a la qual es pot accedir llavors pel nom del paràmetre formal. Per això en manipular una variable passada per referència es modifica l\u0026rsquo;original ja que actua sobre la MATEIXA posició de memòria.\n  A Java, les dades primitives i els Strings es passen per valor i les compostes (com els arrays o altres objectes) es passen per referència.\n Exemple: Pas per valor o per referència Pas de paràmetres per valor o per referència. En aquest exemple es veu la diferència de passar un valor o de passar la referència on es troba aquest valor.\npublic class Parametres { // Paràmetres passats per valor perquè són de tipus simple public static void intercanvi(int a, int b) { System.out.println(\u0026quot;Dins del mètode intercanvi:\u0026quot;); System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); int temp = a; a = b; b = temp; System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); } // Paràmetres passats per referència perquè és de tipus compost (un objecte) public static void intercanviArray(int[] v) { System.out.println(\u0026quot;Dins del mètode intercanviArray:\u0026quot;); System.out.println(\u0026quot;v[0] = \u0026quot; + v[0]); System.out.println(\u0026quot;v[1] = \u0026quot; + v[1]); int temp = v[0]; v[0] = v[1]; v[1] = temp; System.out.println(\u0026quot;v[0] = \u0026quot; + v[0]); System.out.println(\u0026quot;v[1] = \u0026quot; + v[1]); } // Main() public static void main(String[] args) { // // Exemple de pas de paràmetres per valor // System.out.println(\u0026quot;PER VALOR\u0026quot;); int x = 5; int y = 10; System.out.println(\u0026quot;x = \u0026quot; + x); System.out.println(\u0026quot;y = \u0026quot; + y); System.out.println(\u0026quot;Cridem intercanvi(x, y)\u0026quot;); intercanvi(x, y); System.out.println(\u0026quot;Tornem del mètode intercanvi(x, y)\u0026quot;); System.out.println(\u0026quot;x = \u0026quot; + x); System.out.println(\u0026quot;y = \u0026quot; + y); System.out.println(); // // Exemple de pas de paràmetres per referència // System.out.println(\u0026quot;PER REFERÈNCIA\u0026quot;); int[] array = {25, 50}; System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(\u0026quot;Cridem intercanviArray(array)\u0026quot;); intercanviArray(array); System.out.println(\u0026quot;Tornem del mètode intercanviArray(array)\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(); // //Un altre exemple de pas per valor // System.out.println(\u0026quot;PER VALOR\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); System.out.println(\u0026quot;Cridem intercanvi(array[0], array[1])\u0026quot;); intercanvi(array[0], array[1]); System.out.println(\u0026quot;Tornem del mètode intercanvi(array[0], array[1])\u0026quot;); System.out.println(\u0026quot;array[0] = \u0026quot; + array[0]); System.out.println(\u0026quot;array[1] = \u0026quot; + array[1]); } }  Observació: les cadenes (tipus String) són objectes, però són immutables, per tant no poden canviar el seu valor\nExemples Exemple1: Funció suma senzilla Realitzem la suma de dos nombres dins una funció i en retornem el resultat al programa principal:\npublic class Suma { public static void main(String[] args) { int res; int num = 25; // Exemples d'ús d'un mètode res = suma(2, 3); System.out.println(\u0026quot;suma = \u0026quot; + res); res = suma(num, 10); System.out.println(\u0026quot;suma = \u0026quot; + res); res = suma(res, num); System.out.println(\u0026quot;suma = \u0026quot; + res); } // Mètode que fa la suma de dos nombres enters public static int suma (int a, int b) { int s; s = a + b; return s; } }  Exemple2: Paràmetres del programa\npublic class ProvaArgs { /** * Imprimeix per pantalla tots els paràmetres passats en l'execució del programa * @param args Paràmetres al executar el programa */ public static void main(String[] args) { for (int i=0; i\u0026lt;args.length; i++) { System.out.println(\u0026quot;Paràmetre \u0026quot; + i + \u0026quot; = \u0026quot; + args[i]); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/1introduccio/",
	"title": "Introducció a la programació",
	"tags": [],
	"description": "",
	"content": "Breus definicions inicials Programació informàtica: És el procés d\u0026rsquo;escriure, provar, depurar/solucionar problemes, i mantenir el codi font de programes.\n Programa: Conjunt d\u0026rsquo;instruccions d’un llenguatge de programació, ordenades d\u0026rsquo;una manera determinada, que l’ordinador és capaç d’entendre i executar per resoldre un problema. L\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre unes normes sintàctiques i semàntiques que permeten realitzar multitud de funcions diferents.\n Instrucció: És una cadena de símbols d\u0026rsquo;un alfabet, formada d\u0026rsquo;acord amb certes regles sintàctiques que el processador (o el compilador) entén, i que finalment seran interpretades i executades pel processador.\n Llenguatge informàtic: Conjunt d\u0026rsquo;instruccions que ordenades d\u0026rsquo;una determinada manera generen un codi que l\u0026rsquo;ordinador és capaç d\u0026rsquo;entendre per realitzar una determinada tasca.\n Dada: Unitat d\u0026rsquo;informació que utilitzen els programes informàtics per ser tractada (llegir, modificar, eliminar, crear, transformar\u0026hellip;).\n Codi font: Codi que els humans poden entendre i manipular per tal de crear i modificar els diferents programes informàtics. En Java els fitxers que contenen codi font són fitxers amb extensió .java\n Codi màquina: Una vegada el codi font és escrit pels humans es transforma en un altre fitxer (compilació) que genera un altre fitxer/codi que està a més baix nivell i que enten la màquina. En Java els fitxers convertits a codi màquina són els fitxers executables, són diferents per cada plataforma, per això diem que java és un llenguatge multiplataforma, perquè el mateix codi font el podem executar en plataformes diferents.\n Procés d\u0026rsquo;execució d\u0026rsquo;un programa Els programes informàtics donen solució a una determinada necessitat o problemàtica. A partir d\u0026rsquo;un problema determinat dissenyem un conjunt de passos determinats, ordenats i finits que ens aporta la solució (algorisme). La implementació d\u0026rsquo;aquests passos amb un llenguatge de programació genera un codi que dóna lloc al programa informàtic final.\nAixí doncs el programa té un iniciador, executa una sèrie d\u0026rsquo;instruccions que solucionen un problema determinat i existeix un punt de finalització quan es troba l\u0026rsquo;estat que soluciona el problema.\nEn aquest procés es possible que tinguem dades d\u0026rsquo;entrada (input: dades necessàries per executar un codi determinat), i també és possible que tinguem dades de sortida (output: dades que desitgem retornar o mostrar quan s\u0026rsquo;acaba l\u0026rsquo;execució del codi).\nTot el codi que hem escrit i que posem a executar l\u0026rsquo;anomenarem procés (codi en execució).\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/2accions/1lectura/",
	"title": "Lectura",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/5coleccions/1arraylist/",
	"title": "Llista - ArrayList",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que conté una col·lecció de dades del mateix tipus i és dinàmica.\n La definició de la classe ArrayList java.util.ArrayList i de totes les seves funcionalitats la trobareu a: Java Oracle Classe ArrayList\nPropietats\n Un arrayList funciona de forma similar a un array estàtic, conté elements del mateix tipus, poden ser repetits i aquests elements estan ordenats. A diferència d\u0026rsquo;un array estàtic, en els ArrayList no és necessari definir el tamany de l\u0026rsquo;array en la seva creació. Es tracta d\u0026rsquo;una llista d\u0026rsquo;elements en els que podrem iterar-los, afegir-ne, modificar-los o eliminar-los.  Les operacions d\u0026rsquo;afegir un element al final de l\u0026rsquo;array (add), i d\u0026rsquo;establir o obtenir l\u0026rsquo;element en una determinada posició (get/set) tenen un cost temporal constant. Les insercions i esborrats tenen un cost lineal O(n), on n és el nombre d\u0026rsquo;elements de l\u0026rsquo;array.\nHem de destacar que la implementació d' ArrayList no està sincronitzada, és a dir, si múltiples fils accedeixen a un mateix ArrayList concurrentment podríem tenir problemes en la consistència de les dades. Per tant, ho haurem de tenir en compte quan fem servir aquest tipus de dades que hem de controlar la concurrència d\u0026rsquo;accés, una altra opció és utilitzar la classe Vector, similar a ArrayList i que sí permet la sincronització.\nDeclaració\nEn la declaració indicarem de quin tipus és la llista entre \u0026lt;\u0026gt;. Per exemple per declarar un ArrayList d\u0026rsquo;enters:\nArrayList\u0026lt;Integer\u0026gt; arrayListEnters = new ArrayList();  Exemple\nEn el següent exemple es veuen diferents mètodes (tots ells explicats en la declaració de Java Oracle) que permeten actuar a un ArrayList de la mateixa manera que un Array (.add(), .size(), .get()), l\u0026rsquo;exemple és primer per un enter i després per una col·lecció d\u0026rsquo;objectes Alumne:\nimport java.util.ArrayList; import java.util.Collections; public class ExempleArrayList { public static void main(String[] args) { /* * ARRAYLIST AMB ENTERS */ System.out.println(\u0026quot;ARRAYLIST ENTERS\u0026quot;); ArrayList\u0026lt;Integer\u0026gt; aL = new ArrayList\u0026lt;Integer\u0026gt;(); // Afegir elements aL.add(23); aL.add(12); aL.add(46); aL.add(2); // Recorregut System.out.println(\u0026quot;Mostrem els elements tal qual s'han introduït, ArrayList és una llista d'elements:\u0026quot;); for (int i=0; i\u0026lt;aL.size(); i++){ System.out.print(aL.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); // Comprovar si conté un objecte i obtenir la posició System.out.println(\u0026quot;Comprovem si conté element 46 i diem la posició on es troba:\u0026quot;); if (aL.contains(46)) { System.out.println(\u0026quot;Existeix i es troba a la posició: \u0026quot; + aL.indexOf(46)); } System.out.println(); //Ordenem i recorregut Collections.sort(aL); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;aL.size(); i++){ System.out.print(aL.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Eliminem i recorregut System.out.println(\u0026quot;Eliminem l'element amb index 1:\u0026quot;); aL.remove(1); for (int i=0; i\u0026lt;aL.size(); i++){ System.out.print(aL.get(i) + \u0026quot; \u0026quot;); } System.out.println(); /* * ARRAYLIST AMB OBJECTES ALUMNE */ System.out.println(\u0026quot;ARRAYLIST ALUMNES\u0026quot;); ArrayList\u0026lt;Alumne\u0026gt; alumnes = new ArrayList\u0026lt;Alumne\u0026gt;(); // Afegir elements System.out.println(\u0026quot;Mostrem els elements tal qual s'han introduït:\u0026quot;); alumnes.add(new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;)); alumnes.add(new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;)); Alumne al = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); alumnes.add(al); alumnes.add(new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;)); alumnes.add(new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;)); // Recorregut for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i)); } System.out.println(); System.out.println(); // Comprovar si conté un objecte i obtenir la posició System.out.println(\u0026quot;Comprovem si conté un element Alumne \\\u0026quot;al\\\u0026quot; i diem la posició on es troba:\u0026quot;); if (alumnes.contains(al)) { System.out.println(\u0026quot;Existeix i es troba a la posició: \u0026quot; + alumnes.indexOf(al)); } System.out.println(); System.out.println(); //ORDENACIÓ D'OBJECTES //Ordenem per edat i mostrem en recorregut Collections.sort(alumnes, Alumne.alumnesCompararPerEdat); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Ordenem per nom i mostrem en recorregut Collections.sort(alumnes, Alumne.alumnesCompararPerNom); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Ordenem per cognoms i mostrem en recorregut Collections.sort(alumnes, Alumne.alumnesCompararPerCognom); System.out.println(\u0026quot;Mostrem els elements ORDENATS:\u0026quot;); for (int i=0; i\u0026lt;alumnes.size(); i++){ System.out.println(alumnes.get(i) + \u0026quot; \u0026quot;); } System.out.println(); System.out.println(); //Eliminem i recorregut System.out.println(\u0026quot;Eliminem l'element amb index 1:\u0026quot;); alumnes.remove(1); System.out.println(); for (Alumne alumne : alumnes){ System.out.println(alumne); } } }  En aquesta pàgina trobareu uns quants exemples més d\u0026rsquo;ús d\u0026rsquo;ArrayList: ArrayList con ejemplos\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/4cadenescaracters/1operacionsregulars/",
	"title": "Operacions Regulars",
	"tags": [],
	"description": "",
	"content": " Una expressió regular (regex) és la representació d\u0026rsquo;un patró alhora de buscar una seqüència de caràcters en un text.\n El patró de cerca pot anar des d\u0026rsquo;un caràcter, un string fixat o una expressió complexa de diferents caràcters especials.\nL\u0026rsquo;avaluació d\u0026rsquo;un patró o d\u0026rsquo;una expressió regex sempre serà d\u0026rsquo;esquerra a dreta. Pot ser que es trobi una ocurrència com a resultat, que no en trobi cap o que en trobi més d\u0026rsquo;una.\nCom aplicar-ho des de Java Ens podria interessar que:\n Si un text complert s\u0026rsquo;identifica amb un patró fixat, en aquest cas usarem Pattern.matches(regex, string); -\u0026gt; Retorna un booleà. Si una part del text compleix el patró, o si hi ha més d\u0026rsquo;una ocurrència que compleixi amb el patró fixat, en aquest cas usarem Pattern.compile(regex).matcher(string).find()  Un exemple de com podríem trobar quines paraules existeixen dins un text:\nimport java.util.regex.Pattern; import java.util.regex.Matcher; public class Main { public static void main(String[] args) { Pattern myPattern = Pattern.compile(\u0026quot;\\\\w+\u0026quot;); Matcher myMatcher = myPattern.matcher(\u0026quot;Hola Mon!\u0026quot;); while (myMatcher.find()) { System.out.println(\u0026quot;Trobat: \u0026quot; + myMatcher.group() + \u0026quot; a: \u0026quot; + myMatcher.start() + \u0026quot;,\u0026quot; + myMatcher.end()); } } }  Com es pot observar en l\u0026rsquo;exemple anterior Pattern.compile(\u0026quot;\\\\w+\u0026quot;) defineix el patró de cerca en el qual s\u0026rsquo;identifiquen totes aquelles seqüències de caràcters que són Words, \u0026ldquo;\\w+\u0026rdquo; busca seqüències de caràcters dins el text que coincideixi amb el patró [a-zA-Z_0-9]+.\nUn cop definit el Pattern el que fem és cridar la funció matcher que s\u0026rsquo;encarrega d\u0026rsquo;enllaçar el patró amb el text on estic buscant i el resultat queda en un objecte Matcher que ja puc iterar si és el cas (find/group).\nQuan la totalitat del text encaixa amb el patró utilitzaríem la funció matches de Pattern:\nPattern.matches(PATRO_DEFINIT, TEXT_A_BUSCAR); //Retorna True/False Pattern.matches(\u0026quot;\\\\d{5}\u0026quot;, \u0026quot;56745\u0026quot;); //TRUE Pattern.matches(\u0026quot;\\\\d{5}\u0026quot;, \u0026quot;56745d\u0026quot;); //FALSE  Per veure la diferència entre Pattern.matches() o Pattern.compile().matcher().find(). En el següent exemple, si busquem amb el mateix patró en el mateix text, observem com el primer cas ens retorna TRUE mentre que el segon ens retorna FALSE, ja que el patró encaixa amb una subcadena del text, no en la seva totalitat.\nPattern.compile(\u0026quot;HOLA\u0026quot;).matcher(\u0026quot;HOLA MON!\u0026quot;).find() //True Pattern.matches(\u0026quot;HOLA\u0026quot;, \u0026quot;HOLA MON!\u0026quot;); //False  En la pròpia pàgina de la classe Pattern de l\u0026rsquo;API de Java Oracle observareu quins són els caràcters especials i com es poden conformar diferents tipus de patrons java.util.regex.Pattern.\n Exemples d\u0026rsquo;ús Saber si una data està en el format correcte.\nString literalMonthRegexp = \u0026quot;\\\\d{1,2}/(?i)(gener|febrer|març|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre)/\\\\d{4}\u0026quot;; //TRUE System.out.println(Pattern.matches(literalMonthRegexp, \u0026quot;15/maig/2024\u0026quot;)); System.out.println(Pattern.matches(literalMonthRegexp, \u0026quot;8/abril/2021\u0026quot;)); System.out.println(Pattern.matches(literalMonthRegexp, \u0026quot;7/juny/2023\u0026quot;)); //FALSE System.out.println(Pattern.matches(literalMonthRegexp, \u0026quot;11/abc/2024\u0026quot;)); System.out.println(Pattern.matches(literalMonthRegexp, \u0026quot;11//2024\u0026quot;)); System.out.println(Pattern.matches(literalMonthRegexp, \u0026quot;7/juny/2023joan\u0026quot;));  Validar que un dni contingui 8 nombres i una lletra de DNI.\nString dniRegexp = \u0026quot;\\\\d{8}[A-HJ-NP-TV-Z]\u0026quot;; System.out.println(Pattern.matches(dniRegexp, \u0026quot;56453453C\u0026quot;)); //TRUE System.out.println(Pattern.matches(dniRegexp, \u0026quot;01234567U\u0026quot;)); // FALSE, U no vàlida System.out.println(Pattern.matches(dniRegexp, \u0026quot;0123567X\u0026quot;)); // FALSE no conté 8 dígits  Validar el format d\u0026rsquo;un email\nString entrada = \u0026quot;\u0026lt;p\u0026gt;malvarez@iespoblenou.org\u0026lt;/p\u0026gt;\u0026lt;br\u0026gt;\\n\u0026quot;; Pattern limpiar = Pattern .compile(\u0026quot;([a-zA-Z0-9.!#$%\u0026amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\\\.[a-zA-Z0-9-]+)*)\u0026quot;); Matcher buscar = limpiar.matcher(entrada); while (buscar.find()) System.out.println(buscar.group(1));  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/zzz_gesti%C3%B3-bbddor/1.preparedstatement/",
	"title": "PreparedStatement",
	"tags": [],
	"description": "",
	"content": "Si una mateixa consulta s’ha d’executar diverses vegades, és millor usar PreparedStatement com a alternativa a Statement, ja que la instrucció SQL es manté precompilada i això la fa més eficient. A més, permet l’ús de paràmetres dins de la instrucció i asignar-los en temps d’execució, cosa que protegeix la consulta de possibles SQLInjection.\nEls paràmetres de la consulta s’indiquen amb el signe ‘?’. I l’assignació es fa mitjançant el mètode de PreparedStatement adequat al tipus de dada (setInt, setString, etc) i el número de paràmetre al que assignar el valor dins de la consulta.\npublic void seleccionaAlbum(int idAlbum) { Statement stmt = null; try { String query = \u0026quot;SELECT * FROM Album WHERE AlbumId = ?\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setInt(1,idAlbum); ResultSet rs = ps.executeQuery(); while ( rs.next() ) { int albumId = rs.getInt(\u0026quot;AlbumId\u0026quot;); String title = rs.getString(\u0026quot;Title\u0026quot;); int artistId = rs.getInt(\u0026quot;ArtistId\u0026quot;); System.out.println( \u0026quot;albumId : \u0026quot; + albumId ); System.out.println( \u0026quot;title : \u0026quot; + title ); System.out.println( \u0026quot;artistId : \u0026quot; + artistId ); System.out.println(); } rs.close(); ps.close(); } catch ( Exception e ) { System.err.println( e.getClass().getName() + \u0026quot;: \u0026quot; + e.getMessage() ); System.exit(0); } System.out.println(\u0026quot;Operation done successfully\u0026quot;); }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/4tipusdades/1primerprograma/",
	"title": "Primer programa",
	"tags": [],
	"description": "",
	"content": "Primer programa public class Main { public static void main(String[] args) { System.out.println(\u0026quot;Hello world!\u0026quot;); } }  En qualsevol llenguatge de programació, el primer programa que es veu és l\u0026rsquo;Hola Mon, aquest programa l\u0026rsquo;únic que fa és imprimir per pantalla un missatge, en aquest cas \u0026ldquo;Hello world!\u0026rdquo;.\nTot el codi que escrivim estarà encapsulat dins una classe Main public class Main, i dins una funció main public static void main(String []args). Les instruccions que escrivim han d\u0026rsquo;anar contingudes dins els caràcters { } de la funció.\nEn aquest cas, una manera senzilla d\u0026rsquo;escriure per pantalla un text és utilitzant la instrucció: System.out.println(\u0026quot;Hello world!\u0026quot;); Tot el que estigui contingut dins \u0026quot;\u0026quot; serà el text que es veurà per pantalla. Java tracta el tipus de text com a cadena de caràcters tot el que vagi contingut entre \u0026ldquo;\u0026rdquo;.\nQuan executem un programa de Java, el que farà la màquina virtual de Java, la JVM, és buscar una funció que es digui public static void main(String []args) i començarà a executar totes les instruccions que estiguin dins.\nSi ara volguéssim executar aquest programa el guardaríem en un fitxer que s\u0026rsquo;anomeni IGUAL que el nom de la classe, en el nostre exemple s\u0026rsquo;ha de dir Main.java. L\u0026rsquo;extensió dels fitxers font que escriurem han d\u0026rsquo;acabar en .java.\nA continuació en la línea de comandes realitzarem la compilació del programa utilitzant l\u0026rsquo;eina del JDK javac. En el procés de compilació s\u0026rsquo;analitza que el nostre programa compleix amb les regles sintàctiques i semàntiques d\u0026rsquo;acord amb el llenguatge Java, si hi hagués algun error s\u0026rsquo;informaria del mateix per línea de comandes. Si tot ha anat bé s\u0026rsquo;ha generat un Main.class (L\u0026rsquo;objecte de bytecode generat amb el nostre sistema).Aquest és el document binari que Java pot utilitzar usant l\u0026rsquo;eina del JDK java.\n   Procés de compilació i execució:            En el següent exemple m\u0026rsquo;he deixat el \u0026ldquo;;\u0026rdquo; final de l\u0026rsquo;expressió i apareix el següent error al compilar:         "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/4cadenescaracters/2stringbuilder/",
	"title": "StringBuilder",
	"tags": [],
	"description": "",
	"content": "Com s\u0026rsquo;ha comentat anteriorment la classe String és una classe immutable, això des del punt de vista de l\u0026rsquo;eficiència a l\u0026rsquo;hora d\u0026rsquo;operar i manipular les cadenes de caràcters es planteja com un gran problema. Cada cop que manipulem una referència de String el que acaba succeïnt és que es crea una nova instància de String en la memòria Heap, no es modifica l\u0026rsquo;anterior, sinó que estem creant objectes nous per a cada modificació que realitzem, la qual cosa és mooolt costós en temps i en memòria.\nPer això existeix les classes StringBuilder, i StringBuffer. Són classes que sí són mutables, per tant Sí permeten la modificació d\u0026rsquo;una cadena de caràcters sense perdre eficència, ja que no creen noves instàncies sinó que manipulen l\u0026rsquo;objecte actual.\nLa diferència entre StringBuilder i StringBuffer està en que StringBuffer té els mètodes sincronitzats i, degut a això, és una mica més ineficient. A mesura que desenvolupeu codi us adonareu que diferents programes (fils d\u0026rsquo;execució, threads) interactuaran de forma síncrona, per tal d\u0026rsquo;evitar problemes de sincronització de recursos compartits us serà necessari usar eines que evitin aquest problema, com per exemple StringBuffer, de moment, i donat que els mètodes són els mateixos, utilitzarem StringBuilder.\nCom ja vam veure en l\u0026rsquo;AEA anterior, els objectes String es guarden en el Constant String Pool, que és un repositori de valors de Strings. La utilitat d\u0026rsquo;aquest Pool és que si creem altres Strings amb el mateix valor, no es crea un objecte nou en el Heap sinó que es \u0026ldquo;reutilitza\u0026rdquo; el valor que ja tenim en el Pool (recordem que String és immutable). Tant StringBuilder com StringBuffer emmagatzemen directament els objectes en el Heap.\nInicialització Per tal d\u0026rsquo;inicialitzar un StringBuilder usarem aquestes tres formes, depenent de cada cas:\n//Construeix un StringBuilder buit i amb una capacitat de 16 caràcters StringBuilder s = new StringBuilder(); //Construeix un StringBuilder buit i amb una capacitat de 25 caràcters StringBuilder s = new StringBuilder(25); //Construeix un StringBuilder en base a l'String passat com a paràmetre StringBuilder s = new StringBuilder(\u0026quot;Hola Món!\u0026quot;);  Funcionalitats més habituals El conjunt de funcionalitats complert el trobareu a Oracle a l\u0026rsquo;apartat de StringBuilder.\nPasso a detallar aquelles funcionalitats més significatives, moltes funcionalitats són les mateixes que la classe String (charAt, indexOf, substring\u0026hellip;):\nappend. Aquesta serà la funcionalitat més utilitzada, serveix per concatenar al final del StringBuilder una cadena de text determinada\nfor(int i = 0; i \u0026lt; 1000; i++) stringBuilder.append(i);  length(). Caràcters amb informació útil en StringBuilder.\nstringBuilder.length();  capacity(). Inicialment StringBuilder reserva una capacitat (espai per allotjar-hi caràcters). Si la informació que manipulem supera aquesta capacitat el que fa StringBuilder és crear una nova instància amb la capacitat necessària per encabir la informació sol·licitada.\nstringBuilder.capacity();  toString(). Converteix un StringBuilder a un String. Si volem mostrar el valor d\u0026rsquo;un StringBuilder serà necessari fer aquesta conversió per imprimir-lo per línia de comandes.\nSystem.out.println(stringBuilder.toString());  Criteris per utilitzar String o StringBuilder/StringBuffer  Si el valor que assignem a les variables String no ha de variar (o varia poques vegades) utilitzarem la classe String. Si el valor que assignem a les variables String varia un gran nombre de vegades i estem en un únic fil d\u0026rsquo;execució s\u0026rsquo;utilitzarà StringBuilder ja que és més eficient. Si el valor que assignem a les variables String varia un gran nombre de vegades i estem en multitasca s\u0026rsquo;utilitzarà StringBuffer ja que és thread safe i per tant ens assegura un bon ús compartit de les dades entre els diferents fils d\u0026rsquo;execució.  Exemple d\u0026rsquo;ús i comparativa de temps Posem per cas el següent exemple: \u0026ldquo;Donada una cadena, crea una altra cadena igual a la primera sense espais en blanc.\u0026rdquo; Es recomana provar el codi amb tamanys de text d\u0026rsquo;entrada MOOOLT diferents, d\u0026rsquo;aquesta forma permet apreciar les diferències alhora de manipular un String o un StringBuilder.\n//Opcio1: fent ús de replace() System.out.println(\u0026quot;Introdueix una cadena: \u0026quot;); String cadena = sc.nextLine(); long startTime = System.currentTimeMillis(); System.out.println(cadena.replace(\u0026quot; \u0026quot;, \u0026quot;\u0026quot;)); long finalTime = System.currentTimeMillis(); System.out.println(\u0026quot;AMB REPLACE\u0026quot;); System.out.println(\u0026quot;Temps en trobar solucio: \u0026quot;+(finalTime-startTime)); System.out.println(); //Opcio2 sense fer ús de replace() String paraules[] = cadena.split(\u0026quot; \u0026quot;); String solucio = \u0026quot;\u0026quot;; startTime = System.currentTimeMillis(); for(String paraula : paraules){ //solucio = solucio + paraula solucio += paraula; } finalTime = System.currentTimeMillis(); System.out.println(solucio); System.out.println(\u0026quot;STRING\u0026quot;); System.out.println(\u0026quot;Temps en trobar solucio: \u0026quot;+(finalTime-startTime)); System.out.println(); //Opcio3 amb StringBuilder String paraulesBuilder[] = cadena.split(\u0026quot; \u0026quot;); StringBuilder solucioBuilder = new StringBuilder(); startTime = System.currentTimeMillis(); for(String paraula : paraules){ solucioBuilder.append(paraula); } finalTime = System.currentTimeMillis(); System.out.println(solucioBuilder.toString()); System.out.println(\u0026quot;STRINGBUILDER\u0026quot;); System.out.println(\u0026quot;Temps en trobar solucio: \u0026quot;+(System.currentTimeMillis()-startTime));  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/3manipulaciofitxers/1text/",
	"title": "Text",
	"tags": [],
	"description": "",
	"content": "L/E caràcter a caràcter (de fitxers de text plà) FileReader: http://docs.oracle.com/javase/8/docs/api/java/io/FileReader.html\nFileWriter: http://docs.oracle.com/javase/8/docs/api/java/io/FileWriter.html\nL/E per caràcters amb buffer (més eficient) BufferedReader: http://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html\nBufferedWriter: http://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html\nLectura d\u0026rsquo;un fitxer de text Lectura d\u0026rsquo;un fitxer utilitzant FileReader i BufferedReader. Observeu que calculem el temps en realitzat el mateix amb dos fitxers diferents. Com que utilitzant FileReader l\u0026rsquo;accés de Lectura al fitxer és caràcter a caràcter és molt més lent que si podem llegir les dades del buffer amb BufferReader.\npackage exemples; import java.io.BufferedReader; import java.io.FileReader; public class LTextPla { public static void main(String[] args) { long time_start, time_end; time_start = System.currentTimeMillis(); System.out.print(llegirFitxerTextPla(\u0026quot;f1.txt\u0026quot;)); time_end = System.currentTimeMillis(); System.out.println(\u0026quot;the task has taken \u0026quot;+ ( time_end - time_start ) +\u0026quot; milliseconds\u0026quot;); System.out.println(); System.out.println(); time_start = System.currentTimeMillis(); System.out.print(llegirFitxerTextPlaBuffered(\u0026quot;f1.txt\u0026quot;)); time_end = System.currentTimeMillis(); System.out.println(\u0026quot;the task has taken \u0026quot;+ ( time_end - time_start ) +\u0026quot; milliseconds\u0026quot;); } /** * Llegeix el contingut d'un fitxer de text plà caràcter a caràcter. * @param path Path del fitxer de text plà. * @return Contingut del fitxer. */ public static String llegirFitxerTextPla(String path) { try { String res = \u0026quot;\u0026quot;; FileReader fr = new FileReader(path); int ch = fr.read(); while (ch != -1) { res = res + (char)ch; ch = fr.read(); } fr.close(); return res; } catch (Exception e) { System.out.println(e.getMessage()); return null; } } /** * Llegeix el contingut d'un fitxer de text plà accedint amb buffer. * @param path Path del fitxer de text plà. * @return Contingut del fitxer. */ public static String llegirFitxerTextPlaBuffered(String path) { try { String res = \u0026quot;\u0026quot;; FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr); String linia = br.readLine(); while (linia != null) { res = res + linia + \u0026quot;\\n\u0026quot;; //readLine() no inclou els salts de línia. linia = br.readLine(); } br.close(); return res; } catch (Exception e) { System.out.println(e.getMessage()); return null; } } }  Escriptura d\u0026rsquo;un fitxer de text De nou tenim un exemple amb FileWriter i BufferedFileWriter. A destacar d\u0026rsquo;aquí la creació del FileWriter, observeu que té un segon paràmetre booleà, això ens permet començar l\u0026rsquo;escriptura a l\u0026rsquo;inici del fitxer (truncar el fitxer) amb l\u0026rsquo;opció false, mentre que true ens permet afegir el contingut al final del fitxer.\npackage exemples; import java.io.BufferedWriter; import java.io.FileWriter; public class ETextPla { public static void main(String[] args) { EscriureFitxerTextPla(\u0026quot;f2.txt\u0026quot;, \u0026quot;\\nHola\u0026quot;); EscriureFitxerTextPlaBuffered(\u0026quot;f3.txt\u0026quot;, \u0026quot;Hola amb buffer.\\n\u0026quot;); System.out.println(\u0026quot;Done.\u0026quot;); } /** * Escriu un String a un fitxer de text plà. * @param path Path del fitxer de text plà. * @param text Text a escriure. */ public static void EscriureFitxerTextPla(String path, String text) { try { FileWriter fw = new FileWriter(path, true); // true = afegir al fitxer fw.write(text); fw.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } /** * Llegeix el contingut d'un fitxer de text plà accedint amb buffer. * @param path Path del fitxer de text plà. * @param text Text a escriure. */ public static void EscriureFitxerTextPlaBuffered(String path, String text) { try { FileWriter fw = new FileWriter(path, false); // false = truncar el fitxer BufferedWriter bw = new BufferedWriter(fw); bw.write(text); bw.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/3classemetodes/1visibilitat/",
	"title": "Visibilitat",
	"tags": [],
	"description": "",
	"content": "Variables estàtiques de classe Les variables estàtiques de classe són aquelles variables tals que la seva disponibilitat és total, és a dir, es poden utilitzar, actualitzant-les o no, des del programa principal i des de tots els subprogrames. No és aconsellable l\u0026rsquo;ús de variables globals. Les definim just després de la declaració de la classe, per ex:\npublic class Estudiant{ public static int nombreEstudiantsActius; ...  Una variable estàtica de classe és un valor que sempre estarà en memòria i que és ÚNIC per tots els objectes d\u0026rsquo;aquella classe, això vol dir que no té sentit guardar informació d\u0026rsquo;un objecte determinat ja que és d\u0026rsquo;ús compartit per tots els objectes. És una variable que resideix SEMPRE en memòria s\u0026rsquo;hagi creat o no cap objecte d\u0026rsquo;aquella classe i s\u0026rsquo;utilitzi o no aquesta variable ocupa sempre memòria.\nVariables locals Una variable local és aquella que està declarada dins un bloc de codi (while, funció, etc.). L’àmbit d’ús de les variables locals és el propi bloc de codi on estigui declarada. L’àmbit d’existència d’una variable és la part de la classe en què la variable pot ser referenciada o s’hi pot accedir pel seu nom.\nEn Java, quan declarem una variable, aquesta és accessible només dins l\u0026rsquo;estructura on és declarada. En el cas dels arguments, només són visibles en el mètode en el qual s\u0026rsquo;usen. Posem un exemple:\npublic double m2km (double m) { double km; km = m / 1000; return km; }  En aquest cas les variables m i km només són accessibles dins del mètode m2km.\nUn altre exemple:\npublic int sumElements (int[] array) { int sum = 0; for(int i = 0; i \u0026lt; array.length; i++) sum = sum + array[i]; return sum; }  Les variables sum i array només són accessibles dins del mètode sumElements, però la variable i només és visible dins l\u0026rsquo;estructura for.\nÀmbits de visibilitat Fins el moment hem observat com els atributs i mètodes públics són accessibles des de fora de la pròpia classe i els que són privats són només accessibles desde dins la pròpia classe.\nAmb l\u0026rsquo;herència, que veurem a posteriori, apareix la visibilitat protected, que permet tenir visibilitat d\u0026rsquo;atributs i mètodes situats en:\n la mateixa classe les seves subclasses altres classes del mateix package  Com s\u0026rsquo;observa existeix també l\u0026rsquo;opció default quan no indiquem cap atribut de visibilitat (public, private, etc.), les classes declarades com a default tenen accés a totes les classes del propi package.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/2arrayunidimensional/",
	"title": "Arrays Unidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays unidimensional: és una estructura de dades que conté un conjunt de dades del mateix tipus.\n La biblioteca de classes de Java inclou una classe auxiliar que s\u0026rsquo;anomena java.util.Arrays i conté funcions molt útils per utilitzar amb arrays: Java Oracle Classe Arrays\nPropietats\n Els arrays s\u0026rsquo;utilitzen com a contenedors per guardar dades relacionades (enlloc de declarar variables per separat per cada un dels elements de l\u0026rsquo;array). Totes les dades incluïdes a l\u0026rsquo;array són del mateix tipus. Es poden crear arrays d\u0026rsquo;enters (int, long), de reals(float, double), però en un mateix array no es poden mesclar dades de tipus diferents. En els arrays estàtics el tamany s\u0026rsquo;estableix quan es crea l\u0026rsquo;array (amb l\u0026rsquo;operador new, igual que qualsevol altre objecte). Al ser un conjunt d\u0026rsquo;elements ordenats, a cada element de l\u0026rsquo;array s\u0026rsquo;hi accedirà a través de la posició que ocupa dins el conjunt.  Exemple Per exemple podríem necessitar les edats d\u0026rsquo;una classe per efectuar-ne un tractament especial. Fins ara el que podíem fer és declarar tantes variables enteres com alumnes hi hagi per tal de guardar-ne l\u0026rsquo;edat:\nint edatAlumne1 = 29; int edatAlumne2 = 26; int edatAlumne3 = 18; ... int edatAlumne30 = 28;  Com podeu observar, si escaléssim el problema anterior i enlloc de 30 necessitéssim les edats dels 700 estudiants de l\u0026rsquo;institut, la declaració de variables seria una feina feixuga i amb un alt índex d\u0026rsquo;equivocar-nos, a més no permetria mantenir i modificar el programa de forma àgil. Per això hi ha les estructures de dades d\u0026rsquo;un mateix tipus. Una manera de guardar 700 edats dins una mateixa estructura seria aquesta:\n//Declarem una posició de memòria on hi ha una referència a un array int[] edatsAlumnes; //Aquest array és estàtic, per això abans d'usar-lo ens reservem en memòria el nombre d'enters que necessitem edatsAlumnes = new int[700]; //Omplim les edats dels alumnes for(int i = 0; i \u0026lt; edatsAlumnes.length; i++) edatsAlumnes[i] = sc.nextInt();  Declaració array En les línies anteriors hem observat que per crear un objecte array, és necessari fer servir la paraula reservada new, amb això el que fem és reservar en memòria l\u0026rsquo;espai necessari per allotjar la informació. En el següent exemple creem un array estàtic que l\u0026rsquo;anomeno arrayEstatic de 12 posicions.\nint[] arrayEstatic = new int[12]; //També es podria fer de la següent manera: int arrayEstatic[] = new int[12];  Fixeu-vos que en el primer exemple he fet la declaració i la reserva d\u0026rsquo;espais dels enters en instruccions separades, en canvi en aquest últim exemple ho he fet tot junt en una única línia.\nPer accedir a la posició enèssima de l\u0026rsquo;array ho puc fer de la següent manera arrayEstatic[n].\nEls Indexs d\u0026rsquo;un array comencen en la posició 0, no en la 1. L\u0026rsquo;últim element de l\u0026rsquo;array es troba a la posició llargària de l\u0026rsquo;array - 1. Així doncs en l\u0026rsquo;exemple anterior el primer enter de l\u0026rsquo;arrayEstatic es troba en la posició arrayEstatic[0] mentre que l\u0026rsquo;últim en la posició arrayEstatic[11]. Hem de tenir en compte que l'índex no pot ser un valor negatiu, i que per exemple podria ser un càlcul numèric o fent ús de variables arrayEstatic[i + 1]\n És important entendre que un cop declaro un arrayEstatic, es reserva en memòria espai per guardar el tipus de dades * Tamany de l'array. En l\u0026rsquo;exemple anterior es demana al programa que ens reservi espai per a 12 enters consecutius. Aquests enters per defecte s\u0026rsquo;inicialitzen a 0 (si fossin booleans a false).\nint index = 4; int array[index + 1]++;  En aquest exemple s\u0026rsquo;observa com inicialitzem un índex a 4, s\u0026rsquo;accedeix a l\u0026rsquo;element amb índex 5 de l\u0026rsquo;array, és la posició 6 (recordeu que el 0 és la primera posició de l\u0026rsquo;array) i en l\u0026rsquo;enter de la posició 6 n\u0026rsquo;augmentem el valor en una unitat.\nLongitud Al ser una estructura estàtica la longitud de l\u0026rsquo;array no es pot variar i es defineix quan es crea (amb el new). Per tal d\u0026rsquo;obtenir el seu valor en Java utilitzarem la propietat length de la classe Arrays:\nSystem.out.println(\u0026quot;La longitud de l'array és \u0026quot; + array.length);  Una altra inicialització Una altra manera d\u0026rsquo;inicialitzar un array és directament definint els seus elements:\nint[] array2 = {10, 20, 54, -2, 76 };  Si a aquest array2 imprimissim el seu valor de array2.length el resultat seria 5. De forma que s\u0026rsquo;hauria declarat i reservat la memòria directament.\nRecorregut i manipulació d\u0026rsquo;arrays Normalment ens trobarem amb problemes on cal accedir a arrays i efectuar-ne un tractament determinat. Per exemple, ens podríem trobar el següent problema:\n Com ho faríem per guardar en un array els 10 primers números parells?\n //declaració i creació de l'array\tint[] llista = new int[10]; //modificació el valor dels elements de l'array for(int i=0; i\u0026lt;llista.length; i++) { llista[i] = i*2; }\t//Imprimim els valors 0 2 4 6 8 10 12 14 16 18 for(int i=0; i\u0026lt;llista.length; i++) { System.out.print(llista[i] + \u0026quot; \u0026quot;); }  Es pot observar com mitjançant l\u0026rsquo;índex i s\u0026rsquo;accedeix a tots els elements de l\u0026rsquo;array i se\u0026rsquo;n va modificant el seu valor.\nOrdenació arrays Una altra funcionalitat corrent és l\u0026rsquo;ordenació d' arrays. En Java existeix una funció que ordena els elements d\u0026rsquo;un array, més endavant l\u0026rsquo;estudiarem amb deteniment.\nArrays.sort(vector);  Existeixen molts algorismes diferents capaços d\u0026rsquo;ordenar els elements d\u0026rsquo;un array, tots ells tenen la seva lògica i obeeixen a casuïstiques diferents, i per tant també tenen costos de còmput diferent. En la següent web podrem observar simulacions de diferents algorismes en un llenguatge de pseudocodi i com evoluciona cada array fins a la seva ordenació: Visualgo\nCerca d\u0026rsquo;un element dins l\u0026rsquo;array La cerca d\u0026rsquo;un element dins un array és un problema típic. No és el mateix tenir l\u0026rsquo;array ordenat que l\u0026rsquo;array desordenat:\n Si l\u0026rsquo;array està desordenat farem un recorregut buscant l\u0026rsquo;element, si no el troba s\u0026rsquo;arriba al final de l\u0026rsquo;array, si el troba sortim de l\u0026rsquo;array abans de la seva finalització. Si l\u0026rsquo;array està ordenat, a diferència de l\u0026rsquo;anterior, no cal que busquem fins al final de l\u0026rsquo;array, un cop \u0026ldquo;em passi\u0026rdquo; de l\u0026rsquo;element que estic buscant ja no cal que continuï, és una manera d\u0026rsquo;optimitzar la cerca.  Cerca en array desordenat:\ndouble[] array = {2, 5.5, 9.1, 1, 2.9, 8, 5.5, 55.4, 2.6, 5.45, 7}; //Definim variable booleana per saber si s'ha trobat el valor var trobat = false; //Índex var i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length) \u0026amp;\u0026amp; (!trobat)) { if (array[i] == 8) { trobat = true; } i = i + 1; } //S’ha trobat? System.out.println ( trobat ? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;);  Una altra manera de fer el mateix problema però utilitzant la instrucció de salt break enlloc d\u0026rsquo;un booleà.\ndouble[] array = {2, 5.5, 9.1, 1, 2.9, 8, 5.5, 55.4, 2.6, 5.45, 7}; //Índex var i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length)) { if (array[i] == 8) { break; } i = i + 1; } //S’ha trobat? System.out.println( i \u0026lt; array.length ? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;);  Cerca en array ordenat:\ndouble[] array = {2, 5.5, 8, 9.1, 10.4, 12.9, 18, 25.5, 55.4}; //Definim variable booleana per saber si s'ha trobat el valor boolean trobat = false; //Definim variable booleana per saber si ens hem passat ja de l'element boolean passat=false; //Índex int i = 0; //Realitzem el recorregut, mentre no s’arriba al final i no es trobi un 1 while ((i \u0026lt; array.length) \u0026amp;\u0026amp; (!trobat) \u0026amp;\u0026amp; (!passat)) { if (array[i] == 8) { trobat = true; } if (array[i] \u0026gt; 8) { passat = true; } i = i + 1; } //S’ha trobat? String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Bucle for millorat per arrays Per tal d\u0026rsquo;efectuar el recorregut en un array java ens permet aquesta expressió reduïda de bucles for foreach. Per exemple, els bucles següents són equivalents:\nfor(int i=0; i\u0026lt;array.length; i++) { int valor = array[i]; System.out.println(valor); } for(int valor: array) { System.out.println(valor); }  La versió adaptada del bucle for es pot fer servir amb qualsevol tipus d\u0026rsquo;array (String, int, boolean, etc.).\nAltres mètodes útils de la classe java.util.Arrays Arrays.sort(array); // Ordena els elements Arrays.equals(array1, array2); // Comprova si els dos arrays són iguals Arrays.fill(array, val) //Omple el vector v amb el valor \u0026quot;val\u0026quot; Arrays.toString(array) // Retorna una cadena que representa el contingut del vector Arrays.binarySearch(array, k) // Busca el valor k dins del vector array (que prèviament ha estat ordenat)  Exemples  Exemple de diferents maneres per omplir de valors un array i imprimir-lo per línia de comandes:  //Crear Array int primerArray[] = new int[7]; //Omplir de valors amb for i després amb while for(int i=0; i \u0026lt; primerArray.length; i++){ primerArray[i] = sc.nextInt(); } var i=0; while(i \u0026lt; primerArray.length){ primerArray[i] = sc.nextInt(); i++; } //Mostrar valors amb toString amb bucle for i bucle for millorat Arrays.toString(primerArray); for( i=0; i \u0026lt; primerArray.length; i++){ System.out.println(primerArray[i]); } for( int valor : primerArray){ System.out.println(valor); } //Ús de la funció fill de la classe Arrays que consisteix en omplir totes les posicions d'un array amb el mateix valor Arrays.fill(primerArray,7); for(i=0; i \u0026lt; primerArray.length; i++){ primerArray[i] = 7; }  Còpia d\u0026rsquo;arrays  int[] llista = {1,2,3,4}; //llista i llistaCopia apunten al mateix array ja que són referències int[] llistaCopia = llista; //Fent ús de clone. En aquest cas llista i llistaCopia SON DOS ARRAYS IGUALS I INDEPENDENTS llistaCopia = llista.clone(); //còpia manual dels elements int[] llistaCopia = new int[4]; for(i=0; i \u0026lt; llista.length; i++){ llistaCopia[i] = llista[i]; } System.out.println(\u0026quot;Contingut de l'array 'llista'\u0026quot;); for(int valor : llista) System.out.println(valor); System.out.println(\u0026quot;Contingut de l'array 'llistaCopia'\u0026quot;); for(int valor : llistaCopia) System.out.println(valor);  Cerca d\u0026rsquo;un element dins un array (exemple del màxim)  primerArray = new int[]{-1, -2, -3, -4}; var max = 0; for(i=0; i \u0026lt; primerArray.length; i++){ if(max\u0026lt;primerArray[i]) max = primerArray[i]; }  Sumar els elements d\u0026rsquo;un array valor a valor i guardar-lo en un altre array  int vector1[] = new int[10]; int vector2[] = new int[10]; //falta introduir els valors en vector1 i vector2 int suma[] = new int[10]; for( i=0; i\u0026lt;suma.length;i++){ suma[i] = vector1[i] + vector2[i]; }  Cerca dicotòmica  //Tamany vector System.out.println(\u0026quot;De quants elements vols el vector?\u0026quot;); var llargada = sc.nextInt(); //Creem i posem elements aleatoris entre 0 i 100 dins el vector i l'ordenem int [] vector = new int[llargada]; for(int i=0; i\u0026lt;llargada;i++) vector[i] = (int)(Math.random()*100); Arrays.sort(vector); //Imprimim vector System.out.println(Arrays.toString(vector)); //Quin element vols buscar? System.out.println(\u0026quot;Quin element vols buscar?\u0026quot;); var nombreBuscat = sc.nextInt(); //inicialitzem index inferior i superior i declarem element central var elementCentral; var inferior=0; var superior=llargada-1; //inicialment no s'ha trobat l'element var trobat = false; var iteracions = 0; //mentre element inferior no rebassi el superior continuem explorant while(inferior\u0026lt;=superior \u0026amp;\u0026amp; !trobat){ //Augmentem nombre iteracions iteracions++; //busquem quin és l'element central elementCentral=(superior+inferior)/2; //Imprimim l'estat actual System.out.println(STR.\u0026quot;Iteracio: \\{iteracions} Inferior: \\{inferior} Superior: \\{superior} Element Central: \\{vector[elementCentral]} A buscar: \\{nombreBuscat}\u0026quot;); for(int i=inferior; i \u0026lt;= superior; i++) System.out.print(vector[i]+\u0026quot; \u0026quot;); System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;\u0026quot;); //Si el trobem posem trobat a true per sortir del bucle i anunciem que l'hem trobat if(vector[elementCentral]==nombreBuscat){ trobat=true; System.out.println(\u0026quot;L'element \\{nombreBuscat} està dins l'array\u0026quot;); } //Sinó actualitzem index, caldrà actualitzar o bé el superior en cas que el nombre buscat sigui inferior a l'actual, o bé l'inferior en cas contrari. else if(nombreBuscat \u0026lt; vector[elementCentral] ){ superior=elementCentral-1; } else { inferior=elementCentral+1; } } //Si no el trobem ho anunciem if(!trobat)System.out.println(\u0026quot;L'element no es troba en el vector\u0026quot;); /** * Comparem amb... * CERCA LINEAL * **/ inferior=0; superior=llargada-1; //inicialment no s'ha trobat l'element trobat = false; iteracions = 0; //mentre element inferior no rebassi el superior continuem explorant while(inferior\u0026lt;=superior \u0026amp;\u0026amp; !trobat) { //Augmentem nombre iteracions iteracions++; //Imprimim l'estat actual System.out.println(STR.\u0026quot;Iteracio: \\{iteracions} Inferior: \\{inferior} Superior: \\{superior} Element Central: \\{vector[elementCentral]} A buscar: \\{nombreBuscat}\u0026quot;); for (int i = inferior; i \u0026lt;= superior; i++) System.out.print(vector[i] + \u0026quot; \u0026quot;); System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;\u0026quot;); //Si el trobem posem trobat a true per sortir del bucle i anunciem que l'hem trobat if (vector[inferior] == nombreBuscat) { trobat = true; System.out.println(\u0026quot;L'element \\{nombreBuscat} està dins l'array\u0026quot;); } //Miro el següent element inferior++; } //Si no el trobem ho anunciem if(!trobat)System.out.println(\u0026quot;L'element no es troba en el vector\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/2classesabstractes/",
	"title": "Classes abstractes i finals",
	"tags": [],
	"description": "",
	"content": "Classes abstractes Classes abstractes (Abstract class). Quan definim una classe abstracta indiquem a Java que NO VOLEM instanciar/crear objectes concrets d\u0026rsquo;aquesta classe. Segurament ens servirà com a template per tal d\u0026rsquo;adoptar un comportament comú i extendre-la a una sèrie de fills que SÍ tenen sentit. El mateix és aplicable als mètodes, un mètode abstract és només la signatura del mètode sense implementació i s\u0026rsquo;extendrà en les seves subclasses.\n public abstract class Vehicle { protected int preu=-1; public Vehicle(){} public int getPreu (int preu){ return preu; } public void setPreu (int preu){ this.preu += preu; } public abstract int factura(int dies); } public class Cotxe extends Vehicle{ protected int preu=25; public Cotxe(){ super(); } public int factura(int dies){ return dies * preu; } } public class Moto extends Vehicle{ protected int preu=10; public Moto(){ super(); } public int factura(int dies){ if(dies\u0026gt;10) return dies * preu; else return 0; } } public class Caravana extends Vehicle{ protected int preu=40; public Caravana(){ super(); } public int factura(int dies){ return (dies * preu) / 2; } } .... public static void main (String[] params){ Cotxe cotxe = new Cotxe(); Moto moto = new Moto(); Caravana caravana = new Caravana(); cotxe.factura(10); moto.factura(10); caravana.factura(10); ... } //També podria tenir public static void main (String[] params){ Vehicle cotxe = new Cotxe(); Vehicle moto = new Moto(); Vehicle caravana = new Caravana(); }  Amb l\u0026rsquo;exemple anterior, si modelitzem un parking, cada vehicle pagarà una factura diferent en funció al vehicle que tingui. Ens interessa tenir una classe principal Vehicle, la qual no tindrà implementació i que serveix per definir un mètode factura abstracte que hauran d\u0026rsquo;implementar-se en totes les subclasses. Volem aplicar diferent comportament en funció a cada vehicle per això definim el mètode de pagament factura(int dies) dins les subclasses. En aquest exemple Vehicle no tindria sentit com a instància de classe però sí que serveix per establir QUÈ han de tenir els Vehicles del nostre model implementat obligatòriament.\nEl mètode abstracte factura(int dies) de Vehicle no té implementació i obligatòriament cal implementar-lo en les classes concretes filles que tingui Vehicle. Això ens permet establir condicionants a la factura EN FUNCIÓ de cada Vehicle, per exemple si és una Moto i aparca menys de 10 dies no paga, si és una Caravana pagarà la meitat, etc.\nUna classe abstracta pot contenir mètodes concrets implementats, com getPreu o setPreu en l\u0026rsquo;exemple, ** i mètodes abstractes** com factura.\n El que ens indica que una classe sigui abstracta és que no podem crear objectes/instàncies d'aquesta classe. S\u0026rsquo;ha d\u0026rsquo;instanciar a partir dels seus fills. El que ens indica que un mètode sigui abstracte és que no té implementació definida. Els mètodes abstractes només tenen sentit dins de classes abstractes. Serveixen per indicar que tots els fills concrets han d\u0026rsquo;implementar aquest mètode.  Aquesta unificació de criteris fa que sigui molt fàcil extendre el model i incorporar de forma fàcil nous Vehicles: Camions, Bicicletes o Patinets, només ens cal pensar quins són els mètodes abstractes que necessitem tenir per incorporar i implementar-los, en el cas anterior només cal el mètode factura(). Molts cops es fa necessari tenir tots els vehicles dins un array per a que facin una determinada acció, posem per cas l\u0026rsquo;exemple anterior i fem que tots els vehicles paguin la factura de cop:\npublic static void main (String[] params){ Cotxe cotxe1 = new Cotxe(); Moto moto1 = new Moto(); Caravana caravana2 = new Caravana(); ArrayList\u0026lt;Vehicle\u0026gt; vehicles = new ArrayList(); vehicles.add(cotxe1); vehicles.add(moto1); vehicles.add(caravana2); for(Vehicle v : vehicles){ v.factura(10); System.out.println(\u0026quot;El vehicle \u0026quot;+ v.getClass()+\u0026quot; li toca pagar per 10 dies: \u0026quot; + v.factura(10)+\u0026quot; euros.\u0026quot;); } } ... }  Resumint:\n Una classe abstracta no s\u0026rsquo;instancia, sinó que només ho poden fer les seves subclasses i els anomenarem classes concretes. Una classe abstracta pot tenir mètodes abstractes i implementats dins la mateixa classe. Un mètode abstracte no té implementació i obliga que les subclasses l\u0026rsquo;implementin. Podríem tenir una classe abstracta amb tots els mètodes implementats, però en canvi, si un mètode és abstracte obliga que la classe també ho sigui. No podem tenir un mètode estàtic i abstracte ja que el podríem usar sense necessitat de crear un objecte, i ja sabem que un mètode abstracte no té implementació. Podríem tenir una jerarquia de classes abstractes. Una classe abstracta que a la vegada la subclasse sigui abstracta. L\u0026rsquo;únic requisit és que les classes concretes implementin TOTS els mètodes abstractes de totes les classes abstractes.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/5coleccions/2hashset/",
	"title": "Conjunt - HashSet",
	"tags": [],
	"description": "",
	"content": " HashSet: és un conjunt d\u0026rsquo;elements en els quals no hi trobem cap element repetit (Set) i que no existeix un ordre en l\u0026rsquo;inserció de nous elements.\n La definició de la classe ArrayList java.util.HashSet i de totes les seves funcionalitats la trobareu a: Java Oracle Classe HashSet\nConsiderem que un element està repetit si tenim dos objectes o1 i o2 iguals, comparant-los mitjançant l\u0026rsquo;operador o1.equals(o2). D\u0026rsquo;aquesta manera, si l\u0026rsquo;objecte a inserir en el conjunt estigués repetit, no ens deixaria inserir-lo i el mètode add retornaria false. Un conjunt pot contenir com a màxim un element null.\nEls objectes s\u0026rsquo;emmagatzemen en una taula de dispersió (hash). El cost de les operacions bàsiques (inserció, esborrat, recerca) es realitzen en temps constant sempre que els elements s\u0026rsquo;hagin dispersat de forma adequada. La iteració a través dels seus elements és més costosa, ja que necessitarà recórrer totes les entrades de la taula de dispersió, el que farà que el cost estigui en funció tant del nombre d\u0026rsquo;elements inserits en el conjunt com de el nombre d\u0026rsquo;entrades de la taula. L\u0026rsquo;ordre d\u0026rsquo;iteració pot ser diferent de l\u0026rsquo;ordre en què es van inserir els elements.\nDeclaració\nEn la declaració indicarem de quin tipus són els elements del Set \u0026lt;\u0026gt;. Per exemple per declarar un HashSet d\u0026rsquo;enters:\nHashSet\u0026lt;Integer\u0026gt; conjuntEnters = new HashSet();  Funcionalitats principals\nEn l\u0026rsquo;exemple s\u0026rsquo;observa la manipulació d\u0026rsquo;un HashSet primer per enters i després per un set d\u0026rsquo;objectes Alumne:\nimport java.util.*; public class ExHashSet { public static void main(String[] args) { // HashSet de String // Creem el HashSet HashSet\u0026lt;String\u0026gt; hS = new HashSet\u0026lt;String\u0026gt;(); // Afegim elements hS.add(\u0026quot;Element 9\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 7\u0026quot;); hS.add(\u0026quot;Element 4\u0026quot;); hS.add(\u0026quot;Element 5\u0026quot;); hS.add(\u0026quot;Element 6\u0026quot;); hS.add(\u0026quot;Element 3\u0026quot;); hS.add(\u0026quot;Element 8\u0026quot;); hS.add(\u0026quot;Element 1\u0026quot;); // Intentem afegir Elements repetits hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); hS.add(\u0026quot;Element 2\u0026quot;); if (!hS.add(\u0026quot;Element 2\u0026quot;)) System.out.println(\u0026quot;Element 2 nomes s'afegeix una sola vegada\u0026quot;); System.out.println(); // Recorregut usant la classe Iterator System.out.println(\u0026quot;Realitzem un recorregut mitjançant iterator\u0026quot;); Iterator\u0026lt;String\u0026gt; it = hS.iterator(); while (it.hasNext()) System.out.println((String)it.next()); System.out.println(); // Eliminar un element if (!hS.remove(\u0026quot;Element 25\u0026quot;)) System.out.println(\u0026quot;Si intento esborrar un objecte que no existeix em retorna false!!!\u0026quot;); System.out.println(); System.out.println(\u0026quot;Esborrem un element existent: Element 3, i mostrem com queda el HashSet\u0026quot;); hS.remove(\u0026quot;Element 3\u0026quot;); System.out.println(hS); System.out.println(); System.out.println(); //Ordenació mitjançant TreeSet System.out.println(\u0026quot;Ordenem mitjançant un TreeSet\u0026quot;); TreeSet myTreeSet = new TreeSet(); myTreeSet.addAll(hS); System.out.println(myTreeSet); //Objectes ALUMNE // ArrayList d' objectes Alumne System.out.println(\u0026quot;\\nHASHSET ALUMNES\u0026quot;); HashSet\u0026lt;Alumne\u0026gt; alumnes = new HashSet\u0026lt;Alumne\u0026gt;(); // Afegir elements System.out.println(\u0026quot;Mostrem els alumnes\u0026quot;); alumnes.add(new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;)); alumnes.add(new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;)); Alumne al = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); alumnes.add(al); alumnes.add(new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;)); alumnes.add(new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;)); // Recorregut usant la classe Iterator System.out.println(\u0026quot;\\nRealitzem un recorregut mitjançant iterator\u0026quot;); Iterator its = alumnes.iterator(); while (its.hasNext()) System.out.println(its.next()); //ORDENAR HASHSET USANT TREESET System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeSet per NOM\u0026quot;); TreeSet treeNom = new TreeSet(Alumne.alumnesCompararPerNom); treeNom.addAll(alumnes); its = treeNom.iterator(); while (its.hasNext()) System.out.println(its.next()); System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeSet per COGNOM\u0026quot;); TreeSet treeCognom = new TreeSet(Alumne.alumnesCompararPerCognom); treeCognom.addAll(alumnes); its = treeCognom.iterator(); while (its.hasNext()) System.out.println(its.next()); System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeSet per EDAT\u0026quot;); TreeSet treeEdat = new TreeSet(Alumne.alumnesCompararPerEdat); treeEdat.addAll(alumnes); its = treeEdat.iterator(); while (its.hasNext()) System.out.println(its.next()); // Comprovar si conté un objecte System.out.println(\u0026quot;\\nComprovem si conté un element Alumne \\\u0026quot;al\\\u0026quot;\u0026quot;); if (alumnes.contains(al)) { System.out.println(\u0026quot;Existeix l'alumne buscat\u0026quot;+al); } //Eliminem i recorregut System.out.println(\u0026quot;\\nEliminem l'element 'al'\u0026quot;); alumnes.remove(al); System.out.println(alumnes); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/1herencia/2coleccions/",
	"title": "Exemples polimòrfics",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;herència permet a una classe nova crear-se a partir d\u0026rsquo;una classe existent. La nova classe (subclasse) \u0026ldquo;hereta\u0026rdquo; els atributs i mètodes de la classe primària, i a més a més, té la possibilitat d\u0026rsquo;incorporar nous atributs i mètodes específics a la subclasse.\n Aquesta particularitat permet crear una estructura jeràrquica de classes cada vegada més especialitzada. L\u0026rsquo;herència es basa en la reutilització de classes on es crea una classe nova incorporant atributs i mètodes de la classe pare. Els mètodes heretats poden ser sobreescrits i adoptar un comportament nou o ampliant-ne la seva funcionalitat. Aquesta reutilització permet estalviar molt de temps i adoptar components creats i ja testats.\nConceptes:\n Superclasse: Classe primària o existent en l\u0026rsquo;herència. Subclasse: classe nova i resultant d\u0026rsquo;aplicar herència a una altra classe. Especialització: Procés que permet estendre d\u0026rsquo;una classe pare a una classe filla, ampliant atributs i mètodes. Generalització: Procés de navegar de les classes filles a la classe pare. En la classe pare trobarem els atributs i mètodes comuns a totes les subclasses.  Herència simple\nJava permet l\u0026rsquo;herència simple: qualsevol classe només té una classe pare, no permet l\u0026rsquo;herència múltiple com sí permeten altres llenguatges de programació com el C++. Això ens planteja el problema que a vegades pels requisits de la nostra aplicació és necessari simular l\u0026rsquo;herència múltiple fent ús d\u0026rsquo;interfícies. Per a més informació: problema del diamant\nRelació \u0026ldquo;és un\u0026rdquo; vs \u0026ldquo;conté un\u0026rdquo;\nL\u0026rsquo;herència és una relació d\u0026rsquo;extensió d\u0026rsquo;una classe més específica respecte una classe genèrica, això ens porta a que la classe filla ÉS UNA classe pare, però amb les funcionalitats ampliades/exteses/modificades. A vegades quan es programa existeix el dubte de confondre aquesta relació amb una relació de composició CONTÉ UN, que erròniament entenguem com a subclasse \u0026ldquo;una part\u0026rdquo; de la classe principal. Un exemple seria el següent:\nCom podeu veure en l\u0026rsquo;herència es parteix d\u0026rsquo;un BaseVehicle, que a la vegada s\u0026rsquo;especialitza en un Truck, i a la vegada s\u0026rsquo;especialitza en un TacoTruck. TacoTruck \u0026ldquo;ÉS UN\u0026rdquo; BaseVehicle, TacoTruck és una extensió de BaseVehicle. En canvi Truck \u0026ldquo;CONTÉ UN\u0026rdquo; engine, engine és una part de Truck, no podria substituir l\u0026rsquo;engine per un truck i que es comporti de la mateixa manera.\nUna vegada es conceptualitza el problema a resoldre pots crear el teu arbre jeràrquic. Un exemple amb animals seria:\nImplementació Per tal d\u0026rsquo;indicar que una classe és una herència utilitzarem la paraula extends en la definició de la classe. Per exemple si tenim una classe pare Persona i dos classes filles Alumne i Professor, ho faríem de la següent manera:\npublic class Persona{ ... } public class Alumne extends Persona { ... } public class Professor extends Persona{ ... }  Si la superclasse no està al mateix package que la subclasse, s\u0026rsquo;ha d\u0026rsquo;importar la classe ja que sinó no en tindria visibilitat.\njava.lang.Object\nUna subclasse pot ser a la vegada superclasse d\u0026rsquo;altres classes i crear així un àrbre jeràrquic de classes. En Java totes les classes hereten d\u0026rsquo;una classe mare, la classe arrel de totes és java.lang.Object. Hi ha un conjunt de mètodes que tenen TOTES les classes de Java, inclús les que programeu vosaltres, aquí teniu la descripció de Java Oracle referent a la classe Object.\nTotes les classes per defecte extenen de java.lang.Object, per tant poden fer ús dels mètodes que conté aquesta classe, per exemple:\n toString(): retorna una definició dels atributs en forma de String, aquesta definició la podeu \u0026ldquo;sobreescriure i modificar i adaptar a les vostres necessitats\u0026rdquo;. equals(Object o): mètode per comparar l\u0026rsquo;Objecte o amb l\u0026rsquo;implícit(this), per defecte retorna true si es tracta del mateix objecte (mateixa referència) i false si no. Si volem comparar els atributs per comprovar que es tracta dels mateixos valors serà necessari \u0026ldquo;sobreescriure\u0026rdquo; el mètode i fer que adopti el comportament que volem, això passa per exemple amb el cas de la classe String, ens retorna true si els dos Strings tenen el mateix valor i no si fan referència al mateix objecte. clone(): s\u0026rsquo;utilitza per realitzar una còpia de l\u0026rsquo;objecte. Veurem altres maneres de realitzar còpies.  És el mateix posar en la definició extends Object que no posar-ho.\nfinal\nA vegades, pels requisits de la nostra aplicació no ens interessa que hi pugui haver una herència en una classe, en aquests casos indicaríem mitjançant l\u0026rsquo;atribut final. Per exemple si vull que Persona sigui una classe final i que per tant no es pugui extendre ho marcaria de la següent manera:\npublic final class Persona{ ... }  El mateix passa quan apliquem final a un mètode o a un atribut.\n En el cas del mètode si en la definició posem que és final no ens permetrà en subclasses sobreescriure\u0026rsquo;l, no el podrem modificar.  package paquet.exemplefinal; public class classeOrigen { public final void mostraInfo() { System.out.println(\u0026quot;mostraInfo\u0026quot;); } } package paquet.exemplefinal; public class classeFilla extends classeOrigen { public void mostraInfo() { System.out.println(\u0026quot;mostra una altra info\u0026quot;); } }  En aquest cas donaria un error de compilació ja que intentem sobreescriure un mètode que és definit com a final en la classe pare.\n En el cas d\u0026rsquo;un atribut final un cop inicialitzat no ens permetrà tornar-lo a modificar canviant-li el valor, s\u0026rsquo;utilitza per definir constants.  public class CanviVariable { private final int enter=1; public CanviVariable(int enter){ this.enter = enter; } } public class CanviVariable2 { public static void main(String[] args){ final int enter = 0; enter = 2; } }  Els casos anteriors donarien error ja que volem canviar el valor d\u0026rsquo;una variable que s\u0026rsquo;ha declarat final i ja té valor. En canvi, el cas següent no ens donaria cap error, ja que quan creem l\u0026rsquo;objecte donem valor per primer cop a aquesta variable, això sí, no li podrem canviar el valor en l\u0026rsquo;execució de tot el programa al ser final.\npublic class CanviVariable { private final int enter; public CanviVariable(int enter){ this.enter = enter; } }  Visibilitat\nFins el moment hem observat com els atributs i mètodes públics són accessibles des de fora de la pròpia classe i els que són privats són només accessibles desde dins la pròpia classe.\nAmb l\u0026rsquo;herència apareix la visibilitat protected, que permet tenir visibilitat d\u0026rsquo;atributs i mètodes situats en:\n la mateixa classe les seves subclasses altres classes del mateix package  Com s\u0026rsquo;observa existeix l\u0026rsquo;opció default quan no indiquem cap atribut de visibilitat, les classes declarades com a default tenen accés a totes les classes del propi package.\nSobreescriptura\nMés amunt hem comentat el concepte de sobreescriptura, aquesta és una de les característiques polimòrfiques que tenim amb els llenguatges POO.\nLa sobreescriptura ens permet modificar mètodes definits en la superclasse. Per tant ens permet canviar el comportament de mètodes que ja estan definits en la classe pare.\n Quan sobreescrivim un mètode podem utilitzar la paraula @Override sobre la definició del mètode per indicar-li a Java que sobreescrivim un mètode la superclasse.\nEx, sobreescrivim el comportament que ens dóna java.lang.Object per toString():\npublic class Enter{ int valor; @Override public String toString() { return \u0026quot;El valor d'Enter és:\u0026quot; + this.valor; } }  Constructors i super\nQuan definim els mètodes constructors de les subclasses, és necessari primer cridar la constructora de la classe pare, això és possible gràcies a super() o super(parametres). Quan es crea un fill primer sempre es comença inicialitzant les variables del pare i després s\u0026rsquo;inicialitzen les del fill. Si no posem cap mètode super, per defecte intentarà buscar super() en el pare, si no existís hi hauria un error de compilació.\npublic class Persona{ String dni; public Persona(String dni){ this.dni = dni; } } public class Alumne extends Persona{ int matricula; public Alumne(String dni, int matricula){ super(dni); this.matricula = matricula; } } //Error de compilació ja que la constructora Persona() com a tal no existeix public class Alumne extends Persona{ int matricula; public Alumne(int matricula){ super(); this.matricula = matricula; } }  Exemple\nRealitzem un exemple de com seria una herència amb classe pare Producte i classe Filla ProducteDescompte.\npublic class Producte { protected String nom; protected double preu; public Producte(String nom, double preu) { this.nom = nom; this.preu = preu; } public void anunci() { System.out.println(\u0026quot;Hola sóc el producte \u0026quot; + nom); } public double valorProducte() { return preu; } } public class ProducteDescompte extends Producte { private int descompte; public ProducteDescompte(String nom, double preu, int descompte) { super(nom, preu); this.descompte = descompte; } @Override public void anunci() { super.anunci(); System.out.println( \u0026quot;Tinc un descompte de \u0026quot; + descompte+\u0026quot;%\u0026quot;); } @Override public double valorProducte() { return preu - (preu*descompte)/100; } public void rebaixaNouDescompte(int rebaixa){ this.descompte = this.descompte - rebaixa; } public void augmentaNouDescompte(int augment){ this.descompte = this.descompte + augment; } } public class Programa { public static void main(String[] args) { Producte p = new Producte(\u0026quot;Llapis\u0026quot;, 100.0); p.anunci(); System.out.println(\u0026quot;El preu del producte és \u0026quot; + p.valorProducte()); System.out.println(); ProducteDescompte p1 = new ProducteDescompte(\u0026quot;Llapis rebaixat\u0026quot;, 100.0, 10); p1.anunci(); System.out.println(\u0026quot;El preu d'un nou producte rebaixat és \u0026quot; + p1.valorProducte()); System.out.println(); p1.augmentaNouDescompte(10); p1.anunci(); System.out.println(\u0026quot;El preu del producte després de modificar la rebaixa és \u0026quot; + p1.valorProducte()); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/2accions/",
	"title": "Accions a base de dades",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/",
	"title": "AEA2. Introducció a la POO",
	"tags": [],
	"description": "",
	"content": "Comencem la segona part d\u0026rsquo;aquest mòdul que parla sobre una introducció a la Programació Orientada a Objectes, Java és un llenguatge purament orientat a objectes i per tant és necessari assolir-ne les bases quan abans millor. En aquesta Activitat d\u0026rsquo;Ensenyament Aprenentatge (AEA) veurem els següent:\n Funcions i pas de paràmetres\n  Definicions i exemple\n  Instanciació d\u0026rsquo;objectes\n  Estructura de classe i mètodes\n3.1. Visibilitat\n3.2. Mètodes estàtics\n  Construcció i destrucció d\u0026rsquo;objectes\n  Ús de mètodes i propietats\n  Concepte d\u0026rsquo;herència i ús\n  Llibreries\n  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/3manipulaciofitxers/2binari/",
	"title": "Binari",
	"tags": [],
	"description": "",
	"content": "L/E byte a byte FileInputStream: http://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html\nFileOutputStream: http://docs.oracle.com/javase/8/docs/api/java/io/FileOutputStream.html\nL/E per bytes amb buffer (més eficient) BufferedInputStream: http://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html\nBufferedOutputStream: http://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html\nLectura fitxer binari Com s\u0026rsquo;observa en cada exemple permet llegir d\u0026rsquo;un ArrayList o bé d\u0026rsquo;un Array. Els dos primers exemples fan referència al FileInputStream i els dos últims al BufferInputStream. Proveu la lectura d\u0026rsquo;una imatge per exemple, o un fitxer binari i observeu que passa amb els temps.\npackage exemples; import java.io.BufferedInputStream; import java.io.FileInputStream; import java.util.ArrayList; import java.util.Arrays; public class LBinari { public static void main(String[] args) { long time_start, time_end; time_start = System.currentTimeMillis(); System.out.print(llegirFitxerBinari2AList(\u0026quot;f1.txt\u0026quot;)); time_end = System.currentTimeMillis(); System.out.println(\u0026quot;the task has taken \u0026quot;+ ( time_end - time_start ) +\u0026quot; milliseconds\u0026quot;); System.out.println(); time_start = System.currentTimeMillis(); System.out.print(Arrays.toString(llegirFitxerBinari2Array(\u0026quot;f1.txt\u0026quot;))); time_end = System.currentTimeMillis(); System.out.println(\u0026quot;the task has taken \u0026quot;+ ( time_end - time_start ) +\u0026quot; milliseconds\u0026quot;); System.out.println(); System.out.println(); System.out.println(\u0026quot;\\n\u0026quot;); time_start = System.currentTimeMillis(); System.out.print(llegirFitxerBinariBuffered(\u0026quot;f1.txt\u0026quot;)); time_end = System.currentTimeMillis(); System.out.println(\u0026quot;the task has taken \u0026quot;+ ( time_end - time_start ) +\u0026quot; milliseconds\u0026quot;); System.out.println(); time_start = System.currentTimeMillis(); System.out.print(Arrays.toString(llegirFitxerBinari2ArrayBuffered(\u0026quot;f1.txt\u0026quot;))); time_end = System.currentTimeMillis(); System.out.println(\u0026quot;the task has taken \u0026quot;+ ( time_end - time_start ) +\u0026quot; milliseconds\u0026quot;); System.out.println(); System.out.println(); } /** * Llegeix el contingut d'un fitxer byte a byte. * @param path Path del fitxer de text plà. * @return ArrayList de bytes amb el contingut del fitxer. */ public static ArrayList\u0026lt;Byte\u0026gt; llegirFitxerBinari2AList(String path) { try { ArrayList\u0026lt;Byte\u0026gt; res = new ArrayList\u0026lt;Byte\u0026gt;(); FileInputStream fis = new FileInputStream(path); byte b; while ((b = (byte)fis.read()) != -1) { res.add(b); } fis.close(); return res; } catch (Exception e) { System.out.println(e.getMessage()); return null; } } /** * Llegeix el contingut d'un fitxer byte a byte. * @param path Path del fitxer de text plà. * @return Array de bytes amb el contingut del fitxer. */ public static byte[] llegirFitxerBinari2Array(String path) { try { FileInputStream fis = new FileInputStream(path); int len = fis.available(); byte[] res = new byte[len]; fis.read(res); fis.close(); return res; } catch (Exception e) { System.out.println(e.getMessage()); return null; } } /** * Llegeix el contingut d'un fitxer byte a byte, usant classes buffered. * @param path Path del fitxer de text plà. * @return ArrayList de bytes amb el contingut del fitxer. */ public static ArrayList\u0026lt;Byte\u0026gt; llegirFitxerBinariBuffered(String path) { try { ArrayList\u0026lt;Byte\u0026gt; res = new ArrayList\u0026lt;Byte\u0026gt;(); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path)); byte b; while ((b = (byte)bis.read()) != -1) { res.add(b); } bis.close(); return res; } catch (Exception e) { System.out.println(e.getMessage()); return null; } } /** * Llegeix el contingut d'un fitxer byte a byte, usant classes buffered. * @param path Path del fitxer de text plà. * @return Array de bytes amb el contingut del fitxer. */ public static byte[] llegirFitxerBinari2ArrayBuffered(String path) { try { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path)); int len = bis.available(); byte[] res = new byte[len]; bis.read(res); bis.close(); return res; } catch (Exception e) { System.out.println(e.getMessage()); return null; } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/1acces/2caracteristiques/",
	"title": "Característiques",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/1definicionsexemple/",
	"title": "Definicions i exemples",
	"tags": [],
	"description": "",
	"content": "Com hem observat, a mesura que tenim problemes més complexes és necessari fer ús de tècniques que ens ajudin a programar d\u0026rsquo;una forma més senzilla, d\u0026rsquo;aquesta manera hem passat de la programació estructurada a la programació funcional on hem ordenat i estructurat el codi en blocs d\u0026rsquo;instruccions coherents. Continuant en aquest procés ara toca fer el salt per conèixer la programació orientada a objectes (POO).\n1. Paradigma de Programació orientada a objectes Es fonamenta en la manera en que els éssers humans percebem i entenem els objectes del nostre món\n Exemple:\n   Joan Maria          Que tenen en comú el Joan i la Maria? Els dos són persones.\nMitjançant un procés de generalització sabem que els dos objectes Joan i Maria pertanyen a la mateixa classe persona.\nMitjançant aquesta abstracció identifiquem molts exemples de la mateixa plantilla. Així doncs sabem que tots aquests exemples tenen les característiques comunes d\u0026rsquo;una plantilla persona.\nAprofundim ara en els nostres exemples de Persona: Joan i Maria.\n          Atributs\n- Nom\n- Estatura\n- Pes\n- Color cabell\n- Color ulls\n- Edat\n- Sexe\n- Té un nas\nMètodes\n- Somriu\n- Parla\n- Dorm\n- Pensa\n- Menja    Atributs\n- Nom\n- Estatura\n- Pes\n- Color cabell\n- Color ulls\n- Edat\n- Sexe\n- Té un nas\nMètodes\n- Somriu\n- Parla\n- Dorm\n- Pensa\n- Menja    Com podem observar tant en Joan com la Maria tenen una sèrie de característiques comunes (atributs) i un comportament comú (mètodes) ja que els dos es poden classificar dins la mateixa categoria de persones.\nLa POO consisteix en fer servir aquesta manera natural de pensar en objectes com a mecanisme per a organitzar millor el nostre codi i poder desenvolupar, mantenir i ampliar aplicacions de software amb un alt grau de complexitat.\n2. Definicions          Classe\n Una classe és la definició d\u0026rsquo;un objecte real.\nÉs l\u0026rsquo;element que descriu els components d\u0026rsquo;un objecte de manera general. En ell hi queden especificats quines característiques té l\u0026rsquo;objecte (atributs) i quines accions pot realitzar (mètodes). És la plantilla que ens servirà per crear objectes.   Objecte\n Un objecte és una instància d\u0026rsquo;una classe. Diem que hem creat o instanciat un objecte quan donem valors i fem servir els mètodes definits a la classe.   Atribut\n Un atribut és una característica concreta d\u0026rsquo;un objecte. Es defineix com les variables del programes estructurats, és a dir, definint tipus de dades i identificador (nom).   Mètode\n Els mètodes defineixen quines funcionalitats pot realitzar els objectes d\u0026rsquo;una classe. Reflecteixen les operacions que es poden fer sobre els atributs.    Exemple Un exemple podria ser una classe jugadorFutbol que tingués:\n atributs: nom, edat, pes, posició, nacionalitat, etc. mètodes: marcaGols, esLesiona, protestaArbitre, canviaPosicio, etc.  I amb aquesta classe jugadorFutbol definida podríem tenir diferents jugadors, per tant hi instanciaríem diferents objectes:\n Leo Messi, 37 anys, 65kg, davanter, argentí. Andres Iniesta, 40 anys, 67kg, centrecampista, espanyol.  3. Característiques generals de POO Abstracció Es tracta de centrar-se en “el què fa” més que no en el “com ho fa”.\n Com hem vist en l\u0026rsquo;exemple anterior, sabem que dos objectes diferents com el Joan i la Maria tenen unes característiques i un comportament comú, d\u0026rsquo;aquí hem deduït per abstracció que formen part del mateix conjunt Persones. Així doncs l\u0026rsquo;abstracció ens permet aïllar aquella part que ens interessa del conjunt. Ex:\n No és necessari saber de mecànica de bicicletes per aprendre a anar en bicicleta. No és necessari conèixer què fan exactament les funcions del kernel de linux per usar-les. No ens cal conèixer en profunditat com funciona el rentaplats per usar-lo. Tots els exemples anteriors són casos en els que fem ús d\u0026rsquo;un instrument sense coneixer-lo a fons.  Quan definiu les classes podeu crear funcions privades que utilitzeu pel funcionament del vostre programa però que NO seran accessibles des del programa principal.\nL\u0026rsquo;abstracció permet que qualsevol objecte el poguem reutilitzar en qualsevol situació. Per exemple, l\u0026rsquo;objecte cotxe vist anteriorment el podem fer servir en una aplicació de carreres però també per a una altra de mobilitat sostenible. El que tenen en comú és que identifiquem el mateix objecte en ambdues aplicacions(característiques i comportament).\nEncapsulament Es refereix a l\u0026rsquo;ocultació d\u0026rsquo;informació de forma que les dades internes d\u0026rsquo;un objecte són ocultes al món exterior, tal sols sabem què podem fer amb ell.\n Per exemple, quan escrivim per pantalla amb el mètode “sc.nextInt()”, sols sabem que ens retorna un enter però no sabem com és la implementació d\u0026rsquo;aquest mètode per dins, ni tampoc coneixem les seves variables internes.\nModularitat es refereix a la forma en que els elements es POO es troben organitzats en mòduls (paquets en Java) facilitant l\u0026rsquo;encapsulació i abstracció de la informació.\n Jerarquia S\u0026rsquo;ordenen els objectes de forma que s\u0026rsquo;estableixen relacions entre ells. Serveix per especificar aquelles característiques d\u0026rsquo;un objecte necessàries per la nostra aplicació.\n La jerarquia s\u0026rsquo;estableix mitjançant herència. Per exemple, podem definir objectes vehicle (amb matrícula, cavalls, etc..) i també objectes camions que hereten les característiques de vehicle i n\u0026rsquo;afegeixen d\u0026rsquo;altres (pes màxim, etc\u0026hellip;).\nPolimorfisme Defineix la possibilitat de tenir mètodes i classes amb la mateixa identificació però que tenen un comportament diferent segons l\u0026rsquo;objecte que la faci servir.\n Un bon exemple de polimorfisme és l\u0026rsquo;operador +. Si l\u0026rsquo;apliquem a dos enters ens retorna la suma d\u0026rsquo;aquests, mentre que si l\u0026rsquo;apliquem a dos strings ens els concatena, per tant, donat el mateix operador, el comportament és diferent, és un element sobrecarregat i que adopta diferent funció depenent dels tipus que el rodegen. En POO passa el mateix, podem tenir un mètode que faci una funció diferent depenent de quin objecte l\u0026rsquo;implementa.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/2accions/2emmagatzematge/",
	"title": "Emmagatzematge",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/2entornjava/",
	"title": "Entorn Java",
	"tags": [],
	"description": "",
	"content": "Cas particular de Java Tot seguit veiem què passa amb un programa qualsevol, per exemple HolaMon.java escrit en Java. És el primer programa que s\u0026rsquo;acostuma a mostrar de qualsevol llenguatge de programació. La única funció que té aquest programa és escriure per pantalla un text que digui \u0026ldquo;Hola Món\u0026rdquo;.\nSi us fixeu en la següent il·lustració es mostra tot el procés de compilació. Inicialment tenim el codi font del fitxer HolaMundo.java escrit pel programador. El següent pas és transformar aquest fitxer pla en un fitxer binari que entengui la màquina (bytecode), cada plataforma genera el seu propi fitxer .class diferent. La creació d\u0026rsquo;aquest fitxer binari ens assegura que el procés de compilació del fitxer .java s\u0026rsquo;ha executat correctament, en java s\u0026rsquo;utilitza la comanda javac per poder obtenir-lo. javac HolaMundo.java Amb aquesta instrucció \u0026ldquo;es compila\u0026rdquo; el programa i genera un HolaMundo.class.\nUn cop tenim el fitxer .class, executant la comanda java HolaMundo obtenim l\u0026rsquo;execució del nostre programa sobre la plataforma on estiguem, per això en la imatge següent el codi màquina que s\u0026rsquo;executa amb Win32 serà diferent que el que interpreta MacOS ja que són SO\u0026rsquo;s diferents que obeeixen a instruccions diferents i per tant amb .class diferents.\nEn el següent exemple es pot veure com seria un fitxer .java que es llegeix i s\u0026rsquo;enten amb llenguatge humà. A continuació, en el procés de compilació, es genera el fitxer .class, aquí ja els humans no entenem el contingut del fitxer ja que està en hexadecimal, i finalment quan executem el programa es genera un fitxer en codi màquina amb una tira de 0s i 1s que són les instruccions que necessita la CPU en cada plataforma per ser executat. Aquest últim fitxer serà diferent en cada plataforma d\u0026rsquo;execució (Linux, Windows, MacOS\u0026hellip;)\nEvolució de Java El llenguatge de programació Java va ser desenvolupat per James Gosling l\u0026rsquo;any 1991. La primera versió va ser publicada per Sun Microsystems l\u0026rsquo;any 1995, a partir de la versió JDK 1.0.2 va passar a anomenar-se Java, l\u0026rsquo;any 1996.\nCom observareu en el següent link Versions de Java, les versions de Java estan en constant evolució afegint en cada nova versió noves funcionalitats que modernitzen i actualitzen el llenguatge als nous reptes que van sorgint.\nSi us fixeu en les dates de noves versions, veureu que fins a la versió de Java SE 9 s\u0026rsquo;anaven creant versions cada 2 i cada 3 anys, a partir de Java SE 9 les versions són semestrals. És així ja que des de l\u0026rsquo;any 2017 s\u0026rsquo;ha accelerat el disseny de software i la innovació en el món de la programació ha fet que sorgeixin en períodes curts de temps noves funcionalitats, de manera que l\u0026rsquo;equip de desenvolupadors de Java van creure necessari traure versions de Java cada 6 mesos.\nDe les diferents versions cal destacar aquelles que tenen un suport en el manteniment d\u0026rsquo;errades i actualització de sistema d\u0026rsquo;aquelles versions que no tenen aquest suport, així doncs observareu que Java SE 8, Java SE 11, Java SE 17, Java SE 21 tenen d\u0026rsquo;aquest suport que permet una estabilitat alhora d\u0026rsquo;implantar sistemes que utilitzin aquestes versions.\nEn el llistat de cada versió també podeu veure quines són les noves \u0026ldquo;features\u0026rdquo; o funcionalitats que incorporen les noves versions respecte a les anteriors.\nDurant el curs utilitzarem la última versió estable i, que per tant gaudeix d\u0026rsquo;aquest manteniment, és la versió de Java SE 21.\nEn el següent gràfic podeu veure el nombre de noves JEP\u0026rsquo;s (JDK Enhancement Proposals) que s\u0026rsquo;han afegit en cada nova versió de Java. (Font de: https://dev.java/evolution/)\nVersió de Java Per saber quina versió teniu instal·lada en el vostre sistema heu d\u0026rsquo;anar al terminal i en la línea de comandes podeu escriure java -version. Veureu:\nTot hi així com que treballarem dins un programa per escriure codi, un IDE (Integrated Development Environment), permetrà instal·lar per a cada projecte que volguem la versió que volguem de Java, per defecte tindrem la Java SE 21. El programa per escriure codi que utilitzem és IntelliJ Idea.\nA mesura que aneu fent projectes i instal·leu versions diferents de Java, a partir d\u0026rsquo;ara JDK (Java Development Kid), veureu que si aneu a la carpeta home/usuari/.jdks us apareixen totes les versions que teniu disponibles (a part de la del propi sistema), ja que les heu utilitzades en algun projecte anterior.\nJDK i JRE Fins ara hem parlat del llenguatge de programació Java però no hem explicat la seva estructura interna, com s\u0026rsquo;organitza per paquets i mòduls. La següent imatge resumeix la seva organització:\nJDK és el Java Development Kit. És el mòdul més genèric que ens podem instal·lar i disposa de les eines per construir programes usant el llenguatge de programació Java. Com veieu en la imatge, entre les eines més importants hi ha el compilador (javac), el desassemblador de binaris (javap), el debugger, jar, javadoc, Web Services,\u0026hellip; ** Una instal·lació de JDK ja conté dins el JRE.**\nJRE és el Java Runtime Environment. Conté la JVM (Java Virtual Machine) i altres eines que permeten l'execució i de les aplicacions fetes en Java. el JRE no posseeix compiladors ni eines per desenvolupar aplicacions de Java, només conté eines d\u0026rsquo;execució de programes Java.\nEn la següent web teniu diferents versions del JDK que us podeu instal·lar a la vostra màquina depenent del sistema operatiu i la versió que tingueu: Java Oracle JDK\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/2fitxers/",
	"title": "Gestió de fitxers",
	"tags": [],
	"description": "",
	"content": "File La classe File és útil per portar la gestió sobre fitxers i carpetes en Java, la seva especificació en Java Oracle és: https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/File.html\nEl sistema de fitxers en UNIX separa els directoris usant “/” mentre que en Windows es separen amb “\\”.\nCreació de File\n//Creem objectes File File fitxer=new File(\u0026quot;/home/nomUsuari/direccio/fitxer\u0026quot;); File directori=new File(\u0026quot;/home/nomUsuari/direccio\u0026quot;); //Creem fitxers i directoris fitxer.createNewFile(); directori.mkdir();  Comprovacions de Fitxer o Directori\nEls següents mètodes són booleans.\n//Indica si existeixen els arxius System.out.println(\u0026quot;Fitxer \u0026quot;+fitxer.exists()); System.out.println(\u0026quot;Directori \u0026quot;+directori.exists()); //Indica si son directori System.out.println(\u0026quot;És directori? \u0026quot;+fitxer.isDirectory()); System.out.println(\u0026quot;És directori? \u0026quot;+directori.isDirectory()); //Indica si son fitxers System.out.println(\u0026quot;És fitxer? \u0026quot;+fitxer.isFile()); System.out.println(\u0026quot;És fitxer? \u0026quot;+directori.isFile());  Gestió de rutes\nTot seguit es crea una direcció relativa i una absoluta i després es comprova i se n\u0026rsquo;identifica nom i direcció.\n//Creació ruta relativa i absoluta File fitxerRutaAbsoluta=new File(\u0026quot;/home/nomUsuari/direccio/fitxer\u0026quot;); File fitxerRutaRelativa=new File(\u0026quot;../../../ruta/direccio\u0026quot;); //Indica la ruta absoluta del File System.out.println(\u0026quot;Ruta absoluta: \u0026quot;+fitxerRutaAbsoluta.getAbsolutePath()); System.out.println(\u0026quot;Ruta absoluta: \u0026quot;+fitxerRutaRelativa.getAbsolutePath()); //Indica el nom del document/carpeta System.out.println(\u0026quot;Ruta absoluta: \u0026quot;+fitxerRutaAbsoluta.getName()); System.out.println(\u0026quot;Ruta absoluta: \u0026quot;+fitxerRutaRelativa.getName()); //Indica la ruta del document/carpeta System.out.println(\u0026quot;Ruta absoluta: \u0026quot;+fitxerRutaAbsoluta.getParent()); System.out.println(\u0026quot;Ruta absoluta: \u0026quot;+fitxerRutaRelativa.getParent());  Permisos en File\nTots els mètodes són booleans.\nFile fitxer=new File(\u0026quot;/home/nomUsuari/direccio/fitxer\u0026quot;); fitxer.canRead(); fitxer.canWrite(); fitxer.canExecute();  Llistar fitxers que hi ha dins una carpeta\nFile directori=new File(\u0026quot;/home/nomUsuari/direccio\u0026quot;); File llista[]=directori.listFiles(); for(File file: llista){ System.out.println(file.getName()); } String llista[]=directori.list(); for(String file: llista){ System.out.println(file); }  Altres mètodes interessants\nFile fitxer=new File(\u0026quot;/home/nomUsuari/direccio/fitxer\u0026quot;); //Mida del fitxer fitxer.length //Eliminar un file fitxer.delete() //Renombrar un file fitxer.renameTo(fileDesti)  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/2instanciacio/",
	"title": "Instanciació d&#39;objectes",
	"tags": [],
	"description": "",
	"content": "Intanciem la primera classe Definirem la classe Persona i un mètode que ens faci saludar aquesta persona mostrant un missatge per pantalla.\npackage exemple1.versio1; public class Persona { public void saluda() { System.out.println(\u0026quot;Hola, sóc una persona\u0026quot;); } }  Observacions:\n A la línia 1 tenim la declaració del package. Per \u0026ldquo;Naming Convention\u0026rdquo;, el nom dels packages s\u0026rsquo;ha d\u0026rsquo;escriure en minúscules. A la línia 3 tenim la declaració de la classe. La paraula reservada public serveix per especificar l’àmbit (accés o visibilitat) de la classe. De moment, totes les classes seran públiques. Fixeu-vos que la primera lletra és majúscula i la resta del nom de la classe en minúscula. A la línia 5 tenim la declaració del mètode. És un mètode públic això ens indica que és accessible des d\u0026rsquo;altres classes i per tant pot ser cridat des d\u0026rsquo;elles. També s\u0026rsquo;observa que la signatura del mètode ja no porta la paraula static, això voldrà dir que és un mètode de la classe i que només té sentit quan s\u0026rsquo;instancia un objecte d\u0026rsquo;aquesta classe Persona, no té sentit utilitzar aquest mètode si no tenim un objecte Persona creat.  Recordem que la JVM busca en la classe que executem un mètode main com a punt d\u0026rsquo;inici de l\u0026rsquo;execució, en la classe Persona no hi és, si proveu d\u0026rsquo;executar-lo el compilador de Java retorna un error conforme no ha trobat un mètode main. Cal doncs que definim aquest mètode main ja sigui a la pròpia classe Persona o una altra classe Test. En l\u0026rsquo;exemple següent s\u0026rsquo;ha generat una classe nova per instanciar un objecte de la classe Persona i poder cridar així el mètode saluda().\npackage exemple1.versio1; public class PersonaTest { public static void main(String[] args) { Persona persona = new Persona(); persona.saluda(); } }  Observacions:\n A diferència del mètode saluda, el mètode main de PersonaTest és static, això vol dir que no necessita de la instància de la classe PersonaTest per ser cridat. En la línia 6 es crea un objecte nou de la classe Persona, aquest objecte és instanciat en una variable que s\u0026rsquo;anomena persona. El tipus de persona és Persona que ara mateix no té cap atribut i només conté un mètode capaç de saludar. El mètode Persona() que es crida quan s\u0026rsquo;instancia l\u0026rsquo;objecte s\u0026rsquo;anomena constructor i el veurem més endavant. A continuació, com que ja tenim un objecte instanciat de Persona, ja podem cridar tots aquells mètodes de classe que tingui aquesta persona, com per exemple saluda.  Crida amb paràmetres Efectuem un petit canvi a l\u0026rsquo;activitat anterior i definim el mètode saluda amb un paràmetre d\u0026rsquo;entrada que simbolitzi el nom de la persona i que demanarem per teclat en PersonaTest. Les dues classes quedarien de la següent manera:\npackage exemple1.versio2; public class Persona { public void saluda(String nom) { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom); } }  package exemple1.versio2; import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona que saluda: \u0026quot;); String nomPersona = sc.nextLine(); Persona persona = new Persona(); persona.saluda(nomPersona); } }  Sobre les classes utilitzades en PersonaTest:\n Usem Scanner, per això l\u0026rsquo;importem, ja que sinó no el tindríem visible. També estem cridant String i System, les dues pertanyents al paquet java.lang. Java ja les ha incorporades implícitament per això les podem usar sense declarar-ne l\u0026rsquo;import. Finalment estem creant objectes de la classe Persona. Com que PersonaTest i Persona es troben en el mateix directori, que correspon al mateix package, ja és visible i no cal importar-la tampoc.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/zzz_gesti%C3%B3-bbddor/2.metadades/",
	"title": "Metadades",
	"tags": [],
	"description": "",
	"content": "Donat un objecte Connection, podem obtenir un objecte DatabaseMetaData, que conté informació relativa al base de dades en la que ens hem connectat.\npublic static void main(String[] args) { DatabaseMetaData dbmd = null; try { Class.forName(\u0026quot;org.sqlite.JDBC\u0026quot;); Connection connection = DriverManager.getConnection(\u0026quot;jdbc:sqlite:Chinook_Sqlite.sqlite\u0026quot;); dbmd = connection.getMetaData(); mostraInfoBD(dbmd); mostraTaules(dbmd); mostraColumnes(dbmd, \u0026quot;Album\u0026quot;); } catch (SQLException e) { System.err.println(e.getMessage()); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } }  public static void mostraInfoBD(DatabaseMetaData dbmd) throws SQLException { String nom = dbmd.getDatabaseProductName(); String driver = dbmd.getDriverName(); String url = dbmd.getURL(); String usuari = dbmd.getUserName(); System.out.println(\u0026quot;Informació de la BD:\u0026quot;); System.out.println(\u0026quot;Nom: \u0026quot;+nom); System.out.println(\u0026quot;Driver: \u0026quot;+driver); System.out.println(\u0026quot;URL: \u0026quot;+url); System.out.println(\u0026quot;Usuari: \u0026quot;+usuari); }  public static void mostraTaules(DatabaseMetaData dbmd) throws SQLException { String[] types = {\u0026quot;TABLE\u0026quot;}; try (ResultSet rs = dbmd.getTables(dbmd.getCatalogTerm(), dbmd.getSchemaTerm(), null, types);) { while (rs.next()) { String cataleg = rs.getString(1); String esquema = rs.getString(2); String taula = rs.getString(3); String tipus = rs.getString(4); System.out.println(tipus + \u0026quot; - Cataleg: \u0026quot; + cataleg + \u0026quot;, Esquema: \u0026quot;+esquema+\u0026quot;, Nom: \u0026quot;+taula); } } }  public static void mostraColumnes(DatabaseMetaData dbmd, String taula) throws SQLException { System.out.println(\u0026quot;Columnes de la taula: \u0026quot;+taula); try (ResultSet columnes = dbmd.getColumns(null, null, taula, null);) { while (columnes.next()) { String nom = columnes.getString(\u0026quot;COLUMN_NAME\u0026quot;); // 4 String tipus = columnes.getString(\u0026quot;TYPE_NAME\u0026quot;); // 6 String mida = columnes.getString(\u0026quot;COLUMN_SIZE\u0026quot;); // 7 String nula = columnes.getString(\u0026quot;IS_NULLABLE\u0026quot;); // 18 System.out.println(\u0026quot;Columna: \u0026quot;+nom+\u0026quot;, Tipus: \u0026quot;+tipus+ \u0026quot;, Mida: \u0026quot;+mida+\u0026quot;, Pot ser nul·la? \u0026quot;+nula); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/3classemetodes/2estatics/",
	"title": "Mètodes estàtics",
	"tags": [],
	"description": "",
	"content": "Mètodes Estàtics Els mètodes estàtics són aquells que no depenen d\u0026rsquo;un objecte i que per tant s\u0026rsquo;invoquen a partir de la classe. Els mètodes que no són estàtics són aquells que depenen de l\u0026rsquo;existència d\u0026rsquo;un objecte i que per tant té sentit que s\u0026rsquo;invoquin una vegada s\u0026rsquo;ha creat un objecte.\n Posem un exemple, d\u0026rsquo;un mètode que és estàtic i que per tant no depèn de la instanciació d\u0026rsquo;un objecte i d\u0026rsquo;un mètode que no és estàtic i que per tant necessita d\u0026rsquo;un objecte per ser executat:\n//EXEMPLE ESTÀTIC //Mètode estàtic, suma de dos nombres public class Arithmetic{ public static int sum (int a, int b) { int s; s = a + b; return s; } } //El cridaríem fent ús de la pròpia classe, no és necessari crear un objecte Arithmetic per cridar la suma entre dos nombres. public class Main{ public static void main(String[] args){ int res; res = Arithmetic.suma(2,3); } } //EXEMPLE NO ESTÀTIC //Classe Persona amb un sol atribut, constructora i mètode saluda que utilitza l'atribut nom. public class Persona{ private String nom; Persona(String nom){ this.nom = nom; } public void saluda (){ System.out.println(\u0026quot;Hola em dic \u0026quot; + nom) } } //Per tal de cridar saluda és necessari crear una persona, no té sentit cridar saluda sense haver creat la persona ja que no sabem a partir de qui saludem! public class Main{ public static void main(String[] args){ Persona persona = new Persona(\u0026quot;Manolo\u0026quot;); persona.saluda(); } }  Com s\u0026rsquo;observa en el primer exemple el comportament del mètode suma no varia tant si intanciem com si no instanciem la classe Arithmetic, és una funció que té dos paràmetres d\u0026rsquo;entrada (que són els operands) i un paràmetre de sortida, per tant sempre té el mateix comportament. Mentre que en el segon exemple el mètode saluda fa ús de l\u0026rsquo;atribut nom, si no tenim un objecte Persona deixa de tenir sentit aquest mètode per això va lligat al comportament que adopti una determinada persona.\nRECORDA\nNo podrem declarar un mètode com estàtic si aquest:\n Accedeix a atributs de la classe. Modifica el contingut d\u0026rsquo;atributs de la classe. En ell hi intervenen mètodes privats de la pròpia classe.  Si el mètode ha de realitzar una tasca independent al contingut de l\u0026rsquo;objecte i no hi té incidència es pot declarar com static.\nEn Java existeixen funcionalitats en les quals ens ve de sèrie classes implementades amb mètdoes estàtics, seguint l\u0026rsquo;exemple anterior és un clar exemple la classe Math de Java. Si li feu un cop d\u0026rsquo;ull observareu que tots els seus mètodes són estàtics, és així ja que el propòsit de tots ells és efectuar càlculs independents. En l\u0026rsquo;exemple següent usarem el mètode max de la classe Math:\npublic static void main((String[] args) { int numero1 = 20; int numero2 = 10; int numeroMaxim = Math.max(numero1, numero2); }  Observacions:\n La notació per tal d\u0026rsquo;usar els mètodes estàtics és NomClasse.nomMetode(). Els mètodes estàtics també poden ser privats. Si per exemple hagués declarat suma() com a mètode privat voldria dir que només el podria usar des de dins la pròpia classe Arithmetic, no tindria visibilitat fora d\u0026rsquo;aquesta.  Atributs estàtics\nFins al moment hem treballat amb atributs d\u0026rsquo;instància, són aquells que poden canviar de valor en cada objecte i que per tant el determinen. Però també tenim atributs estàtics, són aquells que no se\u0026rsquo;n modifica el valor i que, per tant, comparteixen el mateix valor per tots els objectes. Els atributs estàtics estan sempre en memòria, per això és necessari declarar només aquells que siguin imprescindibles.\nPer a utilitzar-los posarem la paraula static abans del tipus de la variable. Per exemple MAJOR_EDAT:\npublic class Persona { public static int MAJOR_EDAT = 18; private String nom; private int edat; Persona (String nom, int edat){ this.nom = nom; this.edat = edat; } public String getNom(){ return nom; } ...  Igual que amb els mètodes, si la variable estàtica és pública i es vol accedir a ella des d\u0026rsquo;una altra classe cal que siguem la nomenclatura NomClasse.NomAtribut. Per exemple per accedir a l\u0026rsquo;anteior atribut estàtic fora de Persona hauríem de posar Persona.MAJOR_EDAT.\nUn dels usos més habituals de les variables estàtiques són per declarar constants (vist ja en la RA1), per exemple en la classe Math anterior tenim Math.PI. En aquests casos cal que vagin acompanyats de la paraula final, en Java quan declarem una variable com a final vol dir que un cop inicialitzada no li podem canviar el valor (com passa amb les constants). Si es vol canviar el valor a un atribut declarat com a final el compilador de Java respondrà amb el pertinent error.\npublic static final int MAJOR_EDAT = 18;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/4tipusdades/2operadors/",
	"title": "Operadors",
	"tags": [],
	"description": "",
	"content": "Les expressions són una combinació de variables i operadors que retornen un valor determinat. El tipus de dada retornat depèn de l\u0026rsquo;operació realitzada en l\u0026rsquo;expressió i dels tipus de dades de les variables implicades.\nEls operadors són els símbols especials que s\u0026rsquo;utilitzen per operar en les expressions.\nOperadors aritmètics Són les operacions que avaluen una operació i retornen un resultat numèric.\n   Operació Operador     Suma +   Resta -   Multiplicació *   Divisió /   Mòdul %    El mòdul és el residu d\u0026rsquo;una divisió, per exemple 10 % 2 = 0, o 16 % 3 = 1. És una operació molt útil en camp informàtic ja que ens ajuda a saber per exemple si una divisió és entera i per tant a saber si un nombre és divisible per un altre, veurem exemples més endavant.\nRecordem l\u0026rsquo;ordre de prioritat en les operacions aritmètiques:\n 1r Parèntesi () 2n Multiplicacions, divisioons i mòdul * / % 3r Sumes i restes + -  Operadors d\u0026rsquo;increment/decrement En Java existeix la possibilitat de realitzar un postincrement o un preincrement a una variable, per exemple: a++ ++a a-- --a.\n//PostIncrement a = 2; System.out.println(a++); // a = 2 System.out.println(a); // a = 3 //Preincrement a = 2; System.out.println(++a); // a = 3 System.out.println(a); // a = 3 //PostDecrement a = 2; System.out.println(a--); // a = 2 System.out.println(a); // a = 1 //PreDecrement a = 2; System.out.println(--a); // a = 1 System.out.println(a); // a = 1  Operadors d\u0026rsquo;assignació    Operació Operador Exemple     Assignació = a = b   Suma i assignació += a += b (a = a + b)   Resta i assignació -= a -= b (a = a - b)   Multiplicació i assignació *= a *= b (a = a * b)   Divisió i assignació /= a /= b (a = a / b)   Mòdul i assignació %= a %= b (a = a % b)    Operadors lògics i relacionals Són les operacions que avaluen una expressió i retornen un resultat booleà (true o false).\nOperadors lògics\n   A B !A A \u0026amp;\u0026amp; B A || B     true true false true true   true false false false true   false true true false true   false false true false false    Operadors relacionals\nAquests operadors els podem aplicar a diferents tipus de dades i s\u0026rsquo;avalua l\u0026rsquo;expressió a un booleà (true o false).\n   Operació Signe Exemple1 Resultat1 Exemple2 Resultat2     Major \u0026gt; 5 \u0026gt; 3 true 3 \u0026gt; 5 false   Major o igual \u0026gt;= 5 \u0026gt;= 5 true 5 \u0026gt;= 3 true   Menor \u0026lt; 5 \u0026lt; 5 false 3 \u0026lt; 2 false   Menor o igual \u0026lt;= 6 \u0026lt;= 5 false 4 \u0026lt;= 5 true   Igual == \u0026lsquo;c\u0026rsquo; == \u0026rsquo;d' false 5 == 3 false   No igual != \u0026lsquo;c\u0026rsquo; != \u0026rsquo;d' true 5 != 5 false    Prioritat\nLa prioritat alhora d\u0026rsquo;avaluar expressions que contenen operadors aritmètics, relacionals i lògics és:\n 1r. Es realitzen els càlculs aritmètics. 2n. S\u0026rsquo;avaluen les operacions relacionals de \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 3r. S\u0026rsquo;avaluen les operacions relacionals de == != 4rt. S\u0026rsquo;avaluen les negacions lògiques ! 5è. S\u0026rsquo;avaluen les operacions de conjunció \u0026amp;\u0026amp; 6è. S\u0026rsquo;avaluen les operacions de disjunció ||  Les operacions anteriors s\u0026rsquo;avaluen sempre d\u0026rsquo;esquerra a dreta.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/",
	"title": "AEA3. Estructura de dades",
	"tags": [],
	"description": "",
	"content": "Fins ara hem treballat amb estructures de dades simples. A mesura que tractem problemes més complexos es fa necessari agrupar i tractar les dades com un únic conjunt, Java ens ofereix diferents formes que ens permeten agrupar dades en una mateixa estructura. Així doncs, en el següent capítol veurem:\n Estructures estàtiques i dinàmiques Arrays Unidimensionals Arrays Bidimensionals Tractament cadena de caràcters\n4.1. Operacions Regulars\n4.2. StringBuilder Col·leccions\n5.1. Llistes: ArrayList\n5.2. Conjunts: Hashset\n5.3. Diccionaris: HashMap\n5.4. Genericitat Operacions Agregades  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/3arraybidimensional/",
	"title": "Arrays Bidimensionals",
	"tags": [],
	"description": "",
	"content": " Arrays bidimensional: és una estructura d\u0026rsquo;array de dues dimensions. També s\u0026rsquo;entén com un vector de vectors. Es coneix amb el nom de matriu. És un conjunt d\u0026rsquo;elements del mateix tipus disposats en dues dimensions.\n En aquest cas al tenir dues dimensions en forma de taula, la primera dimensió ens indica les files i la segona les columnes.\nDeclaració A l\u0026rsquo;igual que amb els arrays unidimensionals existeix la part de declarar una referència a la matriu i tot seguit quan cridem el new reservem en memòria l\u0026rsquo;espai on allotjar la informació.\nEn l\u0026rsquo;exemple següent creem una matriu d\u0026rsquo;enters que l\u0026rsquo;anomenem balances de 11 x 6 posicions guardem en memòria 66 enters de forma consecutiva i ordenats per files i columnes.\nPer tal d\u0026rsquo;accedir a un element cal indicar ara dos índexs, un per les files i un per les columnes, si per exemple volgués accedir a l\u0026rsquo;element situat a la 4 fila i 5a columna ho faríem amb balances[3][4]\nint[][] balances = new int[11][6]; int valor = balances[3][4];  Una altra forma de declarar una matriu és amb els valors directament igual com ja havíem vist en l\u0026rsquo;array unidimensional. Per exemple, la següent matriu conté 3 files i 2 columnes:\nint[][] matriu = {13,25},{34,78},{0,-3}};  S\u0026rsquo;observen 3 files i cadascuna conté els valors entre {}, les files entre sí estan separades per una coma.\nLongitud Al igual que els vectors les matrius també poden fer ús de l\u0026rsquo;atribut length (també són Arrays). El que passa que si provem d\u0026rsquo;imprimir matriu.length observarem que mostra el total de files que conté la matriu. Java organitza la informació com un vector de vectors, així que si volem saber el length d\u0026rsquo;una columna cal que fem el següent matriu[i].length.\nFuncionalitat    Funcionalitat Sintaxi Exemples     Declaració d\u0026rsquo;un array 2D tipus[][] nom; int[][] matriu1; double[][] matriu2;   Creació d\u0026rsquo;un array de n files i m columnes nom = new tipus[n][m]; matriu1 = new int [3][2]; matriu2 = new double[5][5];   Declaració d\u0026rsquo;un array 2D inicialitzat tipus[][] nom ={{elem01,\u0026hellip;,elem0n},{elem11,\u0026hellip;,elem1n},\u0026hellip;,{elemm1,\u0026hellip;,elemmn}} int[][] matriu1={{13,25},{34,78},{0,-3}};   Accés a l\u0026rsquo;element de la fila i i columna j nom[i][j] int a = matriu1[1][0];\ndouble m = matriu2[5][8];    Recorregut Per fer un recorregut d\u0026rsquo;un array bidimensional o matriu utilitzarem 2 bucles anidats. Això ens permetrà tenir dos índexos, un per les files i un per les columnes. Per exemple:\nint rows = 10; int cols = 10; int[][] myArray = new int[rows][cols]; for (int i = 0; i \u0026lt; rows; i++){ for (int j = 0; j \u0026lt; cols; j++){ myArray[i][j] = 0; } }  Cerca De la mateixa manera que treballàvem la cerca d\u0026rsquo;un element dins un vector, en les matrius funciona igual, només que ara toca realitzar la cerca en dos bucles anidats. En aquest cas, quan es troba l\u0026rsquo;element (si es troba) cal sortir dels dos bucles.\nEn el següent exemple busquem el 0 dins una matriu de nombres aleatoris:\nboolean trobat=false; int matriu[][] = new int[10][12]; //Introduim valors aleatoris for (int i = 0; i \u0026lt; matriu.length; i++){ for(int j = 0; j \u0026lt; matriu[i].length; j++){ matriu[i][j] = (int) (Math.random() * 100); } } for (int i = 0; i \u0026lt; matriu.length \u0026amp;\u0026amp; !trobat; i++){ for(int j = 0; j \u0026lt; matriu[i].length \u0026amp;\u0026amp; !trobat; j++){ if( matriu[i][j]==0) trobat=true; } } String resposta = (trobat)? \u0026quot;S'ha trobat l'element\u0026quot; : \u0026quot;NO s'ha trobat l'element\u0026quot;; System.out.println(resposta);  Exemple Busquem l\u0026rsquo;element màxim i mínim d\u0026rsquo;una matriu:\nint max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; //RECORREM FILES for(int i=0; i\u0026lt;matriu.length;i++) { //RECORREM COLUMNES for (int j = 0; j \u0026lt; matriu[i].length; j++) { //BUSQUEM ELEMENT MES GRAN i MES PETIT if(matriu[i][j] \u0026gt; max) max = matriu[i][j]; if(matriu[i][j] \u0026lt; min) min = matriu[i][j]; } } System.out.println(\u0026quot;\u0026quot;); System.out.println(\u0026quot;MAX: \u0026quot;+max); System.out.println(\u0026quot;MIN: \u0026quot;+min);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/5coleccions/3hashmap/",
	"title": "Diccionari - Hashmap",
	"tags": [],
	"description": "",
	"content": " HashMap: és una estructura de dades que conté elements que obeeixen a la lògica clau-valor (K-V). La clau és única en tota la col·lecció i identifica un element respecte els altres, els valors poden estar duplicats.\n La definició de la classe HashMap java.util.HashMap i de totes les seves funcionalitats la trobareu a: Java Oracle Classe HashMap\nUtilitza una taula de dispersió per a emmagatzemar la informació de mapa. Les operacions bàsiques (get i put) es faran en temps constant sempre que es dispersin adequadament els elements. El cost de la iteració dependrà del nombre d\u0026rsquo;entrades de la taula i del nombre d\u0026rsquo;elements del mapa. No es garanteix que es respecti l\u0026rsquo;ordre de les claus. Tot hi que se l\u0026rsquo;identifica com una Collection, un HashMap hereta de Map i no de Collection.\nDeclaració\nEn la declaració indicarem de quin tipus és la llista en \u0026lt;K, V\u0026gt;. Per exemple per declarar un HashMap on la clau són enters i els valors són Strings:\nHashMap\u0026lt;Integer,String\u0026gt; hm = new HashMap\u0026lt;Integer,String\u0026gt;();  Funcionalitats principals\nEn l\u0026rsquo;exemple s\u0026rsquo;observa la manipulació d\u0026rsquo;un HashMap primer per un parell\u0026lt;Integer, String\u0026gt; i després per un parell \u0026lt;Integer,Alumne\u0026gt;:\nimport java.util.*; import java.util.stream.Collectors; public class ExHashmap { public static void main(String[] args) { // HashSet de String // Creem el Hashmap HashMap\u0026lt;Integer,String\u0026gt; hm = new HashMap\u0026lt;Integer,String\u0026gt;(); // Afegim elements hm.put(45,\u0026quot;Element 9\u0026quot;); hm.put(23,\u0026quot;Element 2\u0026quot;); hm.put(12,\u0026quot;Element 7\u0026quot;); hm.put(87,\u0026quot;Element 4\u0026quot;); hm.put(97,\u0026quot;Element 5\u0026quot;); hm.put(34,\u0026quot;Element 6\u0026quot;); hm.put(56,\u0026quot;Element 3\u0026quot;); hm.put(32,\u0026quot;Element 8\u0026quot;); hm.put(98,\u0026quot;Element 1\u0026quot;); // Afegim elements amb la mateixa clau hm.put(98,\u0026quot;Element maxacat\u0026quot;); hm.put(56,\u0026quot;Element maxacat\u0026quot;); hm.put(32,\u0026quot;Element maxacat\u0026quot;); hm.put(34,\u0026quot;Element maxacat\u0026quot;); // Imprimim hashmap System.out.println(\u0026quot;\\nRealitzem recorregut de tres maneres diferents\u0026quot;); System.out.println(\u0026quot;1. Mitjançant la key\u0026quot;); for (int key : hm.keySet()) { System.out.println(key+\u0026quot; --\u0026gt; \u0026quot;+hm.get(key)); } System.out.println(\u0026quot;\\n2. Només amb els valors\u0026quot;); for (Object value : hm.values()) { System.out.println((String)value); } System.out.println(\u0026quot;\\n3. Amb valor i clau\u0026quot;); for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : hm.entrySet()) { int key = entry.getKey(); Object value = entry.getValue(); System.out.println(\u0026quot;Per la clau \u0026quot; + key + \u0026quot; tenim el valor \u0026quot; + value); } System.out.println(\u0026quot;\\nSi intento eliminar amb el mètode remove(key), si la key no existeix retorna null\u0026quot;); System.out.println(hm.remove(1)); System.out.println(\u0026quot;\\nSi intento eliminar amb el mètode remove(key), si la key existeix retorna el valor\u0026quot;); System.out.println(hm.remove(98)); //Ordenació mitjançant TreeMap System.out.println(\u0026quot;\\nOrdenem mitjançant un TreeMap\u0026quot;); TreeMap\u0026lt;Integer, String\u0026gt; hmOrdenat = new TreeMap\u0026lt;\u0026gt;(hm); //TreeMap\u0026lt;Integer, String\u0026gt; hmOrdenat2 = new TreeMap\u0026lt;\u0026gt;(); //hmOrdenat2.putAll(hm); System.out.println(\u0026quot;\\nMostrem HashMap ordenat per keys\u0026quot;); for (int key : hmOrdenat.keySet()) { System.out.printf(\u0026quot;key: %s, value: %s\\n\u0026quot;, key, hmOrdenat.get(key)); } /*System.out.println(\u0026quot;\\nMostrem HashMap ordenat per keys\u0026quot;); Set ref = hmOrdenat.keySet(); Iterator it = ref.iterator(); while (it.hasNext()) { int key = (int) it.next(); System.out.println(key + \u0026quot; --\u0026gt; \u0026quot; + hmOrdenat.get(key)); }*/ System.out.println(\u0026quot;\\nMostrem HashMap ordenat per valors\u0026quot;); final Map\u0026lt;Integer, String\u0026gt; ordenarPerString = hm.entrySet() .stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -\u0026gt; e1, LinkedHashMap::new)); for (int key : ordenarPerString.keySet()) { System.out.printf(\u0026quot;key: %s, value: %s\\n\u0026quot;, key, ordenarPerString.get(key)); } //Objectes ALUMNE // HashMap d' objectes Alumne System.out.println(\u0026quot;\\nHASHMAP ALUMNES\u0026quot;); HashMap\u0026lt;Integer, Alumne\u0026gt; alumnes = new HashMap\u0026lt;Integer,Alumne\u0026gt;(); // Afegir element alumnes.put(4,new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;)); alumnes.put(3,new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;)); Alumne al = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); alumnes.put(2,al); alumnes.put(1,new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;)); alumnes.put(5,new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;)); // Imprimim hashmap les altre dues formes d'imprimir també funcionen. System.out.println(\u0026quot;\\nRealitzem recorregut\u0026quot;); System.out.println(\u0026quot;Mostrem HashMap d'alumnes:\u0026quot;); for (int key : alumnes.keySet()) { System.out.println(\u0026quot;key: \u0026quot;+ key +\u0026quot; valor: \u0026quot; + alumnes.get(key)); } //ORDENAR MITJANÇANT ARRAYLIST System.out.println(\u0026quot;\\nOrdenar claus i valors per ArrayList\u0026quot;); List\u0026lt;Integer\u0026gt; keyAlumnes = new ArrayList\u0026lt;\u0026gt;(alumnes.keySet()); Collections.sort(keyAlumnes); System.out.println(\u0026quot;Ordenar claus\u0026quot;); System.out.println(keyAlumnes); List\u0026lt;Alumne\u0026gt; alumnesLlista = new ArrayList\u0026lt;\u0026gt;(alumnes.values()); Collections.sort(alumnesLlista, Alumne.alumnesCompararPerCognom); System.out.println(\u0026quot;\\nOrdenar valors per cognom\u0026quot;); for(Alumne alumne: alumnesLlista) System.out.println(alumne); // Comprovar si conté un objecte System.out.println(\u0026quot;\\nComprovem si conté un element per key\u0026quot;); if (alumnes.containsKey(4)) { System.out.println(\u0026quot;Existeix l'alumne buscat \u0026quot;+alumnes.get(4)); } System.out.println(\u0026quot;\\nComprovem si conté un element per valor\u0026quot;); if (alumnes.containsValue(al)) { System.out.println(\u0026quot;Existeix l'alumne buscat \u0026quot;+alumnes.get(1)); } //Eliminem i recorregut System.out.println(\u0026quot;\\nEliminem l'element amb key: 1\u0026quot;); alumnes.remove(1); System.out.println(alumnes); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/3interficies/",
	"title": "Interfícies",
	"tags": [],
	"description": "",
	"content": "Les interfícies són un pas més cap a l\u0026rsquo;abstracció. Una interfície té tots els mètodes abstractes. Ens serveix per diferenciar la declaració dels mètodes de la seva implementació. S\u0026rsquo;acostuma a crear interfícies per definir característiques/funcionalitats que han de tenir les classes concretes i afegir-les en la seva implementació. Desde Java8 és possible tenir mètodes default implementats per defecte dins les interfícies, ho veurem amb l\u0026rsquo;exemple del diamant al final de la lliçó.\nCaracterístiques de les interfícies:\n Els mètodes d\u0026rsquo;una interfície són públics, en canvi, les interfícies poden ser públiques default. Les interfícies només poden tenir variables públiques, estàtiques i finals, constants. Si no es posa res, es sobreentén que són públiques, estàtiques i finals.  Implementació La declaració d\u0026rsquo;una interfície la faríem de la següent manera:\npublic interface Movible{ int SEGONS_PARTIDA = 200; public void giraDreta(); public void giraEsquerra(); public int frena(); public int anarEndavant(); }  Un cop tenim definit com volem la interfície ara cal incloure-la en les classes. Fins ara utilitzàvem extends ja que la relació era \u0026ldquo;ÉS UN\u0026rdquo;, amb les interfícies estem afegint característiques a un objecte, usarem la paraula implements.\nDe l\u0026rsquo;exemple anterior, si tinguéssim una simulació de vehicles i ens fes falta definir funcions per les funcions físiques de cada vehicle ho podríem fer de la següent manera:\npublic abstract class Vehicle{ protected int velocitat; protected int orientacio; ... } public class Cotxe extends Vehicle implements Movible{ public void giraDreta(){ orientacio = orientacio + 45; } public void giraEsquerra(){ orientacio = orientacio - 45; } public int frena(){ if(velocitat \u0026lt;=10) velocitat = 0; else velocitat -=10; } public int anarEndavant(){ velocitat +=10; } } public class Moto extends Vehicle implements Movible{ public void giraDreta(){ orientacio = orientacio + 60; } public void giraEsquerra(){ orientacio = orientacio - 60; } public int frena(){ if(velocitat \u0026lt;=5) velocitat = 0; else velocitat -=5; } public int anarEndavant(){ velocitat +=5; } }  Si volgués incloure un nou vehicle a la meva simulació tant sols seria necessari que tingués en compte d\u0026rsquo;implementar aquells mètodes que té definits la interfície i també els mètodes abstractes que tingués la classe abstracta.\nUna de les avantatges de les interfícies és que permet més d\u0026rsquo;una implementació per classe a diferència de les herències que en java tenim només herència simple. Podríem tenir com exemple:\npublic interface Movible{ public void A(); } public interface Comercial{ public void B(); } public interface Navegable{ public void C(); } public class Taxi extends Vehicle implements Movible, Comercial{ public void A(){ ... } public void B(){ ... } } public class Veler extends Vehicle implements Movible, Navegable{ public void A(){ ... } public void C(){ ... } }  També, al igual que amb les classes abstractes, podria existir jerarquies de classe dins una interfície, es podrien estendre. Si això passa, les classes concretes haurien d\u0026rsquo;implementar tots aquells mètodes de totes les superclasses de la/les interfície/s utilitzades.\npublic interface InterficieSuper{ public void A(); } public interface InterficieSub extends InterficieSuper{ public void B(); } public class ClasseConcreta implements InterficieSub{ public void A(){ ... } public void B(){ ... } }  Agrupar per funcionalitat Totes les classes que implementen una interfície són compatibles amb el tipus introduït per la interfície. Una interfície no es pot instanciar, però sí s\u0026rsquo;hi pot fer referència. Així, si I és una interface i C és una classe que implementa la interfície, es poden declarar referències al tipus I que apuntin objectes de C: I obj = new C (\u0026lt;paràmetres\u0026gt;); Exemple:\nSeguint amb l\u0026rsquo;exemple anterior amb les interfícies movible, comercial i navegable. Podríem agrupar els objectes concrets en ArrayList d\u0026rsquo;una interfície i realitzar-ne el recorregut:\nArrayList\u0026lt;Movible\u0026gt; movibles= new ArrayList(); mov.add(new Cotxe()); mov.add(new Taxi()); mov.add(new Veler()); for (Movible vehicleMoviment : movibles) { vehicleMoviment.A(); }  Herència múltiple En java existeix el problema que les classes només hereten d\u0026rsquo;un pare, això provoca el conflicte conegut amb el problema del diamant: Problema diamant\nExemple\nSi tenim un mètode definit a A i sobreescrit a B i C, D quin hereta? El de B o el de C?\nPer resoldre-ho, el que faríem en Java seria el següent:\ninterface B{ public default void m1() { System.out.println(\u0026quot;display method of m1 for B\u0026quot;); } } interface C{ public default void m1() { System.out.println(\u0026quot;display method of m1 for C\u0026quot;); } } public class D implements B, C{ public void m1() { B.super.m1(); //or, C.super.m1(); } public static void main(String args[]) { D obj = new D(); obj.display(); } }  Resumint:\n Una interfície pot ser implementada per múltiples classes, de manera similar a com una classe pot ser superclasse de múltiples classes. Les classes que implementen una interfície estan obligades a sobreescriure tots els mètodes definits en la interfície. Si la definició d\u0026rsquo;algun dels mètodes a sobreescriure coincideix amb la definició d\u0026rsquo;algun mètode heretat, aquest desapareix de la classe. Una classe pot implementar múltiples interfícies, a diferència de l\u0026rsquo;herència, que només es permet d\u0026rsquo;una única classe base. Totes les classes que implementen una interfície són compatibles amb el tipus introduït per la interfície. L\u0026rsquo;existència de les interfícies possibilita l\u0026rsquo;existència d\u0026rsquo;una jerarquia de tipus (que no s\u0026rsquo;ha de confondre amb la jerarquia de classes) que permet l\u0026rsquo;herència múltiple.  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/1herencia/3protected/",
	"title": "Ús de Protected",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;herència permet a una classe nova crear-se a partir d\u0026rsquo;una classe existent. La nova classe (subclasse) \u0026ldquo;hereta\u0026rdquo; els atributs i mètodes de la classe primària, i a més a més, té la possibilitat d\u0026rsquo;incorporar nous atributs i mètodes específics a la subclasse.\n Aquesta particularitat permet crear una estructura jeràrquica de classes cada vegada més especialitzada. L\u0026rsquo;herència es basa en la reutilització de classes on es crea una classe nova incorporant atributs i mètodes de la classe pare. Els mètodes heretats poden ser sobreescrits i adoptar un comportament nou o ampliant-ne la seva funcionalitat. Aquesta reutilització permet estalviar molt de temps i adoptar components creats i ja testats.\nConceptes:\n Superclasse: Classe primària o existent en l\u0026rsquo;herència. Subclasse: classe nova i resultant d\u0026rsquo;aplicar herència a una altra classe. Especialització: Procés que permet estendre d\u0026rsquo;una classe pare a una classe filla, ampliant atributs i mètodes. Generalització: Procés de navegar de les classes filles a la classe pare. En la classe pare trobarem els atributs i mètodes comuns a totes les subclasses.  Herència simple\nJava permet l\u0026rsquo;herència simple: qualsevol classe només té una classe pare, no permet l\u0026rsquo;herència múltiple com sí permeten altres llenguatges de programació com el C++. Això ens planteja el problema que a vegades pels requisits de la nostra aplicació és necessari simular l\u0026rsquo;herència múltiple fent ús d\u0026rsquo;interfícies. Per a més informació: problema del diamant\nRelació \u0026ldquo;és un\u0026rdquo; vs \u0026ldquo;conté un\u0026rdquo;\nL\u0026rsquo;herència és una relació d\u0026rsquo;extensió d\u0026rsquo;una classe més específica respecte una classe genèrica, això ens porta a que la classe filla ÉS UNA classe pare, però amb les funcionalitats ampliades/exteses/modificades. A vegades quan es programa existeix el dubte de confondre aquesta relació amb una relació de composició CONTÉ UN, que erròniament entenguem com a subclasse \u0026ldquo;una part\u0026rdquo; de la classe principal. Un exemple seria el següent:\nCom podeu veure en l\u0026rsquo;herència es parteix d\u0026rsquo;un BaseVehicle, que a la vegada s\u0026rsquo;especialitza en un Truck, i a la vegada s\u0026rsquo;especialitza en un TacoTruck. TacoTruck \u0026ldquo;ÉS UN\u0026rdquo; BaseVehicle, TacoTruck és una extensió de BaseVehicle. En canvi Truck \u0026ldquo;CONTÉ UN\u0026rdquo; engine, engine és una part de Truck, no podria substituir l\u0026rsquo;engine per un truck i que es comporti de la mateixa manera.\nUna vegada es conceptualitza el problema a resoldre pots crear el teu arbre jeràrquic. Un exemple amb animals seria:\nImplementació Per tal d\u0026rsquo;indicar que una classe és una herència utilitzarem la paraula extends en la definició de la classe. Per exemple si tenim una classe pare Persona i dos classes filles Alumne i Professor, ho faríem de la següent manera:\npublic class Persona{ ... } public class Alumne extends Persona { ... } public class Professor extends Persona{ ... }  Si la superclasse no està al mateix package que la subclasse, s\u0026rsquo;ha d\u0026rsquo;importar la classe ja que sinó no en tindria visibilitat.\njava.lang.Object\nUna subclasse pot ser a la vegada superclasse d\u0026rsquo;altres classes i crear així un àrbre jeràrquic de classes. En Java totes les classes hereten d\u0026rsquo;una classe mare, la classe arrel de totes és java.lang.Object. Hi ha un conjunt de mètodes que tenen TOTES les classes de Java, inclús les que programeu vosaltres, aquí teniu la descripció de Java Oracle referent a la classe Object.\nTotes les classes per defecte extenen de java.lang.Object, per tant poden fer ús dels mètodes que conté aquesta classe, per exemple:\n toString(): retorna una definició dels atributs en forma de String, aquesta definició la podeu \u0026ldquo;sobreescriure i modificar i adaptar a les vostres necessitats\u0026rdquo;. equals(Object o): mètode per comparar l\u0026rsquo;Objecte o amb l\u0026rsquo;implícit(this), per defecte retorna true si es tracta del mateix objecte (mateixa referència) i false si no. Si volem comparar els atributs per comprovar que es tracta dels mateixos valors serà necessari \u0026ldquo;sobreescriure\u0026rdquo; el mètode i fer que adopti el comportament que volem, això passa per exemple amb el cas de la classe String, ens retorna true si els dos Strings tenen el mateix valor i no si fan referència al mateix objecte. clone(): s\u0026rsquo;utilitza per realitzar una còpia de l\u0026rsquo;objecte. Veurem altres maneres de realitzar còpies.  És el mateix posar en la definició extends Object que no posar-ho.\nfinal\nA vegades, pels requisits de la nostra aplicació no ens interessa que hi pugui haver una herència en una classe, en aquests casos indicaríem mitjançant l\u0026rsquo;atribut final. Per exemple si vull que Persona sigui una classe final i que per tant no es pugui extendre ho marcaria de la següent manera:\npublic final class Persona{ ... }  El mateix passa quan apliquem final a un mètode o a un atribut.\n En el cas del mètode si en la definició posem que és final no ens permetrà en subclasses sobreescriure\u0026rsquo;l, no el podrem modificar.  package paquet.exemplefinal; public class classeOrigen { public final void mostraInfo() { System.out.println(\u0026quot;mostraInfo\u0026quot;); } } package paquet.exemplefinal; public class classeFilla extends classeOrigen { public void mostraInfo() { System.out.println(\u0026quot;mostra una altra info\u0026quot;); } }  En aquest cas donaria un error de compilació ja que intentem sobreescriure un mètode que és definit com a final en la classe pare.\n En el cas d\u0026rsquo;un atribut final un cop inicialitzat no ens permetrà tornar-lo a modificar canviant-li el valor, s\u0026rsquo;utilitza per definir constants.  public class CanviVariable { private final int enter=1; public CanviVariable(int enter){ this.enter = enter; } } public class CanviVariable2 { public static void main(String[] args){ final int enter = 0; enter = 2; } }  Els casos anteriors donarien error ja que volem canviar el valor d\u0026rsquo;una variable que s\u0026rsquo;ha declarat final i ja té valor. En canvi, el cas següent no ens donaria cap error, ja que quan creem l\u0026rsquo;objecte donem valor per primer cop a aquesta variable, això sí, no li podrem canviar el valor en l\u0026rsquo;execució de tot el programa al ser final.\npublic class CanviVariable { private final int enter; public CanviVariable(int enter){ this.enter = enter; } }  Visibilitat\nFins el moment hem observat com els atributs i mètodes públics són accessibles des de fora de la pròpia classe i els que són privats són només accessibles desde dins la pròpia classe.\nAmb l\u0026rsquo;herència apareix la visibilitat protected, que permet tenir visibilitat d\u0026rsquo;atributs i mètodes situats en:\n la mateixa classe les seves subclasses altres classes del mateix package  Com s\u0026rsquo;observa existeix l\u0026rsquo;opció default quan no indiquem cap atribut de visibilitat, les classes declarades com a default tenen accés a totes les classes del propi package.\nSobreescriptura\nMés amunt hem comentat el concepte de sobreescriptura, aquesta és una de les característiques polimòrfiques que tenim amb els llenguatges POO.\nLa sobreescriptura ens permet modificar mètodes definits en la superclasse. Per tant ens permet canviar el comportament de mètodes que ja estan definits en la classe pare.\n Quan sobreescrivim un mètode podem utilitzar la paraula @Override sobre la definició del mètode per indicar-li a Java que sobreescrivim un mètode la superclasse.\nEx, sobreescrivim el comportament que ens dóna java.lang.Object per toString():\npublic class Enter{ int valor; @Override public String toString() { return \u0026quot;El valor d'Enter és:\u0026quot; + this.valor; } }  Constructors i super\nQuan definim els mètodes constructors de les subclasses, és necessari primer cridar la constructora de la classe pare, això és possible gràcies a super() o super(parametres). Quan es crea un fill primer sempre es comença inicialitzant les variables del pare i després s\u0026rsquo;inicialitzen les del fill. Si no posem cap mètode super, per defecte intentarà buscar super() en el pare, si no existís hi hauria un error de compilació.\npublic class Persona{ String dni; public Persona(String dni){ this.dni = dni; } } public class Alumne extends Persona{ int matricula; public Alumne(String dni, int matricula){ super(dni); this.matricula = matricula; } } //Error de compilació ja que la constructora Persona() com a tal no existeix public class Alumne extends Persona{ int matricula; public Alumne(int matricula){ super(); this.matricula = matricula; } }  Exemple\nRealitzem un exemple de com seria una herència amb classe pare Producte i classe Filla ProducteDescompte.\npublic class Producte { protected String nom; protected double preu; public Producte(String nom, double preu) { this.nom = nom; this.preu = preu; } public void anunci() { System.out.println(\u0026quot;Hola sóc el producte \u0026quot; + nom); } public double valorProducte() { return preu; } } public class ProducteDescompte extends Producte { private int descompte; public ProducteDescompte(String nom, double preu, int descompte) { super(nom, preu); this.descompte = descompte; } @Override public void anunci() { super.anunci(); System.out.println( \u0026quot;Tinc un descompte de \u0026quot; + descompte+\u0026quot;%\u0026quot;); } @Override public double valorProducte() { return preu - (preu*descompte)/100; } public void rebaixaNouDescompte(int rebaixa){ this.descompte = this.descompte - rebaixa; } public void augmentaNouDescompte(int augment){ this.descompte = this.descompte + augment; } } public class Programa { public static void main(String[] args) { Producte p = new Producte(\u0026quot;Llapis\u0026quot;, 100.0); p.anunci(); System.out.println(\u0026quot;El preu del producte és \u0026quot; + p.valorProducte()); System.out.println(); ProducteDescompte p1 = new ProducteDescompte(\u0026quot;Llapis rebaixat\u0026quot;, 100.0, 10); p1.anunci(); System.out.println(\u0026quot;El preu d'un nou producte rebaixat és \u0026quot; + p1.valorProducte()); System.out.println(); p1.augmentaNouDescompte(10); p1.anunci(); System.out.println(\u0026quot;El preu del producte després de modificar la rebaixa és \u0026quot; + p1.valorProducte()); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/3manipulaciofitxers/3accesaleatori/",
	"title": "Accés aleatori",
	"tags": [],
	"description": "",
	"content": "Accés aleatori RandomAccessFile: https://docs.oracle.com/javase/8/docs/api/java/io/RandomAccessFile.html\nAltres classes PrintWritter: https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html\nPrintStream: https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html\nDataInputStream: https://docs.oracle.com/javase/8/docs/api/java/io/DataInputStream.html\nDataOutputStream: https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html\nExemple de RandomAccessFile Observa diferents circumstàncies d\u0026rsquo;ús d\u0026rsquo;aquesta classe. És molt útil quan guardem informació en un fitxer de text i sabem la posició exacta on hi ha cada peça d\u0026rsquo;informació. Aquesta classe permet moure\u0026rsquo;ns per tot el fitxer, sense haver de fer-ho seqüencialment, sinó que permet posar el punter de L/E en qualsevol posició del fitxer.\npackage exemples; import java.io.FileNotFoundException; import java.io.IOException; import java.io.RandomAccessFile; public class RAF { public static void main(String[] args) { String path = \u0026quot;f1.txt\u0026quot;; String data = \u0026quot;data\u0026quot;; RandomAccessFile raf; try { // RAF L/E fitxer text plà // Lectura System.out.println(\u0026quot;Fitxer \u0026quot; + path + \u0026quot;:\u0026quot;); raf = new RandomAccessFile(path, \u0026quot;rw\u0026quot;);\tString line; while ((line = raf.readLine()) != null) { System.out.println(line); } // Escriptura //raf.writeChars(\u0026quot;RAF\\n\u0026quot;); raf.close(); System.out.println(\u0026quot;\\nFitxer \u0026quot; + data + \u0026quot;:\u0026quot;); // RAF L/E fitxer binari int num = 1000000; raf = new RandomAccessFile(data, \u0026quot;rw\u0026quot;); raf.seek(raf.length()); // Situem el cursor al final del fitxer //raf.seek(12); // Situem el cursos al byte 12, és a dir per sobreescriure el 4art int raf.writeInt(num); raf.seek(0); // Situem el cursor al principi del fitxer // Mentre la posició del cursor sigui més petita que el tamany del fitxer while (raf.getFilePointer() \u0026lt; raf.length()) { num = raf.readInt(); System.out.println(num); } raf.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } }  DataInputStream i DataOutputStream Aquesta classe es treballa àmpliament al M06 Accés a Dades, aquí ens quedem amb la idea que permet lectura i escriptura indicant el tipatge de la dada que estem treballant. L\u0026rsquo;exemple següent és utilitzant un enter (writeInt readInt).\npackage exemples; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; public class DataIOStream { public static void main(String[] args) { String path = \u0026quot;fint.data\u0026quot;; int num = 39568; try { // Escriure a un fitxer un int (4 bytes) // Si el fitxer no existeix es crea // Si el fitxer existeix el true del FileOutputStream fa que el int s'afegeixi al final DataOutputStream dos = new DataOutputStream(new FileOutputStream(path, true)); dos.writeInt(num); dos.close(); // Llegir un int (4 bytes) d'un fitxer. // Es llegeixen el 4 primers bytes del fitxer DataInputStream dis = new DataInputStream(new FileInputStream(path)); System.out.println(dis.readInt()); dis.close(); } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } }  Resum Recordatori Aquest és un exemple que permet llegir fitxers de text caràcter a caràcter, llegir línies, llegir fitxers binaris d\u0026rsquo;enters, de reals o de bytes.\npackage exemples; import java.io.*; public class LecturaFitxer { public static void main (String[] args) { File f = new File (\u0026quot;Fitxer.txt\u0026quot;); System.out.println(\u0026quot;Tamany del fitxer en bytes: \u0026quot; + f.length()); System.out.println(\u0026quot;-----------------------------\u0026quot;); System.out.println(\u0026quot;Lectura com a fitxer de text plà caràcter a caràcter:\u0026quot;); llegirCharAChar(f); System.out.println(\u0026quot;-----------------------------\u0026quot;); System.out.println(\u0026quot;Lectura com a fitxer de text plà línia a línia:\u0026quot;); llegirLiniaALinia(f); System.out.println(\u0026quot;-----------------------------\u0026quot;); System.out.println(\u0026quot;Lectura com a fitxer binari llegint enters (4 bytes):\u0026quot;); llegirBinariInt(f); System.out.println(\u0026quot;-----------------------------\u0026quot;); System.out.println(\u0026quot;Lectura com a fitxer binari llegint reals (8 bytes):\u0026quot;); llegirBinariReal(f); System.out.println(\u0026quot;-----------------------------\u0026quot;); System.out.println(\u0026quot;Lectura com a fitxer binari llegint bytes:\u0026quot;); llegirBinariByte(f); } public static void llegirCharAChar(File f) { try { BufferedReader in = new BufferedReader(new FileReader(f)); char[] car = new char[1]; String text = \u0026quot;\u0026quot;; while((in.read(car, 0, 1)) \u0026gt; -1) { text = text + new String(car, 0, 1); } in.close(); System.out.println(text); } catch(Exception e) { System.out.println(\u0026quot;Error de fitxer: \u0026quot; + e.getMessage()); } } public static void llegirLiniaALinia(File f) { try { BufferedReader in = new BufferedReader(new FileReader(f)); String linia, text = \u0026quot;\u0026quot;; while((linia = in.readLine()) != null) { text = text + linia; if (in.ready()) text = text + \u0026quot;\\n\u0026quot;; } in.close(); System.out.println(text); } catch(Exception e) { System.out.println(\u0026quot;Error de fitxer: \u0026quot; + e.getMessage()); } } public static void llegirBinariInt(File f) { try { RandomAccessFile raf = new RandomAccessFile(f, \u0026quot;r\u0026quot;); long numInts = f.length()/4; for (int i = 0; i \u0026lt; numInts; i++) { System.out.println(raf.readInt()); } raf.close(); } catch (Exception e) { System.out.println(\u0026quot;Error mostrant fitxer: \u0026quot; + e.getMessage()); } } public static void llegirBinariReal(File f) { try { RandomAccessFile raf = new RandomAccessFile(f, \u0026quot;r\u0026quot;); long numReals = f.length()/8; for (int i = 0; i \u0026lt; numReals; i++) { System.out.println(raf.readDouble()); } raf.close(); } catch (Exception e) { System.out.println(\u0026quot;Error mostrant fitxer: \u0026quot; + e.getMessage()); } } public static void llegirBinariByte(File f) { try { RandomAccessFile raf = new RandomAccessFile(f, \u0026quot;r\u0026quot;); long numReals = f.length(); for (int i = 0; i \u0026lt; numReals; i++) { System.out.println(raf.readByte()); } raf.close(); } catch (Exception e) { System.out.println(\u0026quot;Error mostrant fitxer: \u0026quot; + e.getMessage()); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/2accions/3actualitzacio/",
	"title": "Actualització",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/3algorisme/",
	"title": "Algorisme",
	"tags": [],
	"description": "",
	"content": "Què és un algorisme? Un algorisme és un mètode per resoldre un PROBLEMA, són un conjunt d\u0026rsquo;operacions finites i ordenades que s\u0026rsquo;han de seguir per a la resolució d\u0026rsquo;un problema.\n Característiques dels algorismes\nLes característiques bàsiques d\u0026rsquo;un algorisme són:\n Ordenat. Cada instrucció té una posició dins el conjunt. Precís. Cada instrucció és unívoca i obeeix a un objectiu. Definit. Si es segueix un algorisme dues vegades, s\u0026rsquo;ha d\u0026rsquo;obtenir el mateix resultat cada vegada. Finit. L\u0026rsquo;algorisme ha d\u0026rsquo;acabar en algun moment, per tant, tindrà un nombre finit de passos. Un bon disseny algorítmic contindrà tres parts: Entrada (Input), Procés (Tractament de la informació) i Sortida (Output).  Pseudocodi El pseudocodi és un llenguatge informal d’alt nivell que usa les convencions i l’estructura d’un llenguatge de programació, però que està orientat a ser entès pels humans.\n Exemple\n//El problema consisteix en: Llegir el radi d'un cercle i calcular i imprimir per pantalla l'àrea i el perímetre. //Inputs: Radi del cercle (Variable radi). //Outputs: Àrea del cercle (Variable area) i Perímetre del cercle (Variable perimetre) //Variables: radi, area i perimetre de tipus Real. IniciProces Cercle Definir radi, area i perimetre com a tipus Reals; Escriure \u0026quot;Introdueix el radi de la circumferència\u0026quot;; Llegir radi; area \u0026lt;- PI * radi ^ 2; perimetre \u0026lt;- 2 * PI * radi; Escriure \u0026quot;L'àrea és \u0026quot;, area; Escriure \u0026quot;El perímetre és \u0026quot;, perimetre; FiProces  Diagrama de flux Un diagrama de flux de control consisteix en una subdivisió de passes seqüencials, d’acord amb les sentències i estructures de control d’un programa, que mostra els diferents camins que pot seguir un programa a l’hora d’executar les seves instruccions. Cada passa s’associa a una figura geomètrica específica.\n Una eina per dibuixar diagrames de flux és Code2Flow, a partir d\u0026rsquo;un pseudocodi és capaç de dibuixar automàticament el diagrama de flux pertinent.\nSi agafem el cas anterior i \u0026lsquo;l\u0026rsquo;adaptem\u0026rsquo; a les regles que ens demanen aconseguim el següent resultat: Complexitat ciclomàtica La Complexitat ciclomàtica (en anglès, Cyclomatic Complexity) és una mètrica de programari en enginyeria de programari que proporciona una mesura quantitativa de la complexitat lògica d\u0026rsquo;un programa. Consisteix en comptar el nombre de camins necessaris per tal d\u0026rsquo;anar de la primera a la última instrucció passant per tots els camins possibles i cobrint tots els casos.\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/4tipusdades/3conversions/",
	"title": "Conversions",
	"tags": [],
	"description": "",
	"content": "En Java existeix el type casting que permet convertir una variable en una altra. Quan realitzem un casting estem modificant el TIPUS de la variable.\nEl següent exemple de casos és bastant explicatiu:\npublic class Main { public static void main(String[] args) { System.out.println(1 / 3); // 0 System.out.println(1.0 / 3); // 0.3333333333333333 System.out.println(1 / 3.0); // 0.3333333333333333 System.out.println((double) 1 / 3); // 0.3333333333333333 System.out.println((double) (1 / 3)); // 0.0 } }  Com s\u0026rsquo;observa la primera divisió utilitza / entre dos enters, per això, malgrat que el valor és 0.333\u0026hellip; es queda amb la part entera que és 0. Els dos casos següents dividim un nombre de tipus double amb un enter, així que per defecte retorna com a tipus de la divisió un double.\nEls dos últims casos és on apliquem Casting. Si us hi fixeu el 4rt cas és similar al primer amb la diferència que el resultat de la divisió entre dos nombres enters el \u0026ldquo;convertim\u0026rdquo; a double, de forma que permet guardar tots els decimals que perdíem en la divisió entre dos enters.\nEn l\u0026rsquo;últim cas no ens apareixen els decimals ja que primer es realitza l\u0026rsquo;operació entre els dos nombres enters i el resultat és enter, i una vegada obtenim el resultat (0), el convertim a double 0.0.\nEl casting és molt emprat en moltes situacions diferents en programació. A mesura que avancem i veiem classes i objectes veureu com també podem aplicar Casting entre diferents classes.\nSituacions senzilles de casting A vegades és necessari quedar-nos amb la part entera d\u0026rsquo;un nombre decimal:\nfloat decimal = 5.45f; int partEntera = (int)decimal; //partEntera = 5  A vegades només amb la part decimal, float double no ens guarden la precisió al castejar, en aquests casos utilitzaríem BigDecimal que sí que seria exacte;\nfloat decimal = 5.45f; float partDecimal = decimal - (int)decimal; //partEntera = 0.49999...  Un altre exemple on es pot apreciar fàcilment la diferència entre els decimals que pot guardar un double (64 bits) o un float (32 bits) és:\nfloat b=1.0f; double a = Math.PI *b; System.out.println(a); // 3.141592653589793 System.out.println((float)a); // 3.1415927  Un altre casting podria ser passar un caràcter a un enter. El caràcter és un tipus que ocupa 16 bits i que es pot transformar en un nombre fàcilment seguint la taula ASCII. Així doncs obtenim:\nchar a = 'a'; System.out.println(a); // a System.out.println((int)a); // 97 a++; System.out.println(a); // b System.out.println((int)a); // 98  De la mateixa manera a la inversa també obtindríem el mateix:\nint a = 97; System.out.println(a); // 97 System.out.println((char)a); // a  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/1acces/3connexio/",
	"title": "Establiment de la connexió",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/3classemetodes/",
	"title": "Estructura de classe i mètodes",
	"tags": [],
	"description": "",
	"content": "Atributs de la instància (propietats de la classe) Les variables locals es declaren dins un àmbit de visibilitat, per exemple, com ja hem vist, les variables creades dins un while/for estan actives dins aquest àmbit, després desapareixen.\nCada classe té les seves propietats. En la creació de l\u0026rsquo;objecte aquestes poden prendre uns valors determinats que dónen sentit al propi objecte. Aquests valors estan actius durant la vida d\u0026rsquo;aquest objecte, això vol dir que quan aquest objecte es destrueix aquests valors deixen d\u0026rsquo;existir. Cada objecte de cada classe manté una còpia de les propietats amb els seus respectius valors.\nGetters \u0026amp; Setters En la definició de qualsevol classe existeixen uns mètodes particulars que ens ajuden a interactuar amb les propietats de la classe:\n Getters: són mètodes que ens permeten accedir al contingut d\u0026rsquo;una variable d\u0026rsquo;instància. Setters: són mètodes que ens permeten modificar el contingut d\u0026rsquo;una variable d\u0026rsquo;instància.  Les classes en Java estan estructurades sota el principi d\u0026rsquo;encapsulació. Per això, declarem les propietats de la classe com a privades (podríem haver-les fet públiques) encapsulem (amaguem) les propietats. Així, aquestes sols es poden modificar des dels mètodes setNomVariable (setter) que els declarem públics. Evitem modificacions accidentals des de qualsevol lloc del programa. De la mateixa manera, si volem accedir a un valor d\u0026rsquo;una propietat d\u0026rsquo;un objecte existeixen els mètodes getters.\nAixí doncs la manera de minimitzar errors i a la vegada d\u0026rsquo;ocultar el tipus de les variables (la qual cosa ens dóna flexibilitat si en un futur existeixen modificacions en l\u0026rsquo;estructura de dades de la pròpia classe) és creant les propietats de classe com a privats i implementar els seus mètodes get i set públics. L\u0026rsquo;accés des de fora la classe a cada propietat serà a través dels mètodes esmentats. Així per a cada propietat de la classe implementarem un getter i un setter.\nReprenem l\u0026rsquo;exemple anterior i afegim dues propietats a Persona: nom i edat, afegim degudament els seus getters \u0026amp; setters i en comprovem el funcionament en el PersonaTest creant dos exemples de Persona diferents.\npackage exemple1.versio2; public class Persona { private String nom; private int edat; public String getNom(){ return nom; } public int getEdat(){ return edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; } public void saluda() { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom + \u0026quot; i tinc \u0026quot; + edat + \u0026quot; anys\u0026quot;); } }  package exemple1.versio2; import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String nomPersona1 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); int edat1 = sc.nextInt();sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); String nomPersona2 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); int edat2 = sc.nextInt(); sc.close(); Persona persona1 = new Persona(); Persona persona2 = new Persona(); persona1.setNom(nomPersona1); persona1.setEdat(edat1); persona2.setNom(nomPersona2); persona2.setEdat(edat2); System.out.println(\u0026quot;El nom de la persona1 es: \u0026quot;+persona1.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona1.getEdat()); System.out.println(\u0026quot;El nom de la persona2 es: \u0026quot;+persona2.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona2.getEdat()); persona1.saluda(); persona2.saluda(); } }  Observacions:\n El getNom i getEdat retornen el valor de la propietat d\u0026rsquo;un objecte determinat. Per la seva banda setNom i setEdat modifiquen el contingut de la propietat pertinent. Fixem-nos que saluda() ja no té com a paràmetre d\u0026rsquo;entrada el nom ja que l\u0026rsquo;agafa de la pròpia classe. La propietat és privada i per tant no és accessible des de fora la classe (s\u0026rsquo;accedeix mitjançant el getNom) però sí que ho és desde dins la classe, en saluda().  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/3manipulaciofitxers/",
	"title": "Manipulació de fitxers",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/zzz_gesti%C3%B3-bbddor/3.crudmapeigor/",
	"title": "Operacions CRUD i mapeig objecte-relacional",
	"tags": [],
	"description": "",
	"content": "Les sigles CRUD fan referència a create, read, update i delete, que són les operacions bàsiques que es realitzen en una base de dades.\nEn el nostre paradigma de la Programació Orientada a Objectes, haurem de dotar a les nostres classes de mètodes que gestionin la seva persistència en base de dades. Això ho farem amb la tècnica de mapeig objecte-relacional, que consisteix en mapejar cada classe amb una taula de la base de dades, i cada atribut, amb una columna de la taula corresponent. Convertint cada objecte en un registre de la taula i cada registre, en un objecte Java.\nPer tant, cada classe persistent, haurem de dotar-la dels mètodes create(), read(), update() i delete().\nExemple de read:\npublic Album llegeixAlbum(int idAlbum) { Statement stmt = null; Album album = null; try { String query = \u0026quot;SELECT * FROM Album WHERE AlbumId = ?\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setInt(1,idAlbum); ResultSet rs = ps.executeQuery(); while ( rs.next() ) { int albumId = rs.getInt(\u0026quot;AlbumId\u0026quot;); String title = rs.getString(\u0026quot;Title\u0026quot;); int artistId = rs.getInt(\u0026quot;ArtistId\u0026quot;); album = new Album(albumId, title, artistId); } rs.close(); ps.close(); } catch ( Exception e ) { System.err.println( e.getClass().getName() + \u0026quot;: \u0026quot; + e.getMessage() ); } System.out.println(\u0026quot;Operation done successfully\u0026quot;); return album; }  Exemple de delete:\npublic void eliminaAlbum(int idAlbum) { try { con.setAutoCommit(false); String query = \u0026quot;DELETE from Album where AlbumId=?\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setInt(1,idAlbum); ps.executeUpdate(); con.commit(); ps.close(); } catch ( Exception e ) { System.err.println( e.getClass().getName() + \u0026quot;: \u0026quot; + e.getMessage() ); } System.out.println(\u0026quot;Operation done successfully\u0026quot;); }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/3tipusdadesobjecte/",
	"title": "Tipus de dades Objecte",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/",
	"title": "AEA4. POO Avançada",
	"tags": [],
	"description": "",
	"content": "En aquesta segona part de la UF coneixerem i implementarem característiques de la POO que dónen sentit al desenvolupament d\u0026rsquo;aplicacions:\n  Herència\n  Polimorfisme i classes abstractes\n  Interfícies\n  Bones pràctiques en POO\n  Principis SOLID\n  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/4bonespractiques/",
	"title": "Bones pràctiques en POO",
	"tags": [],
	"description": "",
	"content": "En aquesta segona part de la UF coneixerem i implementarem característiques de la POO que dónen sentit al desenvolupament d\u0026rsquo;aplicacions:\n  Herència\n  Polimorfisme i classes abstractes\n  Interfícies\n  Bones pràctiques en POO\n  Principis SOLID\n  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/4bonespractiques/1defensivecopy/",
	"title": "Defensive copy",
	"tags": [],
	"description": "",
	"content": "En aquesta segona part de la UF coneixerem i implementarem característiques de la POO que dónen sentit al desenvolupament d\u0026rsquo;aplicacions:\n  Herència\n  Polimorfisme i classes abstractes\n  Interfícies\n  Bones pràctiques en POO\n  Principis SOLID\n  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/5coleccions/4genericitat/",
	"title": "Genericitat",
	"tags": [],
	"description": "",
	"content": "Tipus Genèrics Són Tipus Parametritzat. Permet indicar per paràmetre el tipus de dades sobre els que s\u0026rsquo;opera en classes, interfícies o mètodes.\nEls tipus genèrics permeten escriure codi que resulta més segur i més fàcil de llegir. Els tipus genèrics són especialment útils amb les classes heredades de la interfície Collections.\nEls tipus genèrics permeten reutilitzar objectes de diferents tipus. El tipus genèric comporta l\u0026rsquo;abstracció de les operacions que es poden fer a conjunts diferents de dades.\nQuan parlem d\u0026rsquo;operacions que es poden fer a un determinat conjunt de dades, gairebé sempre hi tindrem:\n Afegir elements. Inserir elements. Esborrar elements. Actualitzar elements. Obtenir un element. Iterar pels elements.  Independentment del tipus dels elements que formen la llista dels elements, el tipus genèric ens permet aplicar una classe a un objecte concret ja sigui String, File, o objectes de classe com Llibre, Cotxe\u0026hellip;\nUtilitzar un tipus genèric a l\u0026rsquo;hora de crear una col·lecció permet:\n Crear estructures generalistes i reutilitzables independent de l\u0026rsquo;Objecte/dada que s\u0026rsquo;apliqui. El codi on es passa un paràmetre com a genèric treballarà automàticament amb el tipus de dades que hem passat. Per exemple QuickSort treballa de la mateixa manera independentment del tipus de dades amb els que operi: String, Integers\u0026hellip; Treballar automàticament amb el tipus de dades passades al vostre paràmetre de tipus  normalment Type, tot hi que també pot haver E o V. Controlar en temps de compilació ja que tots els elements són del tipus genèric.  Exemple de classe genèrica:\npublic class Cotxe { private String marca; public Cotxe(String marca) { super(); this.marca = marca; } public String getMarca() { return marca; } public void setMarca(String marca) { this.marca = marca; } } import java.util.ArrayList; import java.util.Iterator; public class Conjunt \u0026lt;T\u0026gt; implements Iterable \u0026lt;T\u0026gt; { private ArrayList \u0026lt;T\u0026gt; llista = new ArrayList \u0026lt;T\u0026gt; (); private int tamany; public Conjunt(int tamany) { super(); this.tamany = tamany; } public void add(T objecte) { if (llista.size() \u0026gt;= tope) { llista.add(objecte); } else { throw new RuntimeException(\u0026quot;no caben mas\u0026quot;); } } public Iterator \u0026lt;T\u0026gt; iterator() { return llista.iterator(); } } public class Principal { public static void main(String[] args) { Conjunt \u0026lt;Cotxe\u0026gt; conjuntCotxes = new Conjunt \u0026lt;Cotxe\u0026gt; (); Cotxe c = new Cotxe(\u0026quot;Audio\u0026quot;); Cotxe c1 = new Cotxe(\u0026quot;Merceditas\u0026quot;); Cotxe c2 = new Cotxe(\u0026quot;Seaton\u0026quot;); conjuntCotxes.add(c); conjuntCotxes.add(c1); conjuntCotxes.add(c2); for (Cotxe cotxe: conjuntCotxes) { System.out.println(cotxe.getMarca()); } } }  Si ara canviem l\u0026rsquo;objecte Cotxe per l\u0026rsquo;objecte Llibre, podem utilitzar la classe genèrica Conjunt igual ja que és independent del tipus de dades que la usi al ser genèrica.\npublic class Llibre { private String titol; public Llibre(String titol) { super(); this.titol = titol; } public String getTitol() { return titol; } public void setTitol(String titol) { this.titol = titol; } } public class Principal { public static void main(String[] args) { Conjunt \u0026lt;Llibre\u0026gt; conjuntLlibres = new Conjunt \u0026lt;Llibre\u0026gt; (); Llibre c = new Llibre(\u0026quot;Aventures del Poblenou\u0026quot;); Llibre c1 = new Llibre(\u0026quot;Superherois de DAM\u0026quot;); Llibre c2 = new Llibre(\u0026quot;La vida a l'institut Poblenou\u0026quot;); conjuntLlibres.add(c); conjuntLlibres.add(c1); conjuntLlibres.add(c2); for (Llibre llibre: conjuntLlibres) { System.out.println(llibre.getTitol()); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/5solid/",
	"title": "Principis SOLID",
	"tags": [],
	"description": "",
	"content": "En aquesta segona part de la UF coneixerem i implementarem característiques de la POO que dónen sentit al desenvolupament d\u0026rsquo;aplicacions:\n  Herència\n  Polimorfisme i classes abstractes\n  Interfícies\n  Bones pràctiques en POO\n  Principis SOLID\n  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4poo/4bonespractiques/2excepcions/",
	"title": "Tractament de les excepcions",
	"tags": [],
	"description": "",
	"content": "La Jerarquia de classes establerta de Java pel que fa Error i Exception és la següent.\nExemples d\u0026rsquo;excepcions\nArrayIndexOutOfBoundsException\npublic static void main(String[] args) { int arr[]=new int[10]; try { int valor=arr[10]; }catch (ArrayIndexOutOfBoundsException e){ System.out.println(\u0026quot;Índex fora de límit!: \u0026quot;+ e.getMessage()); } }  Els casos anteriors haguessis pogut substituir el tipus de l\u0026rsquo;Excepció per Exception ja que tots són de tipus Exception només que estan especialitzats pel tipus d\u0026rsquo;error que capturen.\nTot seguit anem a veure com capturem una excepció que es produeix en un altre mètode que cridem des del principal, posem per exemple l\u0026rsquo;ArithmeticException anterior.\npublic static void main(String[] args) { public static int numerador = 10; public static int denominador = 0; try { dividir(); } catch (ArithmeticException e) { System.err.println(e); } } public static void dividir() throws ArithmeticException { System.out.println(numerador / denominador); }  En el cas anterior si no capturéssim l\u0026rsquo;excepció en el main() hi hauria un error i pararia el programa, però com que \u0026ldquo;capturem\u0026rdquo; l\u0026rsquo;excepció i en fem un tractament específic Java continua amb la seva excecució normal. Fixeu-vos que en aquest cas en el mètode dividir() hem utilitzat throws ArithmeticException, d\u0026rsquo;aquesta manera quan es detecta una excepció d\u0026rsquo;aquest tipus, l\u0026rsquo;excepció és propagada cap a la funció que ha cridat aquest mètode, derivant-ne així la responsabilitat del seu tractament.\nEn Java les excepcions que són subclases de Error o RuntimeException no necessiten ser especificades en la llista de throws, Java ho fa automàticament, la resta d\u0026rsquo;Excepcions sí és necessari, del contrari es produeix un error en temps de compilació.\nEs podrien encadenar uns quants throws Exception com seria:\npublic static void main(String[] args) { public static int numerador = 10; public static int denominador = 0; try { dividir1(); } catch (ArithmeticException e) { System.err.println(e); } } public static void dividir1() throws ArithmeticException { dividir2; } public static void dividir2() throws ArithmeticException { System.out.println(numerador / denominador); }  Jerarquia de les Excepcions\nCom us he comentat anteriorment, la captura de l\u0026rsquo;Excepció és jeràrquica, de forma que l\u0026rsquo;excepció serà capturada pel primer Catch que l\u0026rsquo;accepti, per això és tant important ordenar els catch de més específic a més genèric. Continuant amb l\u0026rsquo;exemple anterior:\npublic static void main(String[] args) { int numerador = 10; int denominador = 0; try{ int n = numerador / denominador; }catch(ArithmeticException e){ System.out.println(\u0026quot;Has volgut dividir entre 0 : \u0026quot; + e.toString()); n = 0; }catch(Exception e){ System.out.println(\u0026quot;Aquí no s'hi accedirà ja que l'Excepció en aquest cas serà capturada per ArithmeticException\u0026quot;); } }  Exemples més complerts amb encadenament d\u0026rsquo;excepcions\nUn exemple més complert on barregem diferents Exceptions podria ser el següent:\npublic class TryEncadenat{ public static void main(String[] args) { int nums[]={4,8,16,32,64,128,256,512}; int denom[]={2,0,4,4,0,8}; try { for (int i = 0; i \u0026lt; nums.length; i++) { try { System.out.println(nums[i] + \u0026quot; / \u0026quot; + denom[i] + \u0026quot; es \u0026quot; + nums[i] / denom[i]); } catch (ArithmeticException exc) { System.out.println(\u0026quot;No es pot dividir entre 0!\u0026quot;); } } } catch (ArrayIndexOutOfBoundsException exc) { System.out.println(\u0026quot;Un dels dos arrays s'ha quedat sense més valors. FINALITZA aquí!\u0026quot;); } } }  Un altre exemple podria ser:\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int [] array = {4,2,6,7}; int n; boolean repetir = false; do{ try{ repetir = false; System.out.print(\u0026quot;Introdueix un valor \u0026gt; 0 i \u0026lt; \u0026quot; + array.length + \u0026quot; \u0026quot;); n = sc.nextInt(); System.out.println(\u0026quot;Valor en la posició \u0026quot; + n + \u0026quot;: \u0026quot; + array[n]); }catch(InputMismatchException e){ sc.nextLine(); n = 0; System.out.println(\u0026quot;Has d'introduir un valor enter \u0026quot;); repetir = true; }catch(IndexOutOfBoundsException e){ System.out.println(\u0026quot;Has d'introduir un valor enter \u0026gt; 0 i \u0026lt; \u0026quot; + array.length + \u0026quot; \u0026quot;); repetir = true; }catch(Exception e){ //Resta d'excepcions System.out.println(\u0026quot;Error inesperat \u0026quot; + e.toString()); repetir = true; } }while(repetir); }  Un altre exemple multi-exception\nExcepcions pròpies\nTambé és possible generar les nostres pròpies Excepcions. Moltes vegades, degut a l\u0026rsquo;especificació que tenim, és necessari que creem les nostres pròpies excepcions que dónen sentit a certes circumstàncies i que el ventall d\u0026rsquo;Excepcions de Java no cobreix. L\u0026rsquo;únic que haurem de fer és heredar de la classe Exception i adaptar el comportament a la constructora i també al missatge de sortida que volem que es mostri quan es produeixi l\u0026rsquo;excepció.\npublic class MajoriaEdatExcepcio extends Exception{ private int edat; MajoriaEdatExcepcio (int n){ this.edat = n; } @Override public String toString() { return \u0026quot;Excepcio: Majoria Edat [edat \u0026quot;+this.edat+\u0026quot;]\u0026quot;; } }  Aquesta excepció s\u0026rsquo;instancia un cop es genera l\u0026rsquo;Excepció (throw new MajoriaEdatExcepcio(n)). Per tant, la situació podria ser la següent:\npublic class MajoriaEdat { public static void main(String[] args) { Scanner sc = new Scanner(System.in); try{ int edat = sc.nextInt(); if(edat\u0026lt;18) throw new MajoriaEdatExcepcio(edat); System.out.println(\u0026quot;L'edat introduida és major d'edat\u0026quot; + edat); } catch (MajoriaEdatExcepcio e){ System.out.println(e); } } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/zzz_gesti%C3%B3-bbddor/4.classes-dao/",
	"title": "Classes DAO",
	"tags": [],
	"description": "",
	"content": "Les operacions relacionades amb la persistència dels objectes en bases de dades, en realitat, no formen part de la responsabilitat de l’entitat que representa la classe. Per exemple, la classe Album dels exemples ha d’ocupar-se de les operacions relacionades amb la lògica del negoci que estem modelant però els mètodes CRUD quedarien fora de la seva responsabilitat.\nSi volem que una classe es guardi en una base de dades, hem de crear una segona classe amb nom NomClasseDAO que implementi les operacions CRUD d’accés a base de dades. Idealment, a més, aquest DAO serà una interfície i implementarem una classe concreta per a cada tecnologia de base de dades que necessitem.\nClasse de negoci / model del domini:\npublic class Album { private int idAlbum; private String nom; private int idArtista; public Album(int idAlbum, String nom, int idArtista) { this.idAlbum = idAlbum; this.nom = nom; this.idArtista = idArtista; } public Album() { } //… (getters + setters + toString) }  Interfície AlbumDAO:\npublic interface AlbumDao { public int create(Album album) throws SQLException; public void delete(int idAlbum) throws SQLException; //public void delete(Album album) throws SQLException; public Album read(int idAlbum) throws SQLException; public void update(Album album) throws SQLException; public List\u0026lt;Album\u0026gt; getAlbums() throws SQLException; }  Classe que implementa AlbumDAO per a a base de dades SQLLite:\npublic class AlbumDaoImplementacio implements AlbumDao{ private static Connection con = Connexio.getConnection(); @Override public int create(Album album) throws SQLException { String query = \u0026quot;insert into Album(Title, ArtistId) VALUES (?, ?)\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setString(1, album.getNom()); ps.setInt(2, album.getIdArtista()); int n = ps.executeUpdate(); return n; } @Override public void delete(int id) throws SQLException { String query = \u0026quot;delete from Album where AlbumId =?\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setInt(1, id); ps.executeUpdate(); } @Override public Album read(int id) throws SQLException { String query = \u0026quot;select * from Album where AlbumId= ?\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setInt(1, id); Album album = new Album(); ResultSet rs = ps.executeQuery(); boolean check = false; while (rs.next()) { check = true; album.setIdAlbum(rs.getInt(\u0026quot;AlbumId\u0026quot;)); album.setNom(rs.getString(\u0026quot;Title\u0026quot;)); album.setIdArtista(rs.getInt(\u0026quot;ArtistId\u0026quot;)); } if (check == true) { return album; } else return null; } @Override public void update(Album album) throws SQLException { String query= \u0026quot;update Album set Title=?, ArtistId= ? where AlbumId = ?\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ps.setString(1, album.getNom()); ps.setInt(2, album.getIdArtista()); ps.setInt(3, album.getIdAlbum()); ps.executeUpdate(); } @Override public List\u0026lt;Album\u0026gt; getAlbums() throws SQLException { String query = \u0026quot;select * from Album\u0026quot;; PreparedStatement ps = con.prepareStatement(query); ResultSet rs = ps.executeQuery(); List\u0026lt;Album\u0026gt; ls = new ArrayList(); while (rs.next()) { Album album = new Album(); album.setIdAlbum(rs.getInt(\u0026quot;AlbumId\u0026quot;)); album.setNom(rs.getString(\u0026quot;Title\u0026quot;)); album.setIdArtista(rs.getInt(\u0026quot;ArtistId\u0026quot;)); ls.add(album); } return ls; } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/4construccio/",
	"title": "Construcció destrucció d&#39;objectes",
	"tags": [],
	"description": "",
	"content": "Constructors Totes les classes han de tenir un constructor que es fa servir per a instanciar objectes d\u0026rsquo;aquesta classe. En el constructor s\u0026rsquo;acostuma a donar valor als atributs de classe. El constructor ha de tenir el mateix nom que la classe i no s\u0026rsquo;ha de posar tipus de retorn (ni void ni res!)\n Si en una classe no s\u0026rsquo;especifica cap constructor, el compilador proporciona un constructor per defecte sense paràmetres. Per exemple:\npublic class ClasseProva { /* És el mateix posar aquest constructor que no posar-lo. * ClasseProva (){ * * } */ } public class ClasseProvaTest { public static void main(String[] args){ ClasseProva cp = new ClasseProva(); } }  Encara que no l\u0026rsquo;haguem definit en ClasseProva, per tal de crear objectes de tipus ClasseProva, SI NO EXISTEIX CAP MÉS CONSTRUCTOR, Java ens proporciona el constructor per defecte (aquell constructor que no conté cap paràmetre ni cap operació dins el constructor). Ara bé, quan ClasseProva tingui definit almenys un constructor, desapareix ClasseProva per defecte, a no sé que també estigui explícitament definit en la classe ClasseProva.\nEls constructors són mètodes especials que sobretot NO retornen cap valor. Serveixen per indicar a Java que estem creant un objecte d\u0026rsquo;aquella classe. Sí que es pot proporcionar paràmetres d\u0026rsquo;entrada que ens ajudin a instanciar els atributs de classe d\u0026rsquo;aquell objecte. Si ens fixem en l\u0026rsquo;exemple anterior de Persona, podríem redefinir-lo de la següent manera:\npublic class Persona { private String nom; private int edat; Persona (String nom, int edat){ this.nom = nom; this.edat = edat; } public String getNom(){ return nom; } public int getEdat(){ return edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; } public void saluda() { System.out.println(\u0026quot;Hola, sóc \u0026quot; + nom + \u0026quot; i tinc \u0026quot; + edat + \u0026quot; anys\u0026quot;); } }  import java.util.Scanner; public class PersonaTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); String nomPersona1 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona1: \u0026quot;); int edat1 = sc.nextInt();sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); String nomPersona2 = sc.nextLine(); System.out.println(\u0026quot;Demana el nom de la persona2: \u0026quot;); int edat2 = sc.nextInt(); sc.close(); Persona persona1 = new Persona(nomPersona1, edat1); Persona persona2 = new Persona(nomPersona2, edat2); System.out.println(\u0026quot;El nom de la persona1 es: \u0026quot;+persona1.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona1.getEdat()); System.out.println(\u0026quot;El nom de la persona2 es: \u0026quot;+persona2.getNom()+\u0026quot; i l'edat es: \u0026quot;+persona2.getEdat()); persona1.saluda(); persona2.saluda(); } }  Observacions:\n La constructora de Persona té dos paràmetres d\u0026rsquo;entrada que corresponen amb les dues propietats de la classe. Per diferenciar dues variables que es diuen igual (atribut de classe i paràmetre d\u0026rsquo;entrada) utilitzem el this. El this ens ajuda a diferenciar qualsevol atribut/mètode de dins la pròpia classe. Com s\u0026rsquo;observa en la constructora de Persona hi ha l\u0026rsquo;atribut de la pròpia instància this.nom que prèn per valor el paràmetre passat com argument nom. En la classe test observem que ara no fem ús dels setters dels atributs, ja que a l\u0026rsquo;instanciar l\u0026rsquo;objecte amb la constructora ja inicialitzem els atributs.  Més d\u0026rsquo;un constructor\nEs podria donar el cas que fos necessari la implementació de més d\u0026rsquo;un constructor en una classe, això és possible sempre que els tipus dels paràmetres d\u0026rsquo;entrada no coincideixin, el compilador de Java diferencia els constructors dins la mateixa classe amb el llistat dels paràmetres d\u0026rsquo;entrada. Per exemple continuant amb l\u0026rsquo;exemple anterior redefinim la classe Persona amb 3 constructors:\n//Constructor per crear una persona amb nom public Persona(String nomPersona) { nom = nomPersona; edat = 0; //li poso un valor per defecte } //Constructor per crear una persona sense res public Persona() { } //Constructor per crear un persona amb nom i edat public Persona(String nomPersona, int edatPersona) { nom = nomPersona; edat = edatPersona; }  En el programa principal podríem crear ara objectes Persona de tres maneres diferents:\npublic static void main(String[] args) { Persona persona1 = new Persona(\u0026quot;Jordi\u0026quot;); persona1.setEdat(45); persona1.saluda(); Persona alumne2 = new Persona(\u0026quot;Maria\u0026quot;, 18); persona2.saluda(); Persona persona3 = new Persona(); persona3.saluda(); }  Això és un dels poders que otorga la programació orientada a objectes i en concret el polimorfisme que permet tenir tres constructores que es diuen igual, i que per tant, l\u0026rsquo;objectiu final de cadascuna d\u0026rsquo;elles és la instanciació de Persona, però en canvi el \u0026ldquo;com ho fan\u0026rdquo;, el comportament intern, és diferent ja que tenen diferent nombre d\u0026rsquo;arguments.\nThis Quan som dins d\u0026rsquo;un constructor o un mètode, this és una referència a l\u0026rsquo;objecte actual. Amb this pots fer referència a qualsevol atribut o mètode de l\u0026rsquo;objecte actual. Sobretot és necessari quan podria prestar confusió quan dos atributs o dos mètodes s\u0026rsquo;anomenen igual.\n public String getNom(){ return this.nom; } public String setEdat(){ return this.edat; } public void setNom(String nom){ this.nom = nom; } public void setEdat(int edatNova){ edat = edatNova; }  Observacions:\n En el mètode setNom és necessari l\u0026rsquo;ús del this ja que ens diferencia l\u0026rsquo;atribut de classe del paràmetre de la funció. En el mètode setEdat, no l\u0026rsquo;hem posat ja que no presta a confusió les dues variables, tot hi així es podria haver posat a this.edat per remarcar que estem parlant de l\u0026rsquo;atribut de classe. En els getters l\u0026rsquo;hem deixat com a bona praxis, però si no hi hagués el this tampoc hi hauria confusió i java ho interpretaria correctament.  En l\u0026rsquo;exemple següent utilitzem el this com a crida a un constructor dins la mateixa classe:\npublic Persona(String nom) { this(nom, 18); //crido al 3r constructor } public Persona() { this(\u0026quot;Anonymous\u0026quot;); //crido al 1r constructor } public Persona(String nom, int edat) { this.setNom(nom); this.setEdat(edat); }  Destrucció d\u0026rsquo;objectes Un objecte es manté viu sempre que existeixi una variable que l\u0026rsquo;estigui referenciant. Destruïrem un objecte, per tant, deixarem de tenir-hi accés, quan no existeixi cap variable que apunti a l\u0026rsquo;objecte. Una vegada un objecte deixa de ser-nos útil i per tant ocupa memòria innecessàriament és el moment de desrefenciar aquest objecte de totes les variables que l\u0026rsquo;apuntin assignant el valor null a aquestes variables. Quan posem valor null a una variable desreferenciem l\u0026rsquo;objecte on apuntava aquesta variable.\nLes variables es guarden a un espai de memòria que s\u0026rsquo;anomena Stack, mentre que els objectes es guarden a un altre espai que s\u0026rsquo;anomena Heap. La variable guarda la direcció de memòria d\u0026rsquo;on es troba aquest objecte dins el heap, quan assignem valor null a una variable fem que aquesta variable deixi de guardar la direcció de memòria de l\u0026rsquo;objecte dins el heap. Quan això passa, en Java existeix el Garbage Collector, és un aplicatiu que rastreja contínuament la memòria de Java i quan troba objectes que no tenen cap referència en cap variable alliberen aquesta memòria i fan que torni a estar disponible per a l\u0026rsquo;ús de l\u0026rsquo;aplicatiu.\nExemple1: alliberem memòria un cop l\u0026rsquo;objecte ja no ens és útil:\nPersona persona = new Persona(); ... persona = null;  Exemple2: en el següent exemple per tal d\u0026rsquo;eliminar l\u0026rsquo;objecte de persona1, és necessari desreferenciar totes aquelles variables que apuntin a l\u0026rsquo;objecte:\nPersona persona1 = new Persona(\u0026quot;Pedro\u0026quot;, 25); Persona persona2 = new Persona(); Persona persona3 = new Persona(\u0026quot;Ramon\u0026quot;); Persona persona4 = new Persona(\u0026quot;Alberto\u0026quot;, 30); Persona persona5 = new Persona(\u0026quot;Pep\u0026quot;, 25); ... persona2 = persona1; persona3 = persona1; persona4 = persona5; ... persona1 = null; persona2 = null; persona3 = null;  Quin és l\u0026rsquo;objecte que es manté actiu en el cas anterior? Persona4! Fixeu-vos que en fer persona2 = persona1; o persona3 = persona1; o persona4 = persona5; tant l\u0026rsquo;objecte de persona2, com l\u0026rsquo;objecte de persona3, com l\u0026rsquo;objecte persona4 han quedat desreferenciats i per tant el Garbage Collector ja els pot eliminar quan en tingui l\u0026rsquo;ocasió.\nPer altra banda, més endavant decidim que persona1 ja no ens és útil, però l\u0026rsquo;objecte que inicialment hem creat en persona1 també guarda una referència en persona2 i en persona3 (persona2 = persona1; i persona3 = persona1;), de forma que si vull destruir aquest objecte i alliberar-ne la memòria que serà necessari que assigni valor null a les variables persona1 persona2 i persona3. D\u0026rsquo;aquesta manera elimino totes les referències de variables a aquest objecte i per tant el Garbage Collector ja el pot eliminar de la memòria Heap.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/2accions/4esborrat/",
	"title": "Esborrat",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/4interficiesgrafiques/",
	"title": "Introducció Interfícies gràfiques",
	"tags": [],
	"description": "",
	"content": " Components gràfics Gestors d’esquema (Layout managers)  FlowLayout BorderLayout GridLayout Nidació de panells   Gestió d’events d’usuari  Classes anònimes    Bibliografia\n The Java™ Tutorials - Creating a GUI With Swing: https://docs.oracle.com/javase/tutorial/uiswing/TOC.html The Java™ Tutorials - Using Swing Components: Examples https://docs.oracle.com/javase/tutorial/uiswing/examples/components/index.html  Java ofereix un conjunt de llibreries de classes molt completa per a la implementació d’interfìcies gràfiques d’usuari, que ens permetrà abandonar la consola de text i dotar a la nostra aplicació d’un frontend amb els elements típics d’interacció gràfica mijantçant finestres, botons, icones, camps de text, etc.\nL’API de Swing proporciona totes les eines per a construir GUI per a una gran diversitat d’aplicacions Java. És un API molt gran, a la vegada que poderosa i flexible. Dels seus 18 packages, per a la construcció d’una GUI, normalment farem servir dos:\n javax.swing javax.swing.event  La llibreria Java Swing conté els components gràfics que hem d’utilitzar, i aprendre a vincular, tant per a la generació d’interfícies gràfiques d’usuari, com per la implementació de la seva lògica associada per tractar les interaccions de l’usuari des del ratolí i el teclat.\nComponents gràfics Cada component típic d’una interfície gràfica es troba representat per una classe de la llibreria Swing, i per tant, per cada component que vulguem afegir a la nostra interfície gràfica, haurem instanciar un objecte de la classe corresponent.\nEls components Swing tenen la capacitat d’adaptar-se en aspecte i ús, a la plataforma en que siguin executades les aplicacions:\n   Linux Windows MAC           El component JFrame és una finestra amb títol i cantonades ajustables. Exemple de creació d’una finestra:\nimport javax.swing.*; public class Exemple1 { public static void main(String[] args){ JFrame finestra = new JFrame(\u0026quot;Títol de la finestra\u0026quot;); finestra.setSize(300, 200); finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  Swing compte amb una gran varietat de components, com JLabel, JButton, JComboBox, JList, JTextField, que hereten de JComponent.\nimport javax.swing.*; import java.awt.*; public class Exemple2 { public static void main(String[] args){ JFrame finestra = new JFrame(\u0026quot;Títol de la finestra\u0026quot;); //Crear diferents components de Swing JLabel etiqueta = new JLabel(\u0026quot;Etiqueta que mostra un text\u0026quot;); JButton boto = new JButton(\u0026quot;Botó\u0026quot;); JComboBox llistaDesplegable = new JComboBox(); llistaDesplegable.addItem(\u0026quot;Opcio 1\u0026quot;); llistaDesplegable.addItem(\u0026quot;Opcio 2\u0026quot;); llistaDesplegable.addItem(\u0026quot;Opcio 3\u0026quot;); JList llistatSeleccionable = new JList(); String[] listData = {\u0026quot;Opcio 1\u0026quot;, \u0026quot;Opcio 2\u0026quot;}; llistatSeleccionable.setListData(listData); JRadioButton opcioMarcable1 = new JRadioButton(\u0026quot;Opcio 1\u0026quot;); JTextField campDeText = new JTextField(); //Ficar els components a la finestra finestra.getContentPane().setLayout(new GridLayout(6, 1)); finestra.getContentPane().add(etiqueta); finestra.getContentPane().add(boto); finestra.getContentPane().add(llistaDesplegable); finestra.getContentPane().add(llistatSeleccionable); finestra.getContentPane().add(opcioMarcable1); finestra.getContentPane().add(campDeText); //Afegir un marge al contingut de la finestra ((JPanel)finestra.getContentPane()).setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8)); finestra.setSize(500, 260); finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  Gestors d’esquema (Layout managers) Els diferents components que conformen una finestra s’han d’incloure en components de tipus contenidors, en concret, de tipus JPanel. Els contenidors tenen associat un gestor d’esquema (Layout manager) que és el que determina la manera de distribuir els components dins el contenidor. Els Layout managers determinen la posició i la mida dels components del contenidor al que està associat.\nA més, per a poder visualitzar un panell de la classe JPanel, s’ha d’associar a una finestra de la classe JFrame.\n//Ficar els components a la finestra JPanel panell = new JPanel(); panell.setLayout(new GridLayout(6, 1)); panell.add(etiqueta); panell.add(boto); panell.add(llistaDesplegable); panell.add(llistatSeleccionable); panell.add(opcioMarcable1); panell.add(campDeText); finestra.setContentPane(panell);  O agafar el JPanel que ja té associat el JFrame.\n//Ficar els components a la finestra finestra.getContentPane().setLayout(new GridLayout(6, 1)); finestra.getContentPane().add(etiqueta); finestra.getContentPane().add(boto); finestra.getContentPane().add(llistaDesplegable); finestra.getContentPane().add(llistatSeleccionable); finestra.getContentPane().add(opcioMarcable1); finestra.getContentPane().add(campDeText);  Així, a un objecte de la classe JFrame, l’hem d’associar un objecte de la classe JPanel o usar el JPanel que ja té associat. A aquest objecte JPanel l’hem d’associar un objecte LayoutManager. Llavors, afegir els objectes tipus JComponent al JPanel.\nHi ha diversos tipus de Layout, mostrem alguns amb la seva distribució i exemples d’ús.\nFlowLayout Els gestor d’esquema FlowLayout distribueix els components un rere l’altre, d’esquerra a dreta i línia a línia. No modifica la mida dels components. Es pot especificar l\u0026rsquo;aliniament i espaiat entre components. Si el contenidor associat al FlowLayout és redimensiona, els components es redistribueixen.\nCanviant la mida de la finestra: import javax.swing.*; import java.awt.*; public class Exemple3 { public static void main(String[] args){ JFrame finestra = new JFrame(); JLabel etiqueta = new JLabel(\u0026quot;Etiqueta que mostra un text\u0026quot;); JButton boto1 = new JButton(\u0026quot;Acceptar\u0026quot;); JButton boto2 = new JButton(\u0026quot;Cancel·lar\u0026quot;); //Ficar els components a la finestra FlowLayout layout = new FlowLayout(FlowLayout.LEFT, 10, 10); finestra.getContentPane().setLayout(layout); finestra.getContentPane().add(etiqueta); finestra.getContentPane().add(boto1); finestra.getContentPane().add(boto2); String tipusDeLayout = finestra.getContentPane().getLayout().getClass().getSimpleName(); finestra.setTitle(\u0026quot;Distribució amb \u0026quot; + tipusDeLayout); //DibuixarLayouts.dibuixaComponents((JPanel) finestra.getContentPane()); finestra.setSize(500, 260); finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  BorderLayout Els gestor d’esquema BorderLayout defineix 5 àrees diferents en el panell contenidor, que són North, South, East, West i Center. Modifica la mida dels components, fent que ocupin tota l’àrea en la que han sigut afegits. Si el contenidor associat al BorderLayout es redimensiona, els components canvien de mida. Les àrees buides (sense components) no es mostren, a excepció de l’àrea Center.\nCanviant la mida de la finestra: Amb àrees sense components afegits: import javax.swing.*; import java.awt.*; public class Exemple4 { public static void main(String[] args){ JFrame finestra = new JFrame(); JButton boto1 = new JButton(\u0026quot;Botó 1 - NORTH\u0026quot;); JButton boto2 = new JButton(\u0026quot;Botó 2 - SOUTH\u0026quot;); JButton boto3 = new JButton(\u0026quot;Botó 3 - EAST\u0026quot;); JButton boto4 = new JButton(\u0026quot;Botó 4 - WEST\u0026quot;); JButton boto5 = new JButton(\u0026quot;Botó 5 - CENTER\u0026quot;); //Ficar els components a la finestra BorderLayout layout = new BorderLayout(); finestra.getContentPane().setLayout(layout); //finestra.getContentPane().add(boto1, BorderLayout.NORTH); finestra.getContentPane().add(boto2, BorderLayout.SOUTH); finestra.getContentPane().add(boto3, BorderLayout.EAST); //finestra.getContentPane().add(boto4, BorderLayout.WEST); finestra.getContentPane().add(boto5, BorderLayout.CENTER); String tipusDeLayout = finestra.getContentPane().getLayout().getClass().getSimpleName(); finestra.setTitle(\u0026quot;Distribució amb \u0026quot; + tipusDeLayout); //DibuixarLayouts.dibuixaComponents((JPanel) finestra.getContentPane()); finestra.setSize(500, 260); finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  GridLayout Els gestor d’esquema GridLayout defineix un número de files i columnes i posa un component a cada cel·la. Totes les cel·les comparteixen la mateixa amplada i alçada. L’ordre dels components queda determinat per l’ordre en què s’afegeixen. Les cel·les s’omplen d’esquerra a dreta i de dalt a baix. Modifica la mida dels components, fent que ocupin tota l’àrea en la que han sigut afegits. Si el contenidor associat al GridLayout es redimensiona, els components canvien de mida.\nCanviant la mida de la finestra: import javax.swing.*; import java.awt.*; public class Exemple5 { public static void main(String[] args){ JFrame finestra = new JFrame(); JButton boto1 = new JButton(\u0026quot;Botó 1\u0026quot;); JButton boto2 = new JButton(\u0026quot;Botó 2\u0026quot;); JButton boto3 = new JButton(\u0026quot;Botó 3\u0026quot;); JButton boto4 = new JButton(\u0026quot;Botó 4\u0026quot;); JButton boto5 = new JButton(\u0026quot;Botó 5\u0026quot;); JButton boto6 = new JButton(\u0026quot;Botó 6\u0026quot;); //Ficar els components a la finestra GridLayout layout = new GridLayout(2, 3); finestra.getContentPane().setLayout(layout); finestra.getContentPane().add(boto1); finestra.getContentPane().add(boto2); finestra.getContentPane().add(boto3); finestra.getContentPane().add(boto4); finestra.getContentPane().add(boto5); finestra.getContentPane().add(boto6); String tipusDeLayout = finestra.getContentPane().getLayout().getClass().getSimpleName(); finestra.setTitle(\u0026quot;Distribució amb \u0026quot; + tipusDeLayout); finestra.setSize(500, 260); finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  Nidació de panells Per a la creació de GUI amb esquemes més complexes, el que hem de fer és nidar panells que tinguin associats diferents gestors d’esquemes. Un JPanel pot contenir una altre JPanel com un component més, que a la vegada, conté altres components.\nimport javax.swing.*; import java.awt.*; import java.awt.event.*; public class FinestraSaluda extends JFrame { private JPanel contentPane; private final String CANCEL; private final String OK; private JButton buttonOK; private JButton buttonCancel; private JTextField textFieldResposta; private String pregunta; private final String TITOL; private JLabel labelPregunta; private JLabel labelResposta; private JPanel panelButton; public FinestraSaluda() { this.TITOL = \u0026quot;Saludant\u0026quot;; this.setTitle(TITOL); this.pregunta = \u0026quot;Com et dius?\u0026quot;; this.labelPregunta = new JLabel(pregunta); this.labelResposta = new JLabel(); this.contentPane = new JPanel(); this.CANCEL = \u0026quot;Cancel·la\u0026quot;; this.OK = \u0026quot;Fes\u0026quot;; this.buttonOK = new JButton(OK); this.buttonCancel = new JButton(CANCEL); this.textFieldResposta = new JTextField(); contentPane.setLayout(new GridLayout(4,1)); contentPane.add(labelPregunta); contentPane.add(textFieldResposta); contentPane.add(labelResposta); panelButton = new JPanel(); panelButton.setLayout(new GridLayout(1, 2)); panelButton.add(buttonOK); panelButton.add(buttonCancel); contentPane.add(panelButton); setContentPane(contentPane); contentPane.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8)); this.pack(); Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize(); int x = (int) ((dimension.getWidth() - this.getWidth()) / 2); int y = (int) ((dimension.getHeight() - this.getHeight()) / 2); this.setLocation(x, y); } public static void main(String[] args) { FinestraSaluda frame = new FinestraSaluda(); frame.setVisible(true); } }  Gestió d\u0026rsquo;events d\u0026rsquo;usuari Un event és la representació d’una acció de l’usuari, des del teclat o ratolí, per exemple, sobre la interfície gràfica. Els events són objectes que porten informació sobre les accions realitzades. Hi ha una gran varietat de classes d’events, per a representar les diferents categories d’accions d’usuari.\nUn event source és el component on es genera l’event. Un event handler és l’objecte que rep la informació de l’event generat i el procesa. Els event handlers són listeners dels events generats en els components que els hagin registrat com a listeners.\nAixí, quan un usuari polsa un botó d’una GUI, si aquest botó té registrat un listener com a manegador d’aquest tipus d’event (pulsar sobre el botó), llavors es genera un objecte de tipus ActionEvent amb el botó com a event source i amb informació relativa a l’event que s\u0026rsquo;acaba de generar. Per exemple, els objectes de la clase ActionEvent tenen el mètode getActionCommand que retorna el nom de l’acció associada al botó.\nLlavors, l’event de la classe ActionEvent arriba al listener que té registrat el botó. Aquest listener és un objecte que ha d’implementar la interface ActionListener. L’event arriba al listener com a paràmetre en l’execució del mètode actionPerformed, que Java el crida després de la creació de l’event.\nimport javax.swing.*; import java.awt.*; public class Exemple6 { public static void main(String args[]){ JFrame finestra = new JFrame(\u0026quot;Polsa un botó\u0026quot;); finestra.getContentPane().setLayout(new FlowLayout(FlowLayout.CENTER)); JButton boto1 = new JButton(\u0026quot;Sóc el botó 1\u0026quot;); boto1.setActionCommand(\u0026quot;boto1\u0026quot;); JButton boto2 = new JButton(\u0026quot;Sóc el botó 2\u0026quot;); boto2.setActionCommand(\u0026quot;boto2\u0026quot;); finestra.getContentPane().add(boto1); finestra.getContentPane().add(boto2); ButtonHandler buttonHandler = new ButtonHandler(); boto1.addActionListener(buttonHandler); boto2.addActionListener(buttonHandler); finestra.pack(); //Calcula la mida adient segons els components finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class ButtonHandler implements ActionListener { public void actionPerformed(ActionEvent e) { System.out.println(\u0026quot;Has polsat el botó \u0026quot; + e.getActionCommand()); } }  Un component pot tenir tants manegadors (handlers) com sigui necessari, per exemple, per manegar diferents tipus d’event sobre el mateix component.\nActionListener actionHandler; … boto.addActionListener(actionHandler); MouseListener mouseHandler; … boto.addMouseListener(mouseHandler);  Un mateix manegador, por gestionar diferents tipus d’events, implementant les interfaces necessàries per a cada tipus de Listener a implementar.\nboto.addActionListener(buttonHandler); boto.addMouseListener(buttonHandler);  Un mateix manegador, pot gestionar events sobre diversos components:\nboto1.addActionListener(buttonHandler); boto2.addActionListener(buttonHandler);  Un mateix event pot ser gestionat per diferents manegadors. En aquestes cas, l’ordre de crida dels mètodes dels manegadors, és indefinit.\nboto.addActionListener(buttonHandler1); boto.addActionListener(buttonHandler2);  En escriure codi per un event handler, hem d’implementar tots el mètodes de la interfície corresponent. Algunes interfícies tenen més d’un mètode i potser només ens interesa posar codi en un d’ells, però implements ens obliga a implementar-los tots.\nPer comoditat, per algunes interfícies Listener existeixen classes Adapter que implementen tots els seus mètodes però sense codi, així, podem fer un extends de la clase Adapter corresponent i sobreescriure només un dels seus mètodes, enlloc d’implementar la interfície Listener.\nTaula amb els tipus d’events, listener i adapter corresponent, i mètodes a implementar.\n   Event Listener Interface Adapter Class Listener Methods     ActionEvent ActionListener  actionPerformed(ActionEvent)   KeyEvent KeyListener KeyAdapter keyPressed(KeyEvent)\nkeyReleased(KeyEvent keyTyped(KeyEvent)   ListSelectionEvent ListSelectionListener  valueChanged(ListSelectionEvent)   MouseEvent MouseListener MouseAdapter mouseClicked(MouseEvent)\nmouseEntered(MouseEvent)\nmouseExited(MouseEvent)\nmousePressed(MouseEvent)\nmouseReleased(MouseEvent)   MouseEvent MouseMotionListener MouseMotionAdapter mouseDragged(MouseEvent)\nmouseMoved(MouseEvent)    WindowListener WindowAdapter windowActivated(WindowEvent)\nwindowClosed(WindowEvent)\nwindowClosing(WindowEvent)\nwindowDeactivated(WindowEvent)\nwindowDeiconified(WindowEvent)\nwindowIconified(WindowEvent)\nwindowOpened(WindowEvent)    Taula completa a https://docs.oracle.com/javase/tutorial/uiswing/events/api.html\nTaula de components Swing i els tipus d’events que poden manegar a https://docs.oracle.com/javase/tutorial/uiswing/events/eventsandcomponents.html\nExemple més complex:\nPrograma que indica si el ratolí és sobre un botó o si surt d’ell, canviant també de color del missatge.Posa en negreta el missatge clicant a sobre d’ell i el deixar sense negreta tornant a clicar. Mostra en el missatge, allò escrit en el camp de text només entrar en el camp i mentre escrivim en ell.\nComponents de la GUI: Layouts manager de la GUI: import javax.swing.*; import java.awt.*; import java.awt.event.*; public class Exemple7 extends MouseAdapter implements ActionListener, KeyListener { private JFrame finestra; private JLabel labelMostraText; private boolean negreta; private JTextField textField; public Exemple7(){ finestra = new JFrame(\u0026quot;Polsa un botó\u0026quot;); finestra.getContentPane().setLayout(new GridLayout(3, 1, 8, 8)); labelMostraText = new JLabel(); labelMostraText.setHorizontalAlignment(JLabel.CENTER); finestra.getContentPane().add(labelMostraText); JPanel buttonPanel = new JPanel(); buttonPanel.setLayout(new FlowLayout(FlowLayout.CENTER)); JButton boto1 = new JButton(\u0026quot;Sóc el botó 1\u0026quot;); boto1.setActionCommand(\u0026quot;boto1\u0026quot;); JButton boto2 = new JButton(\u0026quot;Sóc el botó 2\u0026quot;); boto2.setActionCommand(\u0026quot;boto2\u0026quot;); buttonPanel.add(boto1); buttonPanel.add(boto2); finestra.getContentPane().add(buttonPanel); textField = new JTextField(); finestra.getContentPane().add(textField); //Registrar els manegadors dels events de polsar els botons boto1.addActionListener(this); boto2.addActionListener(this); boto1.addMouseListener(this); boto2.addMouseListener(this); labelMostraText.addMouseListener(this); textField.addKeyListener(this); textField.addMouseListener(this); //Afegir un marge al contingut de la finestra ((JPanel)finestra.getContentPane()).setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8)); finestra.pack(); //Calcula la mida adient segons els components //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public void setVisible(boolean visible){ finestra.setVisible(visible); } public void actionPerformed(ActionEvent e) { String missatge = \u0026quot;Has polsat el botó \u0026quot; + e.getActionCommand(); this.labelMostraText.setForeground(Color.BLUE); this.labelMostraText.setText(missatge); } public void mouseEntered(MouseEvent e) { if (e.getSource() instanceof JButton) { JButton botoPolsat = (JButton) e.getSource(); String missatge = \u0026quot;Estàs sobre el botó \u0026quot; + botoPolsat.getActionCommand(); this.labelMostraText.setForeground(Color.RED); this.labelMostraText.setText(missatge); } } public void mouseExited(MouseEvent e){ if (e.getSource() instanceof JButton) { JButton botoPolsat = (JButton) e.getSource(); String missatge = \u0026quot;Has sortit del botó \u0026quot; + botoPolsat.getActionCommand(); this.labelMostraText.setForeground(Color.BLACK); this.labelMostraText.setText(missatge); } } public void mouseClicked(MouseEvent e){ if (e.getSource() instanceof JLabel) { if(this.negreta){ this.labelMostraText.setFont(this.labelMostraText.getFont().deriveFont(Font.PLAIN)); }else { this.labelMostraText.setFont(this.labelMostraText.getFont().deriveFont(Font.BOLD)); } this.negreta = !this.negreta; }else if (e.getSource() instanceof JTextField){ onEscriu(); } } public void keyTyped(KeyEvent e) { onEscriu(); } public void keyPressed(KeyEvent e) { onEscriu(); } public void keyReleased(KeyEvent e) { onEscriu(); } private void onEscriu(){ this.labelMostraText.setText(this.textField.getText()); } public static void main(String args[]){ Exemple7 exemple = new Exemple7(); exemple.setVisible(true); } }  Classes anònimes Una manera molt pràctica per a implementar la gestió d’events a Swing és l’ús de classes anònimes. Una classe anònima és una expressió que defineix una classe i a la vegada crea una instància (objecte).\n ExistingClassOrInterface e = new ExistingClassOrInterface() { //Definir atributs i mètodes public void method() { //Codi del mètode } … };  Exemple: Programa que mostra un botó i en clicar sobre ell mostra un missatge, que s’esborra si tornem a clicar sobre el botó. import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class Exemple8 { public static void main(String args[]){ JFrame finestra = new JFrame(\u0026quot;Botó y text\u0026quot;); finestra.getContentPane().setLayout(new BorderLayout(8, 8)); JLabel text = new JLabel(); text.setHorizontalAlignment(JLabel.CENTER); finestra.getContentPane().add(text, BorderLayout.CENTER); String titolBoto = \u0026quot;Fes click\u0026quot;; JButton boto = new JButton(titolBoto); finestra.getContentPane().add(boto, BorderLayout.SOUTH); boto.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if(\u0026quot;\u0026quot;.equals(text.getText())){ text.setText(\u0026quot;Has clickat sobre el botó\u0026quot;); boto.setText(\u0026quot;Esborra text\u0026quot;); }else{ text.setText(\u0026quot;\u0026quot;); boto.setText(titolBoto); } } }); finestra.setSize(350, 150); finestra.setVisible(true); //Per finalitzar l'aplicació en tancar la finestra finestra.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/4tipusdadescolleccions/",
	"title": "Tipus de dades Col·lecció",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/4tipusdades/",
	"title": "Tipus de dades i variables",
	"tags": [],
	"description": "",
	"content": "En el següent capítol parlarem de quin tipus de dades tenim en Java, què són les variables, els identificadors, els literals i les constants.\nTipus de dades En el llenguatge Java incorpora tipus de dades diferents d\u0026rsquo;acord amb la seva naturalesa: no és el mateix un nombre, que un text o un valor verdader/fals per exemple. Aquests tipus de dades els classifiquem en tipus de dades primitius i tipus de dades de classe:\n Primitius: són les dades simples que coneixem com a nombres, text, etc. i que ens defineix de forma primitiva el llenguatge. Classe: són tipus de dades més complexos que es creen a partir dels mateixos tipus de classe o de tipus primitius.  Tipus Primitius En Java podem diferenciar els següents tipus de dades primitius:\n Numèrics:  Enters: byte, short, int i long Reals: float, double   Textuals:  chars   Lògics:  boolean    La diferència entre els nombres enters i reals és que els nombres enters no contenen decimals (ex: 2 | 3 | 25) i els nombres reals reserven espai pels decimals (ex: 4,45 | 6,82 | 3,141592). Tot seguit es mostra una taula de rangs:\n   Nom Longitud Rangs de valors     byte 8 bits De -27 a 27 -1   short 16 bits De -215 a 215 -1   int 32 bits De -231 a 231 -1   long 64 bits De -263 a 263 -1   float 32 bits    double 64 bits    char 16 bits     Els valors que admet una variable de tipus booleà és: true o false. Un valor booleà és molt comú en el camp informàtic on moltes vegades cal prendre una decisió que es pot avaluar en \u0026ldquo;veritat\u0026rdquo; o \u0026ldquo;fals\u0026rdquo;.\nVariables Les variables són posicions de memòria que ocupen uns determinats bits (depèn de cada variable, taula anterior) i que ens ajuden a guardar la informació que té incidència en el nostre programa. Normalment existeix una declaració de variable que consisteix en declarar un tipus nomVariable. En ella indiquem a un nom de variable de QUIN TIPUS és, i tot seguit li podem assignar un valor d\u0026rsquo;aquell tipus concret.\nExemple d\u0026rsquo;assignació de valors Declarem i assignem un valor a les variables:\nboolean valorBoolea = true; int valorEnter = 50; float valorDecimal = 50.3f; char lletra ='v';  En aquest cas primer declarem les variables i després li assignem un valor:\nboolean valorBoolea; valorBoolea = true; int valorEnter; valorEnter = 50; float valorDecimal; valorDecimal = 50.3; char lletra; lletra ='v';  La declaració de variable li serveix a Java per reservar un espai en memòria diferent per cada tipus declarat, per exemple no és el mateix declarar un float variable que un double variable, malgrat que els dos casos tinguem un nombre real la primera declaració ocupa 32 bits, mentre que la segona ocupa en memòria 64 bits.\nUna vegada la variable ha estat declarada li assignem el valor en l\u0026rsquo;espai de memòria reservat. Per cada tipus diferent li assignarem un valor o un altre.\nIdentificadors Els identificadors són els noms que donem a les variables. D\u0026rsquo;acord amb el Naming Conventions els identificadors segueixen el sistema upperCamelCase, on la primera paraula és tot en minúscules i si hi ha més paraules, la primera lletra passa a ser majúscula. Això afavoreix la llegibilitat de les variables.\nint variable; int variableExtensa; int variablesMoltMesLlarga;  Paraules reservades Existeixen un conjunt de paraules reservades del propi llenguatge Java i que no estan permeses utilitzar com a noms de variable. A part de (null, true, false que tampoc):\n abstract, default, if, private, this, boolean, do, implements, protected, throw break, double,\timport, public, throws, byte, else, instanceof, return, transient, case, extends, int, short, try, catch, final, interface, static, void, char, finally, long, volatile, class, float, native, super, while, for, new, switch, continue, package, synchronized  Literals Un literal és un valor constant format per una seqüència de caràcters. Són exemples de literals els nombres, els caràcters i les cadenes de caràcters. Ex:\n700 //literal int 700.12 //literal double 700L //literal long 700.12F //literal float true //literal boolean 'c' //literal char \u0026quot;Casa\u0026quot; //literal String int variableInt = 700; //per defecte, quan és un valor enter és de tipus INT double variableDouble = 700.12; //per defecte, quan és un valor amb decimal és de tipus DOUBLE long variableLong = 700L; //també podem posar 700l float variableFloat = 700.12F; //també podem posar 700.12f boolean variableBoolea = true; char variableCaracter = 'c'; String variableString = \u0026quot;Casa\u0026quot;;  Constants Una constant és una variable que només es pot inicialitzar (modificar el valor al principi), i després ja no es pot tornar a modificar en l\u0026rsquo;execució del meu programa. S\u0026rsquo;indica amb la paraula reservada final. Per convenció s\u0026rsquo;utilitzen les majúscules per anomenar la variable. Ex:\nfinal int MAJORIA_EDAT = 18;  Si provo de modificar aquesta variable ja inicialitzada:\nfinal int MAJORIA_EDAT = 18; MAJORIA_EDAT = 16;  Quan compili el meu programa, es detectarà que és una variable constant (final) i que s\u0026rsquo;intenta modificar el valor, per tant m\u0026rsquo;apareixerà el següent error:\nVar keyword (JDK10) Des de la versió JDK10 es permet la paraula var com a declaració de variable, d\u0026rsquo;aquesta manera permet que un cop s\u0026rsquo;assigna valor a aquesta variable existeix inferència de tipus de forma que la variable passa a ser del tipus de valor que se li assigna. Això permet una gestió més senzill dels tipus genèrics dins de Java.\nLa utilització de var està sotmesa a que sigui una variable local, no es permet la utilització en variables globals, ni en tipus genèrics entre altres casuístiques.\nEls casos anteriors serien substituïbles per:\nvar valorBoolea = true; var valorEnter = 50; var valorDecimal = 50.3f; var lletra ='v';  Per comprovar que realment s\u0026rsquo;ha realitzat bé la inferència de tipus podem executar les següents línies on ens retorna el tipus de cada variable:\nSystem.out.println(((Object)valorBoolea).getClass().getSimpleName()); System.out.println(((Object)valorEnter).getClass().getSimpleName()); System.out.println(((Object)valorDecimal).getClass().getSimpleName()); System.out.println(((Object)lletra).getClass().getSimpleName());  La resposta seria:\nBoolean Integer Float Character  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/4cadenescaracters/",
	"title": "Tractament cadena de caràcters",
	"tags": [],
	"description": "",
	"content": " Un String és una classe que permet treballar amb cadenes de caràcters. La classe String de Java ens dóna moltes funcionalitats que ens permeten realitzar moltes tasques d\u0026rsquo;una forma senzilla.\n La funció sobre la classe String la trobareu a: Java Oracle Classe String\nImmutable És important destacar que la classe String és immutable. Això vol dir que un cop en definim un valor no es pot tornar a modificar. Sembla estrany, ja que si en el codi assignem un nou valor a la mateixa variable observem com es guarda correctament. Bé, el que passa exactament és que String no és una classe primitiva de Java, això vol dir que quan declaro una variable String el que faig realment és crear una referència de memòria (es guarda en la pila del meu programa que s\u0026rsquo;executa), quan a aquesta variable li assigno un valor, aquest és en sí un Objecte String (es guarda en el Heap de la memòria), de forma que si torno a guardar un valor en la mateixa referència de memòria no li estic modificant el valor a l\u0026rsquo;objecte original, sinó que assigno la variable String a un altre objecte (Immutabilitat).\nInicialització La manera de declarar i inicialitzar aquest objecte és com en els tipus primitius. Amb la variable String diem que la variable str i strBuit emmagatzemen un String i a continuació s\u0026rsquo;hi assigna un valor. En el cas del valor \u0026quot;\u0026quot; assignem un String buit. Per mostrar-ne el contingut, igual que en les classes primitives, fem ús de System.out.println.\nString str = \u0026quot;El primer string\u0026quot;; String strBuit = \u0026quot;\u0026quot;; System.out.println(str);  De la mateixa manera que qualsevol altre objecte es podria crear un String de la següent manera utilitzant new.\nString str = new String (\u0026quot;El primer string\u0026quot;);  Funcionalitats interessants Longitud d\u0026rsquo;un String\nSystem.out.println(\u0026quot;longitud \u0026quot; + str.length());  Concatenació de Strings\nString primeraPart = \u0026quot;Hola\u0026quot;; String segonaPart = \u0026quot; \u0026quot;; String terceraPart = \u0026quot;Mon!\u0026quot;; String total = primeraPart + segonaPart + terceraPart; System.out.println(total);  Conèixer el contingut d\u0026rsquo;una determinada posició dins l\u0026rsquo;String. (charAt)\nstr = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;En la posició 4 hi ha: \u0026quot; + str.charAt(4)); System.out.println(\u0026quot;En la posició 11 hi ha: \u0026quot; + str.charAt(11));  Creació d\u0026rsquo;una subcadena (substring) a partir d\u0026rsquo;una cadena original. La primera opció crea una subcadena nova des de la posició indicada fins al final del String str. La segona opció crea una subcadena des de la posició inicial fins a la posició final.\nstr.substring(posicioInicial) str.substring(posicioInicial, posicioFinal) str = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;Substring \u0026quot; + str.substring(12)); //Java System.out.println(\u0026quot;Substring \u0026quot; + str.substring(3, 11)); //lenguaje  Saber si l' inici o final d\u0026rsquo;un String comença o acaba amb una determinada subcadena.\nstr = \u0026quot;El primer programa\u0026quot;; System.out.println(\u0026quot;comienza por El \u0026quot; + str.startsWith(\u0026quot;El\u0026quot;)); System.out.println(\u0026quot;termina por programa \u0026quot; + str.endsWith(\u0026quot;programa\u0026quot;));  Conèixer la posició d\u0026rsquo;un determinat caràcter o seqüència de caràcters dins una cadena. (indexOf). Si la funció porta dos arguments, el segon paràmetre indica a partir de quina posició comença la cerca.\nstr = \u0026quot;El primer programa\u0026quot;; //Comença a buscar 'x' dins str des de la posició 0 str.indexOf('x') //Comença a buscar 'x' dins str des de la posició pos str.indexOf('x', pos) int pos = str.indexOf('p'); System.out.println(\u0026quot;posició de la lletra p \u0026quot; + pos); //segona ocurrencia de p pos = str.indexOf('p', pos + 1); //també permet buscar cadenes de caràcters int pos = str.indexOf(\u0026quot;El\u0026quot;); System.out.println(\u0026quot;posició de la subcadena \\\u0026quot;EL\\\u0026quot; \u0026quot; + pos); int pos = str.indexOf(\u0026quot;pr\u0026quot;, 7); System.out.println(\u0026quot;posició de la subcadena \\\u0026quot;pr\\\u0026quot; a partir de la posició 7: \u0026quot; + pos);  Comparació de dos Strings (compareTo). Compara lexicogràficament dos cadenes de caràcters, i extreu com a resultat -1 0 1 depenent de quin String estigui per davant, si el primer, el segon o tenen el mateix valor lexicogràfic, per tant 0.\nstr = \u0026quot;Pep\u0026quot;; System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Xavi\u0026quot;)); System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Gines\u0026quot;)); System.out.println(\u0026quot;Orden alfabético \u0026quot; + str.compareTo(\u0026quot;Pep\u0026quot;));  Elimina espais (trim) a l\u0026rsquo;inici o final de la cadena de caràcters.\nstr = \u0026quot; 12 \u0026quot;; System.out.println(\u0026quot;string original :\u0026quot; + str); System.out.println(\u0026quot;string sin espacios en blanco :\u0026quot; + str.trim());  Convertir un Array a String (toString).\nint[] arrayNumeric = {24, 2, 4, -12}; System.out.println(\u0026quot;número --\u0026gt; string \u0026quot; + Arrays.toString(arrayNumeric));  Convertir Strings a enters i decimals\nINTEGER.PARSEINT(str.TRIM()); DOUBLE.VALUEOF(str).DOUBLEVALUE(); str = \u0026quot;12\u0026quot;; int numeroInt = Integer.parseInt(str.trim()); System.out.println(\u0026quot;string --\u0026gt; número \u0026quot; + numeroInt); str = \u0026quot;12.35 \u0026quot;; double numeroDouble = Double.valueOf(str).doubleValue(); System.out.println(\u0026quot;string --\u0026gt; número \u0026quot; + numeroDouble);  Separar String en diferents cadenes (split)\n//Separar les diferents paraules per espais str.SPLIT(\u0026quot; \u0026quot;); String cadena = \u0026quot;Hola que tal com estas\u0026quot;; String[] vectorSeparat = cadena.split(\u0026quot; \u0026quot;); for (String a : vectorSeparat) System.out.println(a);  EXEMPLE D\u0026rsquo;ÚS: De cada alumne volem obtenir el nom amb el format correcte i el dni.\nString alumnes = \u0026quot;\u0026quot; + \u0026quot;Nom; Cognoms; DNI\\n\u0026quot; + \u0026quot;xavi; sanChO; 111111a\\n\u0026quot; + \u0026quot;pep; beÀ; 222222b\\n\u0026quot;; String[] rows = alumnes.split(\u0026quot;\\n\u0026quot;); for (int i = 1; i \u0026lt; rows.length; i++) { String[] dades = rows[i].split(\u0026quot;;\u0026quot;); String nom = dades[0]; String cognoms = dades[1]; String nomComplet = nom + \u0026quot; \u0026quot; + cognoms; String[] partsNom = nomComplet.split(\u0026quot; \u0026quot;); String capitalitzat = \u0026quot;\u0026quot;; for (String part : partsNom) { String senseEspais = part.trim(); if (!senseEspais.equals(\u0026quot;\u0026quot;)) { String inicial = part.substring(0, 1).toUpperCase(); String resta = part.substring(1).toLowerCase(); capitalitzat += inicial + resta + \u0026quot; \u0026quot;; } } System.out.println(capitalitzat); String dni = dades[2].trim(); System.out.println(dni); }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/5coleccions/",
	"title": "Col·leccions",
	"tags": [],
	"description": "",
	"content": "Collections Les Collections representen grups d\u0026rsquo;objectes, anomenats elements. Podem trobar diversos tipus de col·leccions, segons si els seus elements estan ordenats, o si permetem repetició d\u0026rsquo;elements o no.\n La informació de Java Oracle corresponen a la Collection la trobareu aquí.\nCom observareu de l\u0026rsquo;enllaç anterior una Collection és una interfície de la qual heradaran totes les estructures de dades que veurem a continuació. En aquesta interfície hi trobareu un conjunt de mètodes que totes les estructures tenen implementades: add(), size(), isEmpty(), etc. Aquests operadors són polimòrfics això vol dir que amb la mateixa denominació efectuen la mateixa funcionalitat però per estructures de dades diferents. Ex: el mateix mètode add() ens serveix per afegir un element a un HashSet a un ArrayList o a un LinkedList.\nSempre que tinguem un tipus de dades que contingui una col·lecció implementarà totes les funcions comunes a ella i les podrem utilitzar. En aquesta interfície trobem una sèrie de mètodes que ens serviran per accedir als elements de qualsevol col·lecció de dades, sigui del tipus que sigui.\nAquests mètodes generals són:\n   Mètode Funcionalitat     boolean add(Object o) Afegir un element en la col·lecció   void clear() Elimina tots els elements de la col·lecció   boolean contains(Object o) Comprova si existeix l\u0026rsquo;element en la col·lecció   boolean isEmpty() Comprova si la col·lecció està buida   boolean remove(Object o) Elimina un element de la col·lecció   int size() Retorna la quantitat d\u0026rsquo;elements que té la col·lecció   Object[] toArray() Retorna els conjunt d\u0026rsquo;elements dins un array       Classe Elements repetits Elements ordenats Comentaris     ArrayList Sí, els permet Elements ordenats per ordre d\u0026rsquo;inserció És non-synchronized, si es vol synchronized: Vector   HashSet No, no els permet No existeix un ordre Internament utilitza una taula de hash per guardar els elements   HashMap Les claus són úniques, els valors poden estar duplicats No existeix un ordre Guarda valors basat en claus (diccionari)    Nota: Tot hi que HashMap no hereta de Collections (ho fa de Maps), el tractarem com un element més d\u0026rsquo;anàlisi ja que les seves propietats són molt idònies per determinats tipus de problema.\nQuan utilitzar aquestes estructures en Java?\n Si no voleu tenir valors duplicats a la base de dades, HashSet hauria de ser la vostra primera opció, ja que totes les seves classes no permeten duplicats. Si es necessiten operacions de cerca freqüents basades en els valors de l\u0026rsquo;índex, Llista (ArrayList) és una opció millor. Si cal mantenir l’ordre d’inserció, també la llista és la interfície de col·lecció preferida. Si el requisit és tenir les assignacions de claus i valors a la base de dades, llavors HashMap és la vostra millor aposta.  Collection i Maps són interfícies molt genèriques i analitzarem de forma pràctica les següents classes heredades d\u0026rsquo;aquestes amb exemples:\n ArrayList: Array dinàmic per guardar objectes i elements. HashSet: Conjunt d\u0026rsquo;elements únics i que no tenen un ordre establert. HashMap: Conjunt d\u0026rsquo;elements clau-valor (K-V).  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5esdades/",
	"title": "AEA5. E/S de dades",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/5programacioestructurada/",
	"title": "Què és la progr. estructurada?",
	"tags": [],
	"description": "",
	"content": " La programació estructurada és un paradigma de programació en el qual les instruccions de codi s\u0026rsquo;executen de forma ordenada utilitzant només tres estructures: seqüencial, condicional i repetitiva.\n S\u0026rsquo;anomena estructura a la manera en què diferents parts es combinen per construir un tot. Un programa tindrà l\u0026rsquo;estructura corresponent a la forma en què les diferents accions individuals o avaluacions parcials es combinen per construir el programa en el seu conjunt.\nEls fonaments de l\u0026rsquo;anomenada programació estructurada es van establir a principis dels anys seixanta i es van consolidar amb els treballs de Dijkstra, Bohm.. El resum dels seus postulats és el següent: \u0026ldquo;es diu que un programa és estructurat si s\u0026rsquo;expressa únicament mitjançant combinacions de les estructures bàsiques\u0026rdquo;:\n seqüencial condicional iterativa  Estructura bàsica: Totes les estructures de control tenen un únic punt d\u0026rsquo;entrada i un únic punt de sortida.\nTot seguit repassarem les tres estructures de control: seqüencials, condicionals i iteratives en Java.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/5utilitzacio/",
	"title": "Ús de mètodes i  propietats",
	"tags": [],
	"description": "",
	"content": "Un cop vist què són les classes i com es creen ara anem a veure com interrelacionar-les de forma sencilla per crear petits aplicatius amb orientació a objectes. Alhora de crear un programa és molt important conèixer les diferents fases de desenvolupament de software, en la fase de disseny cal definir les classes que intervindran en el programa amb les seves corresponents responsabilitats, per tal de poder ser codificades en la fase d\u0026rsquo;implementació.\nUn objecte pot ser una propietat d\u0026rsquo;un altre objecte, les classes no només estan formades dels paràmetres primitius, a mesura que els programes es tornen més complexes és necessari definir amb exactitud la composició i interrelació que ha d\u0026rsquo;existir entre els diferents objectes.\nPer exemple, la matrícula d\u0026rsquo;un cotxe podria ser una propietat de la classe Cotxe i definir-la com a tipus String. En posteriors refinaments del meu programa la matrícula passaria a ser una classe Matricula i estaria compost d\u0026rsquo;unes propietats: (caràcters i nombres) i d\u0026rsquo;uns mètodes (per exemple mètodes de verificació, etc.), i la classe Matricula passaria a ser una propietat de la classe Cotxe.\nTot seguit mostrarem petits exemples que ajudin a la comprensió de la composició entre classes i com anem construint el nostre software. Cal tenir clar abans diferents premises:\n Tenir definida una estructura de classes amb uns objectius clars. Quines responsabilitats atorguem a cada classe i a cada mètode (Cal definir la granularitat adient). Quins acoblaments són necessaris (un acoblament entre dues classes es crea quan necessitem d\u0026rsquo;una per crear l\u0026rsquo;altra). Tenir clar els principis de Clean Code alhora d\u0026rsquo;escriure i relacionar classes. Tenir en compte els Naming Conventions que ajudin a la comprensió i legibilitat de les classes.  Variables referenciades Totes les variables que no són primitives en Java passen a estar referenciades, igual com ja hem vist que passa amb els Strings. En el cas que declarem les nostres pròpies classes i les instanciem passa el mateix. Retornant a l\u0026rsquo;exemple de Persona de l\u0026rsquo;activitat anterior, quan declarem una Persona p, estem declarant una referència a un objecte de tipus Persona, però fins que no la construïm amb el new Persona() aquesta referència p apunta a un valor null. La màquina virtual de Java té un procés anomenat Garbage Collector que periòdicament analitza quines són les variables desreferenciades (que apunten a null) i les elimina de la memòria. Així doncs un cop passa el Garbage Collector pel següent codi troba una variable p a null i l\u0026rsquo;elimina:\n//Creem la referència a un objecte de tipus Persona, de moment no està creat encara Persona p; //Creem i reservem en memòria espai suficient per guardar els atributs d'aquest objecte p = new Persona(); //Efectuem modificacions a l'objecte p.setEdat(5); p.setNom(\u0026quot;Joaquim\u0026quot;); //Fem que p es desreferenciï de l'objecte instanciat. Quan passi garbage collector eliminarà tots els punters desreferenciats com aquest. p = null;  En l\u0026rsquo;apartat 0 d\u0026rsquo;aquesta RA hem observat el pas per valor i el pas per referència. Com ja hem vist quan passem com a paràmetre a una funció una variable de tipus primitiu s\u0026rsquo;efectua una còpia d\u0026rsquo;aquesta variable i no s\u0026rsquo;actua en l\u0026rsquo;original, mentre que quan el paràmetre no es primitiu es passa com a referència, i per tant SÍ que estem enviant la posició de memòria on es troba la variable, ho hem vist amb els arrays i ara veurem que passa el mateix quan passem una referència d\u0026rsquo;un objecte d\u0026rsquo;una classe que hem creat nosaltres (NO és de tipus primitiu). Anem a observar l\u0026rsquo;exemple següent:\npublic static void main(String[] args) { Persona p = new Persona(\u0026quot;Leo\u0026quot;, 5); System.out.println(\u0026quot;Abans d'entrar al canvi sense modificació:\u0026quot; + p); canviSenseModificarObjecte(p); System.out.println(\u0026quot;Després de sortir de la funció del canvi sense modificacio:\u0026quot; +p); canviModificantObjecte(p); System.out.println(\u0026quot;Després de sortir de la funció del canvi amb modificacio:\u0026quot; +p); } private static void canviSenseModificarObjecte(Persona p) { System.out.println(\u0026quot;'p' dins de canviSenseModificarObjecte abans de canviar l'objecte de Persona p: \u0026quot; + p); p = new Persona(); p.setNom(\u0026quot;Victor\u0026quot;); p.setEdat(33); System.out.println(\u0026quot;'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: \u0026quot; + p); } private static void canviModificantObjecte(Persona p) { System.out.println(\u0026quot;'p' dins de canviModificantObjecte abans de modificar-lo: \u0026quot; + p); p.setNom(\u0026quot;Pere\u0026quot;); p.setEdat(47); System.out.println(\u0026quot;'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: \u0026quot; + p); }  Resultat\nAbans d'entrar al canvi sense modificació:Persona{nom='Leo', edat=5} 'p' dins de canviSenseModificarObjecte abans de canviar l'objecte de Persona p: Persona{nom='Leo', edat=5} 'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: Persona{nom='Victor', edat=33} Després de sortir de la funció del canvi sense modificacio:Persona{nom='Leo', edat=5} 'p' dins de canviModificantObjecte abans de modificar-lo: Persona{nom='Leo', edat=5} 'p' dins de canviSenseModificarObjecte després de canvia l'objecte de Persona p: Persona{nom='Pere', edat=47} Després de sortir de la funció del canvi amb modificacio:Persona{nom='Pere', edat=47}  Observacions:\n Veiem que imprimim directament p i se n\u0026rsquo;observen els valors dels atributs. Per defecte totes les classes tenen una funció public String toString() que quan es crida la referència de l\u0026rsquo;objecte n\u0026rsquo;imprimeix els seus valors. En el següent apartat veurem com modificar-ho. Com s\u0026rsquo;observa en l\u0026rsquo;exemple el primer mètode realitza una nova instanciació de Persona DINS del mètode, quan es surt del mètode com que els canvis d\u0026rsquo;objecte es produeixen a l\u0026rsquo;interior del mètode, al sortir la referència p apunta on originàriament apuntava (es passa per referència) de forma que perdem els canvis que s\u0026rsquo;hagin pogut produir dins. En canvi, en el segon mètode com que s\u0026rsquo;efectuen els canvis justament a l\u0026rsquo;objecte de la direcció p original, al sortir del mètode observem com els canvis s\u0026rsquo;han mantingut en l\u0026rsquo;objecte p Persona.  Exemple 1: Comptador d\u0026rsquo;un dígit Observem una possible implementació d\u0026rsquo;un comptador d\u0026rsquo;un sol dígit de 0-9.\npublic class Comptador { private int numComptador; /** * Definim la constructora */ public Comptador(){ numComptador = 0; } /** * Definim el getter de numCumptador * @return el valor del comptador */ public int getNumComptador(){ return numComptador; } /** * Definim el setter de numComptador * @param a */ public void setNumComptador(int a){ numComptador=a; } /** * Incrementa el comptador */ public void incrementaComptador(){ if (numComptador==9)numComptador=0; else numComptador++;\t} /** * Decrementa el comptador */ public void decrementaComptador() { if (numComptador==0)numComptador=9; else numComptador--; } public static void main(String[] args) { Scanner in = new Scanner (System.in); Comptador c = new Comptador(); System.out.println(\u0026quot;\\n EXERCICI COMPTADOR\u0026quot;); System.out.println(\u0026quot;\\n ---------------------\u0026quot;); System.out.println(\u0026quot;Valor Inicial: \u0026quot;+c.getNumComptador()); System.out.println(\u0026quot;Incrementem 15 vegades el comptador\u0026quot;); for (int h=0; h\u0026lt;15; h++){ c.incrementaComptador(); System.out.println(c.getNumComptador()); } System.out.println(\u0026quot;Decrementem 15 vegades el valor del comptador\u0026quot;); for (int h=0; h\u0026lt;15; h++){ c.decrementaComptador(); System.out.println(c.getNumComptador()); } } }  Exemple 2: Comptador de dos dígits (usant l\u0026rsquo;anterior) Ara volem un comptador de dos dígits però usant dos comptadors d\u0026rsquo;un sol dígit (exemple anterior)\npublic class Comptador2 { Comptador desenes; Comptador unitats; /** * Constructora de Comptador de dos dígits usant la classe Comptador */ public Comptador2(){ desenes = new Comptador(); unitats = new Comptador(); desenes.setNumComptador(0); unitats.setNumComptador(0); } /** * Mètode getter del comptador */ public String getNumComptador(){ return desenes.getNumComptador()+\u0026quot;\u0026quot;+unitats.getNumComptador(); } /** * Mètode setter del comptador * @param desenes * @param unitats */ public void setNumComptador(int desenes, int unitats){ this.desenes.setNumComptador(desenes); this.unitats.setNumComptador(unitats); } /** * Incrementa el comptador */ public void incrementaComptador(){ if(desenes.getNumComptador()==9 \u0026amp;\u0026amp; unitats.getNumComptador()==9){ desenes.setNumComptador(0); unitats.setNumComptador(0); }else if(unitats.getNumComptador()==9){ desenes.incrementaComptador(); unitats.setNumComptador(0); }else{ unitats.incrementaComptador(); } } /** * Decrementa el comptador */ public void decrementaComptador(){ if(desenes.getNumComptador()==0 \u0026amp;\u0026amp; unitats.getNumComptador()==0){ desenes.setNumComptador(9); unitats.setNumComptador(9); }else if(unitats.getNumComptador()==0){ desenes.decrementaComptador(); unitats.setNumComptador(9); }else{ unitats.decrementaComptador(); } } public static void main(String[] args) { Comptador2 c2 = new Comptador2(); System.out.println(\u0026quot;\\n\\n EXERCICI COMPTADOR 2\u0026quot;); System.out.println(\u0026quot;\\n -------------------------\u0026quot;); System.out.println(\u0026quot;Ara enlloc de tenir un comptador, tenim unitats i desenes (2 instàncies de la classe comptador)\u0026quot;); System.out.print(\u0026quot;Valor inicial: \u0026quot; + c2.getNumComptador()); System.out.println(\u0026quot;Incrementem valors fins a 101 i veiem què passa\u0026quot;); for (int h=0; h\u0026lt;101; h++){ c2.incrementaComptador(); c2.getNumComptador(); System.out.println(c2.getNumComptador()); } System.out.println(\u0026quot;Decrementem els valors fins a -102 i veiem què passa\u0026quot;); for (int h=0; h\u0026lt;102; h++){ c2.decrementaComptador(); c2.getNumComptador(); System.out.println(c2.getNumComptador()); } } }  Exemple 3: Classe amb alumnes Exemple de com usar una col·lecció d\u0026rsquo;objectes, en aquest cas tenim una classe Alumne i una classe Classe que serà un conjunt d\u0026rsquo;alumnes. Durant l\u0026rsquo;exemple veurem diferents conceptes:\n Alumne Test amb JUnit Alumne Classe Programa principal  Comencem amb la definició de la classe Alumne, a més a més:\n Mètodes Override Mètodes de còpia d\u0026rsquo;un objecte Comparator  import java.util.Comparator; public class Alumne implements Cloneable{ private int edat=18; private String nom; private String cognoms; //CONSTRUCTORES public Alumne(){ this(18,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;); } public Alumne(String nom, String cognoms){ this.nom = nom; this.cognoms = cognoms; } public Alumne(int edat, String nom, String cognoms){ this.edat = edat; this.nom = nom; this.cognoms = cognoms; } //CÒPIA OBJECTE public Alumne (Alumne a){ this.edat = a.getEdat(); this.nom = a.getNom(); this.cognoms = a.getCognoms(); } //GETTERS public int getEdat() { return edat; } public String getNom() { return nom; } public String getCognoms() { return cognoms; } //SETTERS public void setEdat(int edat) { this.edat = edat; } public void setNom(String nouNom) { nom = nouNom; } public void setCognoms(String cognoms) { this.cognoms = cognoms; } //MÈTODES SOBREESCRITS @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Alumne)) return false; Alumne alumne = (Alumne) o; if (getEdat() != alumne.getEdat()) return false; if (!getNom().equals(alumne.getNom())) return false; return getCognoms().equals(alumne.getCognoms()); } @Override public int hashCode() { int result = getEdat(); result = 31 * result + getNom().hashCode(); result = 31 * result + getCognoms().hashCode(); return result; } @Override public String toString() { return \u0026quot;Alumne{\u0026quot; + \u0026quot;edat=\u0026quot; + edat + \u0026quot;, nom='\u0026quot; + nom + '\\'' + \u0026quot;, cognoms='\u0026quot; + cognoms + '\\'' + '}'; } //DEFINIM COMPARATORS PER A ORDENAR /*Comparator per Nom*/ public static Comparator\u0026lt;Alumne\u0026gt; alumnesCompararPerNom = new Comparator\u0026lt;Alumne\u0026gt;() { public int compare(Alumne a1, Alumne a2) { String alumneNom1 = a1.getNom().toUpperCase(); String alumneNom2 = a2.getNom().toUpperCase(); //ordre ascendent return alumneNom1.compareTo(alumneNom2); //ordre descendent //return alumneNom2.compareTo(alumneNom1); }}; /*Comparator per Cognoms*/ public static Comparator\u0026lt;Alumne\u0026gt; alumnesCompararPerCognom = new Comparator\u0026lt;Alumne\u0026gt;() { public int compare(Alumne a1, Alumne a2) { String alumneCognom1 = a1.getCognoms().toUpperCase(); String alumneCognom2 = a2.getCognoms().toUpperCase(); //ordre ascendent return alumneCognom1.compareTo(alumneCognom2); //ordre descendent //return alumneCognom2.compareTo(alumneCognom1); }}; /*Comparator per Nom*/ public static Comparator\u0026lt;Alumne\u0026gt; alumnesCompararPerEdat = new Comparator\u0026lt;Alumne\u0026gt;() { public int compare(Alumne a1, Alumne a2) { int alumneEdat1 = a1.getEdat(); int alumneEdat2 = a2.getEdat(); //ordre ascendent if (alumneEdat1\u0026gt;=alumneEdat2) return 1; else return -1; //ordre descendent //if (alumneEdat1\u0026gt;=alumneEdat2) return -1; //else return 1; }}; //ALTRES MÈTODES public void saluda() { System.out.println(\u0026quot;Hola, sóc un alumne i em dic \u0026quot; + nom); } }  Tot seguit continuem amb una classe Test que ens ajudi a testejar la classe Alumne:\nimport org.junit.Test; import static org.junit.Assert.*; public class AlumneTest { @Test public void getEdat() throws Exception { Alumne a = new Alumne(); assertEquals(18, a.getEdat()); Alumne a2 = new Alumne(26, \u0026quot;\u0026quot;,\u0026quot;\u0026quot;); assertEquals(26, a2.getEdat()); } @Test public void getNom() throws Exception { Alumne a = new Alumne(); assertEquals(\u0026quot;\u0026quot;, a.getNom()); Alumne a2 = new Alumne(\u0026quot;Ramon\u0026quot;,\u0026quot;\u0026quot;); assertEquals(\u0026quot;Ramon\u0026quot;, a2.getNom()); } @Test public void getCognoms() throws Exception { Alumne a = new Alumne(); assertEquals(\u0026quot;\u0026quot;, a.getCognoms()); Alumne a2 = new Alumne(\u0026quot;\u0026quot;,\u0026quot;Torres\u0026quot;); assertEquals(\u0026quot;Torres\u0026quot;, a2.getCognoms()); } @Test public void setEdat() throws Exception { Alumne a = new Alumne(); a.setEdat(20); assertEquals(20, a.getEdat()); } @Test public void setNom() throws Exception { Alumne a = new Alumne(); a.setNom(\u0026quot;Miquel\u0026quot;); assertEquals(\u0026quot;Miquel\u0026quot;, a.getNom()); } @Test public void setCognoms() throws Exception { Alumne a = new Alumne(); a.setCognoms(\u0026quot;Torres\u0026quot;); assertEquals(\u0026quot;Torres\u0026quot;, a.getCognoms()); } @Test public void testClone() throws Exception { Alumne a = new Alumne(); Alumne clon = (Alumne)a.clone(); assertEquals(a,clon); Alumne a2 = new Alumne(30, \u0026quot;Mireia\u0026quot;, \u0026quot;Ramirez\u0026quot;); Alumne copia = new Alumne(a2); assertEquals(a2,copia); } @Test public void equals() throws Exception { Alumne a = new Alumne(20,\u0026quot;Joan\u0026quot;,\u0026quot;Rius\u0026quot;); Alumne b = new Alumne (20,\u0026quot;Joan\u0026quot;,\u0026quot;Rius\u0026quot;); assertEquals(a,b); assertNotNull(a); a = null; assertNull(a); } @Test public void testToString() throws Exception { Alumne a = new Alumne(); assertEquals(\u0026quot;Alumne{edat=18, nom='', cognoms=''}\u0026quot;, a.toString()); Alumne a2 = new Alumne(28,\u0026quot;Maria\u0026quot;,\u0026quot;Romero\u0026quot;); assertEquals(\u0026quot;Alumne{edat=28, nom='Maria', cognoms='Romero'}\u0026quot;, a2.toString()); }  Ara definim la classe Classe (com serà una classe amb alumnes). Deixem l\u0026rsquo;apartat d\u0026rsquo;ArrayList per analitzar durant la següent RA.\nimport java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; public class Classe implements Cloneable{ private String grup; private String aula; private ArrayList\u0026lt;Alumne\u0026gt; alumnes = new ArrayList\u0026lt;\u0026gt;(); //CONSTRUCTORES public Classe(){ } public Classe(String grup, String aula, ArrayList\u0026lt;Alumne\u0026gt; grupAlumne){ this.grup = grup; this.aula = aula; this.alumnes = grupAlumne; } //CÒPIA OBJECTE public Classe (Classe classe){ this.grup = classe.getGrup(); this.aula = classe.getAula(); this.alumnes = classe.getAlumnes(); } //GETTERS public String getGrup() { return grup; } public String getAula() { return aula; } public ArrayList\u0026lt;Alumne\u0026gt; getAlumnes() { return alumnes; } public Alumne getAlumne(int posicio) { return alumnes.get(posicio); } //SETTERS public void setGrup(String grup) { this.grup = grup; } public void setAula(String aula) { this.aula = aula; } public void setAlumnes(ArrayList\u0026lt;Alumne\u0026gt; alumnes) { this.alumnes = alumnes; } //Mètodes típics de llistes public void afegirAlumne(Alumne a){ alumnes.add(a); } public boolean esBuit(){ return alumnes.size()==0; } public boolean existeixAlumne(Alumne a){ return alumnes.contains(a); } public int posicioAlumne(Alumne a){ return alumnes.indexOf(a); } public void eliminarAlumne(Alumne a){ alumnes.remove(a); } //MÈTODES SOBREESCRITS @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Classe classe = (Classe) o; if (!grup.equals(classe.grup)) return false; if (!aula.equals(classe.aula)) return false; return alumnes.equals(classe.alumnes); } @Override public int hashCode() { int result = grup.hashCode(); result = 31 * result + aula.hashCode(); result = 31 * result + alumnes.hashCode(); return result; } @Override public String toString() { return \u0026quot;Classe{\u0026quot; + \u0026quot;grup='\u0026quot; + grup + '\\'' + \u0026quot;, aula='\u0026quot; + aula + '\\'' + \u0026quot;, alumnes=\u0026quot; + alumnes + '}'; } }  Finalment anem a crear el programa principal.\nimport java.util.Scanner; public class AlumneClasseMain { public static void main(String args[]){ //Anem a crear una classe de 5 estudiants Classe classe = new Classe(); Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Introdueix el nom del grup\u0026quot;); String grup = sc.nextLine(); classe.setGrup(grup); System.out.println(); System.out.println(\u0026quot;Introdueix el nom de l'aula\u0026quot;); String aula = sc.nextLine(); classe.setAula(aula); System.out.println(); System.out.println(\u0026quot;Introduim 5 alumnes\u0026quot;); Alumne a = new Alumne(20, \u0026quot;Amos\u0026quot;, \u0026quot;Ledesma\u0026quot;); classe.afegirAlumne(a); a = new Alumne(21, \u0026quot;Roger\u0026quot;,\u0026quot;Polo\u0026quot;); classe.afegirAlumne(a); a = new Alumne(25, \u0026quot;Oriol\u0026quot;,\u0026quot;Benito\u0026quot;); classe.afegirAlumne(a); a = new Alumne(28, \u0026quot;Joaquim\u0026quot;,\u0026quot;Rocamora\u0026quot;); classe.afegirAlumne(a); a = new Alumne(18, \u0026quot;Hector\u0026quot;, \u0026quot;Peris\u0026quot;); classe.afegirAlumne(a); System.out.println(); System.out.println(\u0026quot;Imprimim la classe:\u0026quot; + classe); System.out.println(); System.out.println(\u0026quot;L'aula està buida? \u0026quot; + classe.esBuit()); System.out.println(); System.out.println(\u0026quot;Si l'alumne 'a' existeix imprimeix-lo i diga'n la seva posició \u0026quot;); if(classe.existeixAlumne(a)){ System.out.println(\u0026quot;L'alumne 'a' és :\u0026quot; + a); System.out.println(\u0026quot;L'alumne 'a' es troba a la posició :\u0026quot; + classe.posicioAlumne(a)); System.out.println(\u0026quot;Eliminem aquest alumne :\u0026quot;); classe.eliminarAlumne(a); } System.out.println(); System.out.println(\u0026quot;Modifiquem informació de l'alumne 3 i a partir d'ara es dirà Pere Benitez i té 18 anys.\u0026quot;); classe.getAlumne(3).setNom(\u0026quot;Pere\u0026quot;); classe.getAlumne(3).setCognoms(\u0026quot;Benitez\u0026quot;); classe.getAlumne(3).setEdat(18); System.out.println(); System.out.println(); System.out.println(\u0026quot;Imprimim l'alumne 3\u0026quot; + classe.getAlumne(3)); } }  Exemple 4: Game i position El següent exemple és extret del llistat d\u0026rsquo;activitats entregables que tenim. L\u0026rsquo;enunciat de l\u0026rsquo;activitat és:\n Crea i testeja les classes Position i Player amb els atributs que s\u0026rsquo;escaiguin i els mètodes que es descriuen a continuació:\n  Classe Position: representa un punt (x,y) a l\u0026rsquo;eix de coordenades. Cada posició ve definida per dos valors enters x i y. Els mètodes disponibles són:\n- Constructor per defecte, que es correspondrà amb la posició (0,0).\n- Constructor al qual se li passa com a paràmetre els valors inicials de les coordenades x i y.\n- Els getters i setters corresponents als atributs de la classe.\n- Mètodes per incrementar i decrementar els valors de cadascuna de les coordenades de la posició. Els noms dels mètodes seran incX, incY, decX i decY.\n- Un mètode per establir els valors de les dues coordenades, tindrà per nom setXY.\n  Classe Player: representarà un jugador que tindrà com a atributs la posició en la qual es troba (representada per un objecte de la classe Position) i el nom del jugador. Els mètodes necessaris són:\n- Constructor al qual se li passa com a paràmetre la posició inicial on s\u0026rsquo;ha de situar el jugador. Ha de crear l\u0026rsquo;objecte Position que guardarà la posició.\n- Mètodes per moure el jugador, tindran per noms: moveRight, moveLeft, jump, fall.\n- Mètodes per establir i consultar el nom del jugador (getter i setter).\n- Mètode que ens retorna la posició del jugador (getter).\n  Crea una classe Game amb un mètode main que mostri un menú per pantalla amb les següents opcions (usant la classe Player de l\u0026rsquo;exercici anterior):\na) Moure un jugador: aquesta opció passa com a paràmetre quin jugador i cap a quina posició es vol moure.\nb) Resetejar un jugador: aquesta opció elimina la posició d\u0026rsquo;un jugador i el torna al punt d\u0026rsquo;inici (1,1).\nc) Mostrar jugadors: mostrar per pantalla la informació dels dosc jugadors.\n Classe Position\nimport static java.lang.StringTemplate.STR; public class Position { private int x; private int y;\tpublic Position() { x=0; y=0; } public Position(int x, int y) { this.x=x; this.y=y; } public void getPosicio() { System.out.println(\u0026quot;La posicio es X:\u0026quot;+x+\u0026quot; Y:\u0026quot;+y); } public void setPosicio(int x, int y) { this.x=x; this.y=y; } public void incX() { x++; } public void decX() { x--; } public void incY() { y++; } public void decY() { y--; } @Override public String toString() { return STR. \u0026quot;Position{ x=\\{x}, y=\\{y}}\u0026quot;; } }  Classe Player\nimport static java.lang.StringTemplate.STR; public class Player { private int identificador; Position posicio; public Player(int x, int y){ posicio = new Position(x,y); } public Player(Position coord){ posicio = coord; } /* GETTERS */ public int getIdentificador(){ return identificador; } public void getPosicio(){ posicio.getPosicio(); } /* SETTERS */ public void setIdentificador(int identificador){ this.identificador=identificador; } public void setPosicio(Position posicio){ this.posicio = posicio; } /* Modificadors de posicio */ public void moveRight(){ posicio.incX(); } public void moveLeft(){ posicio.decX(); } public void jump(){ posicio.incY(); } public void fall(){ posicio.decY(); } @Override public String toString() { return STR.\u0026quot;Player{ identificador = \\{identificador}, posicio= \\{posicio}}\u0026quot;; } }  Classe Game\nimport java.util.Scanner; public class Game { private Player jugador1; private Player jugador2; public Game(){ jugador1 = new Player(new Position()); jugador2 = new Player(new Position()); jugador1.setIdentificador(1); jugador2.setIdentificador(2); } public static void main(String[] args) { Game game = new Game(); var sc = new Scanner (System.in); var opcio = -1; var torn = true; while (opcio != 0) { System.out.println(\u0026quot;Dona la seguent opcio:\u0026quot;); System.out.println(\u0026quot;1 - Moure jugador\u0026quot;); System.out.println(\u0026quot;2 - Reset jugador\u0026quot;); System.out.println(\u0026quot;3 - Mostrar Jugadors\u0026quot;); System.out.println(\u0026quot;0 - Sortir\u0026quot;); opcio = sc.nextInt(); Player playerActual = torn ? game.jugador1 : game.jugador2; System.out.println(playerActual); switch(opcio){ case 1 -\u0026gt; game.moureJugador(playerActual); case 2 -\u0026gt; game.resetJugador(playerActual); case 3 -\u0026gt; game.mostrarJugadors(); case 0 -\u0026gt; {break;} default -\u0026gt; System.out.println(\u0026quot;Opcio incorrecta\u0026quot;); } if(opcio == 1) torn = !torn; } } public void moureJugador(Player jugador){ System.out.println(\u0026quot;Quina posicio et vols moure? 1-x++, 2-x--, 3-y++ o 4-y--\u0026quot;); Scanner sc = new Scanner(System.in); var posicio = sc.nextInt(); switch(posicio){ case 1 -\u0026gt; jugador.moveRight(); case 2 -\u0026gt; jugador.moveLeft(); case 3 -\u0026gt; jugador.jump(); case 4 -\u0026gt; jugador.fall(); default -\u0026gt; System.out.println(\u0026quot;No es una opcio correcta\u0026quot;); } } public void resetJugador(Player jugador){ jugador.setPosicio(new Position(0,0)); } public void mostrarJugadors(){ System.out.println(jugador1); System.out.println(jugador2); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3dadescompostes/6operacionsagregades/",
	"title": "Operacions agregades",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/6gestiobbdds/",
	"title": "AEA6. Gestió de BBDDs",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/6herencia/",
	"title": "Concepte d&#39;herència i ús",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;herència permet a una classe nova crear-se a partir d\u0026rsquo;una classe existent. La nova classe (subclasse) \u0026ldquo;hereta\u0026rdquo; els atributs i mètodes de la classe primària, i a més a més, té la possibilitat d\u0026rsquo;incorporar nous atributs i mètodes específics a la subclasse.\n Conceptes:\n Superclasse: Classe primària o existent en l\u0026rsquo;herència. Subclasse: classe nova i resultant d\u0026rsquo;aplicar herència a una altra classe. Especialització: Procés que permet estendre d\u0026rsquo;una classe pare a una classe filla, ampliant atributs i mètodes. Generalització: Procés de navegar de les classes filles a la classe pare. En la classe pare trobarem els atributs i mètodes comuns a totes les subclasses.  Herència simple\nJava permet l\u0026rsquo;herència simple: qualsevol classe només té una classe pare, no permet l\u0026rsquo;herència múltiple com sí permeten altres llenguatges de programació com el C++. Això ens planteja el problema que a vegades pels requisits de la nostra aplicació és necessari simular l\u0026rsquo;herència múltiple fent ús d\u0026rsquo;interfícies. Per a més informació: problema del diamant\nRelació \u0026ldquo;és un\u0026rdquo; vs \u0026ldquo;conté un\u0026rdquo; L\u0026rsquo;herència és una relació d\u0026rsquo;extensió d\u0026rsquo;una classe més específica respecte una classe genèrica, això ens porta a que la classe filla ÉS UNA classe pare, però amb les funcionalitats ampliades/exteses/modificades. A vegades quan es programa existeix el dubte de confondre aquesta relació amb una relació de composició CONTÉ UN, que erròniament entenguem com a subclasse \u0026ldquo;una part\u0026rdquo; de la classe principal. Un exemple seria el següent:\nCom podeu veure en l\u0026rsquo;exemple anterior en l\u0026rsquo;herència es parteix d\u0026rsquo;un BaseVehicle, que a la vegada s\u0026rsquo;especialitza en un Truck, i a la vegada s\u0026rsquo;especialitza en un TacoTruck. TacoTruck \u0026ldquo;ÉS UN\u0026rdquo; BaseVehicle, TacoTruck és una extensió de BaseVehicle. En canvi Truck \u0026ldquo;CONTÉ UN\u0026rdquo; engine, engine és una part de Truck, no podria substituir l\u0026rsquo;engine per un truck i que es comporti de la mateixa manera.\nUna vegada es conceptualitza el problema a resoldre pots crear el teu arbre jeràrquic. Un exemple amb animals seria:\nImplementació Per tal d\u0026rsquo;indicar que una classe és una herència utilitzarem la paraula extends en la definició de la classe. Per exemple si tenim una classe pare Persona i dos classes filles Alumne i Professor, ho faríem de la següent manera:\npublic class Persona{ ... } public class Alumne extends Persona { ... } public class Professor extends Persona{ ... }  Si la superclasse no està al mateix package que la subclasse, s\u0026rsquo;ha d\u0026rsquo;importar la classe ja que sinó no en tindria visibilitat.\njava.lang.Object\nUna subclasse pot ser a la vegada superclasse d\u0026rsquo;altres classes i crear així un àrbre jeràrquic de classes. En Java totes les classes hereten d\u0026rsquo;una classe mare, la classe arrel de totes és java.lang.Object. Hi ha un conjunt de mètodes que tenen TOTES les classes de Java, inclús les que programeu vosaltres, aquí teniu la descripció de Java Oracle referent a la classe Object.\nFixeu-vos que com que per defecte s\u0026rsquo;hereda de la classe Object, és el mateix posar en la definició de la classe extends Object que no posar-ho.\nTotes les classes per defecte extenen de java.lang.Object, per tant poden fer ús dels mètodes que conté aquesta classe, per exemple:\n toString(): retorna una definició dels atributs en forma de String, aquesta definició la podeu \u0026ldquo;sobreescriure, modificar i adaptar a les vostres necessitats\u0026rdquo;. equals(Object o): mètode per comparar l\u0026rsquo;Objecte o amb l\u0026rsquo;implícit(this), per defecte retorna true si es tracta del mateix objecte (mateixa referència) i false si no. Si volem comparar els atributs per comprovar que es tracta dels mateixos valors serà necessari \u0026ldquo;sobreescriure\u0026rdquo; el mètode i fer que adopti el comportament que volem, això passa per exemple amb el cas de la classe String, ens retorna true si els dos Strings tenen el mateix valor i no si fan referència al mateix objecte. clone(): s\u0026rsquo;utilitza per realitzar una còpia de l\u0026rsquo;objecte. Veurem altres maneres de realitzar còpies.  Cas equals - String Utilitzem equals per comparar el valor de dos Strings. Molt sovint al principi es comet l\u0026rsquo;error de comparar dos Strings utilitzant \u0026ldquo;==\u0026rdquo;, cal diferenciar els tipus de dades primitius dels que no ho són, pels tipus de dades primitius Java té sobrecarregat sobre l\u0026rsquo;operador relacional \u0026ldquo;==\u0026rdquo; com cal actuar per comparar dos valors del mateix tipus, però en el cas del String no existeix la implementació de l\u0026rsquo;operador d\u0026rsquo;igualtat per \u0026ldquo;==\u0026rdquo;, per això utilitzem equals. De fet, si utilitzem \u0026ldquo;==\u0026rdquo; dos Strings estem comparant que la direcció de memòria on estan ubicats els dos Strings és la mateixa, que els dos OBJECTES comparteixen la mateixa direcció de memòria, i per tant, són, de fet, el mateix objecte.\nDe fet, podria generar dubtes la definició anterior, ja que si proveu el següent codi, d\u0026rsquo;acord amb el que acabem d\u0026rsquo;explicar, valor1 == valor2 hauria de ser False ja que parlem de referències a objectes diferents. El resultat és True perquè la classe String reserva en un pool de valors aquells Strings recents usats com a interned. Els Strings són objectes immutables, això vol dir que una vegada definits els valors no es poden modificar, quan a una referència de String li canviem el valor el que estem fent realment és crear un nou objecte String i reapuntar la variable al nou valor. Per això quan en el següent exemple s\u0026rsquo;observa True entre els valors1 i valors2 el que realment passa és que es comparen les direccions de memòria de valors1 i valors2 i com que els dos apunten a la mateixa direcció on es troba l\u0026rsquo;String \u0026ldquo;Hola\u0026rdquo; dins el pool, tant valor1 com valor2 apunten a la mateixa direcció del pool de Strings. Si en algun moment \u0026ldquo;modifiquem\u0026rdquo; el valor de valor1 o valor2 el que estem fent realment és crear un nou String reapuntant la direcció de memòria. Exemple:\nString valor1 = \u0026quot;Hola\u0026quot;; String valor2 = \u0026quot;Hola\u0026quot;; String valor3 = valor1; //True ja que es tracta de dos Strings recentment guardats dins el pool de Strings. System.out.println(valor1 == valor2); //True ja que estem comparant, mitjançant equals el valor de dos Strings. System.out.println(valor1.equals(valor2)); //True ja que les dues variables valor1 i valor3, apunten AL MATEIX OBJECTE System.out.println(valor1 == valor3);  En canvi per veure el comportament teòric:\nString valor1 = new String(\u0026quot;Hola\u0026quot;); String valor2 = new String(\u0026quot;Hola\u0026quot;); //False ja que fa referència a dos objectes diferents i els Strings no s'han situat en el pool. System.out.println(valor1 == valor2);  Per aprofundir amb la gestió del pool de Strings de Java podem observar el següent exemple que permet veure\u0026rsquo;n la diferència, ja que l\u0026rsquo;assignació del valor a string3 ve precedit de l\u0026rsquo;accés a una funció i per tant s\u0026rsquo;executa dins el RunTime (no en temps de compilació), no es considera eficient afegir l\u0026rsquo;String string3 al pool de Strings i per això el resultat de la comparació és False, després sí que l\u0026rsquo;afegim explícitament i per això el resultat és True:\npublic class Main { private String string1 = \u0026quot;Hola\u0026quot;; public static void main(String[] args) { new Main().manipulacio(); System.exit(0); } public void manipulacio() { String string2 =\u0026quot;Hola\u0026quot;; System.out.println(\u0026quot;[statics] s2 == s1? \u0026quot; + (string2 == string1)); String string3 = \u0026quot;Hol\u0026quot; + retornaA(); System.out.println(\u0026quot;[before interning] s3 == s1? \u0026quot; + (string3 == string1)); string3 = string3.intern(); System.out.println(\u0026quot;[after interning] s3 == s1? \u0026quot; + (string3 == string1)); } private String retornaA() { return \u0026quot;a\u0026quot;; } }  Exemple Resum d\u0026rsquo;Herència S\u0026rsquo;observa com la classe filla adquireix noves propietats i les funcions constructora, get i set es modifiquen d\u0026rsquo;acord a aquestes noves propietats.\npublic class Habitatge{ private String direccio; private int extensio; private int codiPostal; public Habitatge(String direccio, int extensio, int codiPostal){ this.direccio = direccio; this.extensio = extensio; this.codiPostal = codiPostal; } public String getDireccio (){ return direccio; } public void setDireccio (String direccio){ this.direccio = direccio; } } public class Pis extends Habitatge { private int planta; private int porta; public Pis(String direccio, int extensio, int codiPostal, int planta, int porta){ super (direccio, extensio, codiPostal); this.planta = planta; this.porta = porta; } @Override public String getDireccio (){ return super.getDireccio() + \u0026quot; \u0026quot; + planta +\u0026quot; \u0026quot;+ porta; } @Override public void setDireccio (String direccio, planta, porta){ super.setDireccio(direccio) this.planta = planta; this.porta = porta; } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/6sequencial/",
	"title": "Estructura seqüencial",
	"tags": [],
	"description": "",
	"content": "Estructura seqüencial En l\u0026rsquo;estructura seqüencial permet descomposar un problema en instruccions que s\u0026rsquo;executaran de la primera a la última seguint un ordre de forma incondicional.\n L' assignació consisteix en donar un valor a una variable. \u0026ldquo;Guardar\u0026rdquo; una informació en una variable, que segurament serà tractada i/o consultada més endavant.\n    Codi Diagrama de flux     Acció1;\nAcció2;\nAcció3;\nAcció4;     Estructura bàsica L\u0026rsquo;estructura bàsica de qualsevol programa en Java anirà dins una \u0026ldquo;classe\u0026rdquo; amb un fitxer .java, amb la següent plantilla:\npublic class Main { public static void main(String[] args) { } }  Java executarà tot el que trobi dins les claus del main anterior.\nDades d\u0026rsquo;entrada Per tal d\u0026rsquo;introduir valors al nostre programa (inputs), inicialment, farem servir la classe Scanner (Scanner ens permet introduir molts tipus de dades en les variables que ja coneixem). Primerament cal que \u0026ldquo;importem\u0026rdquo; Scanner just a l\u0026rsquo;inici del nostre fitxer, import java.util.Scanner, tot seguit i ja dins el nostre bloc de main creem un objecte Scanner, per exemple a l\u0026rsquo;identificador de la variable li direm sc. Aquest objecte ens permetrà introduir informació pel teclat dels tipus de dades ja coneguts. L\u0026rsquo;exemple és molt il·lustratiu:\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enter32bits = sc.nextInt(); long enter64bits = sc.nextLong(); float decimal = sc.nextFloat(); double decimalGran = sc.nextDouble(); boolean boolea = sc.nextBoolean(); String cadenaCaracters = sc.next(); //Capta tots els caràcters fins al primer espai. String cadenaCaractersFinalLinia = sc.nextLine(); //Guarda tots els caràcters fins a la finalització de línia (Enter). } }  Quan s\u0026rsquo;executa aquest programa, observarem que quan arriba a la línia on hi ha sc.nextInt(), el programa es queda parat esperant que l\u0026rsquo;usuari introdueixi per teclat un valor i pressioni Enter, això passarà amb la resta de valors que s\u0026rsquo;espera que l\u0026rsquo;usuari introdueixi per teclat. Tots aquests valors seran assignats a les variables que hem definit: enter32bits, enter64bits\u0026hellip;\nDades de sortida Per tal d\u0026rsquo;observar els valors pel terminal (outputs) el que farem serà usar System.out.print i si volem un salt de línia System.out.println\nimport java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Pots escriure el teu nom per línia de comandes?\u0026quot;); String nom = sc.nextLine(); System.out.print(\u0026quot;Hola! \u0026quot;); System.out.print(\u0026quot;El meu nom és \u0026quot; + nom); } }  Comentaris Els comentaris són útils per mostrar informació adicional del codi, quan aquesta sigui necessària, no és bo abusar-ne. Normalment un codi ben escrit hauria de ser autoexplicatiu. Si s\u0026rsquo;assignen noms de variables i funcions coherents pel que s\u0026rsquo;utilitzen no caldria escriure molts comentaris.\nJava interpreta com a text explicatiu tots els comentaris i per tant NO ELS EXECUTA com si fossin instruccions. Existeixen comentaris per:\n Una fila. En aquest cas utilitzarem \u0026ldquo;// Comentari\u0026rdquo; Més d\u0026rsquo;una fila, el comentari anirà entre \u0026ldquo;/* Comentari vàries línies */\u0026rdquo; Per realitzar documentacions de codi usant, per exemple Javadoc \u0026ldquo;/** Documentació */\u0026rdquo;  public class Main { public static void main(String[] args) { //Comentari d'una sola línia /* Comentari de més d'una línia */ } /** * Aquesta funció retorna la suma entera de dos nombres enters passats per paràmetre * * @param operand1 primer operand de l'operació suma * @param operand2 segon operand de l'operació suma * @return retorna un enter que és la suma dels dos * @see suma */ public int suma(int operand1, int operand2) { var resultat = operand1 + operand2; return resultat; }  Exemples de problemes seqüencials  Llegeix dos nombres reals i escriu la seva suma, resta, producte i quocient.  float operand1 = sc.nextFloat(); float operand2 = sc.nextFloat(); float suma = operand1 + operand2; float resta = operand1 - operand2; float multiplicacio = operand1 * operand2; float divisio = operand1 / operand2; float modul = operand1 % operand2; System.out.println(\u0026quot;Suma:\u0026quot; + suma); System.out.println(\u0026quot;Resta:\u0026quot; + resta); System.out.println(\u0026quot;Multiplicacio:\u0026quot; + multiplicacio); System.out.println(\u0026quot;Divisio:\u0026quot; + divisio); System.out.println(\u0026quot;Modul:\u0026quot; + modul);  Llegeix el preu d\u0026rsquo;un producte, l\u0026rsquo;IVA (en %) i el descompte (en %) a aplicar. Escriu el preu final del producte.  float preu = sc.nextFloat(); int iva = sc.nextInt(); int descompte = sc.nextInt(); float preuAmbIva = preu + preu * iva / 100; float preuAmbIvaIDescompte = preuAmbIva - preuAmbIva * descompte / 100; System.out.println(\u0026quot;Preu final:\u0026quot; + preuAmbIvaIDescompte);  Calcula l\u0026rsquo;àrea lateral i el volum d\u0026rsquo;un cilindre recte, introduint per teclat els valors del radi i l\u0026rsquo;altura. V =pi⋅r2⋅h AL=2⋅pi⋅r⋅h  float radi = sc.nextFloat(); float altura = sc.nextFloat(); double areaLateral = 2 * Math.PI * radi * altura; double volum = Math.PI * Math.pow(radi,2) * altura; System.out.println(\u0026quot;Area lateral:\u0026quot; + areaLateral + \u0026quot; Volum:\u0026quot; + volum);  Llegeix un nombre enter no negatiu i un altre nombre enter no negatiu que indica la posició de les seves xifres i escriu la xifra que ocupa aquesta posició. Les unitats estan a la posició 1, les desenes a la posició 2, etc.  int nombre = sc.nextInt(); int posicio = sc.nextInt(); double potencia = Math.pow(10,posicio-1); double nombreRetallat = nombre / potencia; int nombreBuscat = (int)nombreRetallat % 10; System.out.println(\u0026quot;el dígit \u0026quot; +posicio+ \u0026quot; del nombre \u0026quot; + nombre + \u0026quot; és: \u0026quot;+ nombreBuscat);  Llegeix un nombre enter de segons i escriu el nombre d’hores, minuts i segons equivalents en format h:m:s.  int segonsTotals = sc.nextInt(); int hores = segonsTotals / 3600; int segonsRestants = segonsTotals % 3600; int minuts = segonsRestants / 60; int segons = segonsRestants % 60; System.out.println(hores + \u0026quot;:\u0026quot; + minuts + \u0026quot;:\u0026quot; + segons);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/7condicional/",
	"title": "Estructura de selecció",
	"tags": [],
	"description": "",
	"content": "Estructura de selecció L\u0026rsquo;estructura de control condicional o alternativa permet prendre una decisió en un moment determinat sobre quines instruccions s\u0026rsquo;han d\u0026rsquo;executar. Donada una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet decidir entre un o varis camins d\u0026rsquo;execució.\n Existeixen diferents tipus d\u0026rsquo;estructura condicional.\n Estructura simple (if) Estructura composta (if/else) Estructura encadenada (if/else if/else) Sentència switch (switch) Combinació d\u0026rsquo;estructures  1. Estructura simple (if) Aquesta és la forma bàsica. Consisteix en una estructura en la qual si l' avaluació lògica és certa s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions, en cas contrari s\u0026rsquo;ometen aquestes instruccions. Consideracions:\n L\u0026rsquo;expressió lògica ha d\u0026rsquo;anar precedida de la paraula if i entre parèntesi (). Les instruccions que s\u0026rsquo;han d\u0026rsquo;executar es situen a continuació dins de les claus {}. Només s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions contingut entre {} quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a cert.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n}\nAcció3;     //Exemple estructura simple (if) int nota = sc.nextInt(); //Acció1 if( nota == 8){ System.out.println(\u0026quot;Tens un notable, nota: \u0026quot; + nota); //Acció2 } nota = 0; //Acció3 //Quan es tracta d'una sola instrucció dins el bloc de l'if, com és el cas amb l'Acció2, no ens caldria posar \u0026quot;{ }\u0026quot; Podria quedar de la següent manera: int nota = sc.nextInt(); //Acció1 if( nota == 8) System.out.println(\u0026quot;Tens un notable, nota: \u0026quot; + nota); //Acció2 nota = 0; //Acció3  2. Estructura composta (if/else) La diferència respecte el cas anterior és que ara quan l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals també s\u0026rsquo;executarà un bloc d\u0026rsquo;instruccions.\n Aquestes instruccions aniran contingudes dins de parèntesis {} i precedides de la paraula else.     Codi Diagrama de flux     Acció1;\nif ( cond ) {\nAcció2;\n} else {\nAcció3;\n}\nAcció4;     //Exemple estructura composta (if/else) int nota = sc.nextInt(); //Acció1 if( nota \u0026gt;= 5){ System.out.println(\u0026quot;Estàs aprovat\u0026quot;); //Acció2 } else{ System.out.println(\u0026quot;Estàs suspès\u0026quot;); //Acció3 } nota = 0; //Acció4 //D'igual manera es podria reescriure com: int nota = sc.nextInt(); //Acció1 if( nota \u0026gt;= 5) System.out.println(\u0026quot;Estàs aprovat\u0026quot;); //Acció2 else System.out.println(\u0026quot;Estàs suspès\u0026quot;); //Acció3 nota = 0; //Acció4  Estructura ternària Existeix una estructura similar a l\u0026rsquo;estructura composta que seria la següent:\nint resultat = (cond)? a : b;  Equivaldria a:\nint resultat; if (cond){ resultat = a; } else{ resultat = b; }  Un exemple senzill podria ser:\nString missatge; int edat = sc.nextInt(); if (edat \u0026gt;=18){ missatge = \u0026quot;És major d'edat\u0026quot;; }else{ missatge = \u0026quot;Encara no és major d'edat\u0026quot;; } System.out.println(missatge); //Utilitzant l'operador ternari var edat = sc.nextInt(); var missatge = (edat \u0026gt;= 18) ? \u0026quot;És major d'edat\u0026quot; : \u0026quot;Encara no és major d'edat\u0026quot;; System.out.println(missatge);  3. Estructura encadenada o múltiple (if / else if / else) A vegades es dóna la situació que no volem decidir només entre dos camins d\u0026rsquo;execució, sinó que el problema ens requereix escollir entre diferents camins, així serà necessari introduir la figura del else if(). Comportament:\n En aquest cas el programa avalua la primera expressió booleana que es troba, si és certa executa el bloc d\u0026rsquo;instruccions que hi pertany. Però si l\u0026rsquo;avaluació és falsa anirà a la següent expressió booleana que es trobarà en un bloc else if(). I així consecutivament fins a la última. S\u0026rsquo;ha de tenir en compte que la prioritat en l\u0026rsquo;avaluació de les diferents expressions booleanes és important. Si s\u0026rsquo;avalua a cert en alguna expressió booleana JA NO avalua els següents casos, entra dins el bloc d\u0026rsquo;instruccions, s\u0026rsquo;executen les instruccions pertinents, i surt de l\u0026rsquo;estructura de control sense avaluar la resta de casos (podrien avaluar-se també a cert, per això és important la prioritat alhora d\u0026rsquo;establir els casos). Si s\u0026rsquo;introdueix un bloc else i cap expressió booleana s\u0026rsquo;avalua a cert, s\u0026rsquo;executarà el bloc d\u0026rsquo;instruccions corresponents a l\u0026rsquo;else.     Codi Diagrama de flux     Acció0;\nif ( cond1 ) {\nAcció1;\n} else if (cond2) {\nAcció2;\n}else if (cond3) {\nAcció3;\n}else if (cond4) {\nAcció4;\n}else {\nAcció5;\n}\nAcció6;     //Exemple estructura composta (if/else) var nota = sc.nextInt(); //Acció0 if (nota \u0026lt; 5) { System.out.println(\u0026quot;Suspès\u0026quot;); //Acció1 } else if (nota \u0026lt; 6) { System.out.println(\u0026quot;Aprovat\u0026quot;); //Acció2 } else if (nota \u0026lt; 8) { System.out.println(\u0026quot;Bé\u0026quot;); //Acció3 } else if (nota \u0026lt; 9) { System.out.println(\u0026quot;Notable\u0026quot;); //Acció4 } else{ System.out.println(\u0026quot;Excel·lent\u0026quot;); //Acció5 } nota = 0; //Acció6  4. Sentència switch (switch) Aquesta estructura és útil quan en funció del valor d\u0026rsquo;una variable es poden executar blocs de codi diferents. Per exemple podríem pensar en un menú d\u0026rsquo;una app on tenim diferents opcions o un comandament a distància de la tele. Consideracions:\n A l\u0026rsquo;inici d\u0026rsquo;aquesta estructura comença amb un switch seguida de la variable que volem avaluar entre parèntesi: switch (variable). Tot seguit, i entre claus {}, definim tots els casos que es volen tractar d\u0026rsquo;aquesta variable. Per a cada cas existeix un bloc case valor: amb tots els casos possibles. Per cada case el que fa és avaluar si la variable del switch == valor definit en el case, si és així executa les instruccions d\u0026rsquo;aquest case. Si volem executar un bloc d\u0026rsquo;instruccions en cas que no es trobi cap dels valors desitjats per la variable sempre tenim el bloc default: que ens permet fer la mateixa funció que \u0026ldquo;l\u0026rsquo;else\u0026rdquo; en les estructures anteriors. En cada bloc case és necessari acabar-lo amb un break; si el que volem és sortir de l\u0026rsquo;estructura per tal que no executi les instruccions del següent case. És una estructura que podríem simular amb una estructura encadenada o múltiple, la única diferència respecte a l\u0026rsquo;anterior és que en aquest cas, si no posem el break, sí que permetria executar més d\u0026rsquo;un case diferent. Els tipus de dades que poden treballar amb un switch són els següents: byte (Byte), shor (Short), int (Integer), char (Character), enum i String.     Codi Diagrama de flux     Acció0;\nswitch ( expressio ) {\ncase valor1:\nAcció1;\nbreak;\ncase valor2:\nAcció2;\nbreak;\ncase valor3:\nAcció3;\nbreak;\ncase valor4:\nAcció4;\nbreak;\ndefault:\nAcció5;\n} Acció6;     var animal = sc.next(); var result; //Acció 0 switch (animal) { case \u0026quot;DOFI\u0026quot;: result = \u0026quot;animal marí\u0026quot;; //Acció 1 break; case \u0026quot;VACA\u0026quot;: result = \u0026quot;animal terrestre\u0026quot;; //Acció 2 break; case \u0026quot;CORB\u0026quot;: result = \u0026quot;animal aeri\u0026quot;; //Acció 3 break; case \u0026quot;GOS\u0026quot;: result = \u0026quot;animal terrestre\u0026quot;; //Acció 4 break; case \u0026quot;TAURO\u0026quot;: result = \u0026quot;animal marí\u0026quot;; //Acció 5 break; default: result = \u0026quot;animal desconegut\u0026quot;; //Acció 6 break; } System.out.println(animal + \u0026quot; es un \u0026quot; + result); //Acció 7  Podríem entendre aquest codi de la següent manera en l\u0026rsquo;estructura de if / else if / else:\nvar animal = sc.next(); var result; if (animal.equals(\u0026quot;DOFI\u0026quot;)) result = \u0026quot;animal marí\u0026quot;; else if(animal.equals(\u0026quot;VACA\u0026quot;)) result = \u0026quot;animal terrestre\u0026quot;; else if(animal.equals(\u0026quot;CORB\u0026quot;)) result = \u0026quot;animal aeri\u0026quot;; else if(animal.equals(\u0026quot;GOS\u0026quot;)) result = \u0026quot;animal terrestre\u0026quot;; else if(animal.equals(\u0026quot;TAURO\u0026quot;)) result = \u0026quot;animal marí\u0026quot;; else result = \u0026quot;animal desconegut\u0026quot;; System.out.println(animal + \u0026quot; es un \u0026quot; + result);  Observem que existeixen dos casos d\u0026rsquo;animal marí i dos d\u0026rsquo;animal terrestre, així que podríem reduir el codi en:\nvar animal = sc.next(); var result; if (animal.equals(\u0026quot;DOFI\u0026quot;) OR animal.equals(\u0026quot;TAURO\u0026quot;)) result = \u0026quot;animal marí\u0026quot;; else if(animal.equals(\u0026quot;VACA\u0026quot;) OR animal.equals(\u0026quot;GOS\u0026quot;)) result = \u0026quot;animal terrestre\u0026quot;; else if(animal.equals(\u0026quot;CORB\u0026quot;)) result = \u0026quot;animal aeri\u0026quot;; else result = \u0026quot;animal desconegut\u0026quot;; System.out.println(animal + \u0026quot; es un \u0026quot; + result);  De la mateixa manera fent ús del switch quedaria:\nvar animal = sc.next(); var result; //Acció 0 switch (animal) { case \u0026quot;DOFI\u0026quot;: case \u0026quot;TAURO\u0026quot;: result = \u0026quot;animal marí\u0026quot;; //Acció 1 break; case \u0026quot;VACA\u0026quot;: case \u0026quot;GOS\u0026quot;: result = \u0026quot;animal terrestre\u0026quot;; //Acció 2 break; case \u0026quot;CORB\u0026quot;: result = \u0026quot;animal aeri\u0026quot;; //Acció 3 break; default: result = \u0026quot;animal desconegut\u0026quot;; //Acció 6 break; } System.out.println(animal + \u0026quot; es un \u0026quot; + result);  Des de JDK12 s\u0026rsquo;incorpora els -\u0026gt; en la formulació del switch, aquesta nova versió li dóna un aire mes legible i més elegant. L\u0026rsquo;exemple anterior usant els \u0026ldquo;arrow\u0026rdquo; en el switch quedaria:\nvar animal = sc.next(); var resultat = switch (animal) { case \u0026quot;DOFI\u0026quot; -\u0026gt; \u0026quot;animal marí\u0026quot;; case \u0026quot;VACA\u0026quot; -\u0026gt; \u0026quot;animal terrestre\u0026quot;; case \u0026quot;CORB\u0026quot; -\u0026gt; \u0026quot;animal aeri\u0026quot;; case \u0026quot;GOS\u0026quot; -\u0026gt; \u0026quot;animal terrestre\u0026quot;; case \u0026quot;TAURO\u0026quot; -\u0026gt; \u0026quot;animal marí\u0026quot;; default -\u0026gt; \u0026quot;animal desconegut\u0026quot;; }; System.out.println(animal + \u0026quot; es un \u0026quot; + resultat);  Optant per l\u0026rsquo;opció de juntar els CASE quedaria encara més resumit:\nvar animal = sc.next(); var resultat = switch (animal) { case \u0026quot;DOFI\u0026quot;, \u0026quot;TAURO\u0026quot; -\u0026gt; \u0026quot;animal marí\u0026quot;; case \u0026quot;VACA\u0026quot;, \u0026quot;GOS\u0026quot; -\u0026gt; \u0026quot;animal terrestre\u0026quot;; case \u0026quot;CORB\u0026quot; -\u0026gt; \u0026quot;animal aeri\u0026quot;; default -\u0026gt; \u0026quot;animal desconegut\u0026quot;; }; System.out.println(animal + \u0026quot; es un \u0026quot; + resultat);  Enum Finalment incorporem un tipus nou, enum, que s\u0026rsquo;ajusta molt bé en el cas d\u0026rsquo;estructures switch. Enum és una llista de valors constants que pot prendre una variable. Seguint el cas anterior quedaria de la següent manera:\nScanner sc = new Scanner(System.in); String animalString = sc.next(); enum animals{ DOFI, TAURO, VACA, GOS, CORB}; animals animal = animals.valueOf(animalString); var resultat = switch (animal) { case DOFI, TAURO -\u0026gt; \u0026quot;animal marí\u0026quot;; case VACA, GOS -\u0026gt; \u0026quot;animal terrestre\u0026quot;; case CORB -\u0026gt; \u0026quot;animal aeri\u0026quot;; default -\u0026gt; \u0026quot;animal desconegut\u0026quot;; }; System.out.println(animal + \u0026quot; es un \u0026quot; + resultat);  Finalment per acabar l\u0026rsquo;exemple, s\u0026rsquo;observa com mai s\u0026rsquo;accedeix a default, de fet, si introduïm un element que no està dins del llistat animals es produeix una excepció (ho veurem properament). Una excepció és un error inesperat i, en aquest cas, causat per la introducció d\u0026rsquo;un valor no apte per l\u0026rsquo;enum que tenim definit. En aquest cas per tal de controlar aquest error el que farem és tractar els casos d\u0026rsquo;animals que no estan dins l\u0026rsquo;enum de la següent manera:\nScanner sc = new Scanner(System.in); String animalString = sc.next(); enum animals{ DOFI, TAURO, VACA, GOS, CORB}; try { animals animal = animals.valueOf(animalString); var resultat = switch (animal) { case DOFI, TAURO -\u0026gt; \u0026quot;animal marí\u0026quot;; case VACA, GOS -\u0026gt; \u0026quot;animal terrestre\u0026quot;; case CORB -\u0026gt; \u0026quot;animal aeri\u0026quot;; }; System.out.println(animal + \u0026quot; es un \u0026quot; + resultat); }catch (IllegalArgumentException e){ System.out.println(animalString + \u0026quot; es un animal desconegut\u0026quot;); }  Observem com en el tractament de l\u0026rsquo;excepció ja contemplem el cas default que ja no tenim definit en el switch.\n5. Combinació d\u0026rsquo;estructures Moltes vegades els problemes que ens trobem a la vida real requereix de la composició de diferents estructures de control, així doncs es podria donar el cas que tinguéssim diferents estructures de control unes dins d\u0026rsquo;altres de forma jerarquitzada.\nExemple: En l\u0026rsquo;època actual de Coronavirus, donat els cribatges de PCRs per detectar casos positius ens interessaria detectar quins són els assimptomàtics. Així doncs m\u0026rsquo;invento un algorisme que permeti filtrar aquelles persones que ens interessa per realitzar les proves. És necessari que donades unes quantes dades ens digui si cal que faci alguna de les proves o no.\n Volem analitzar les persones entre 18 i 40 anys, d\u0026rsquo;aquestes es farà la prova bàsica de PCR, però les noies embarassades no realitzaran aquesta bàsica sinó que faran una prova més avançada. Pel que fa a les persones majors de 40 anys els hi realitzarem una prova avançada de PCR i un test d\u0026rsquo;esforç físic. Deixem l\u0026rsquo;exercici perquè el resolgueu vosaltres.  Exemples  Crea un programa on, un cop introduïts dos nombres per l\u0026rsquo;usuari, es mostri el resultat de sumar dos nombres sempre que el primer sigui més gran al segon. (exemple estructura simple)  var num1 = sc.nextInt(); var num2 = sc.nextInt(); if(num1 \u0026gt; num2) { System.out.println(num1+num2); }  Crea un programa que permeti dir, donats dos nombres per l\u0026rsquo;usuari, si són múltiples l\u0026rsquo;un a l\u0026rsquo;altre. (exemple estructura composta)  System.out.println(\u0026quot;Entra el 1r nombre\u0026quot;); var num1 = sc.nextInt(); System.out.println(\u0026quot;Entra el 2n nombre\u0026quot;); var num2 = sc.nextInt(); if(num1%num2 == 0 || num2%num1 == 0){ System.out.println(\u0026quot;Són divisors\u0026quot;); } else { System.out.println(\u0026quot;No són divisors\u0026quot;); }  Creeu un programa que permeti introduir dos nombres i realitzar una operació sobre la base de l\u0026rsquo;nombre de codi, 1, 2 o 3 permeti restar, multiplicar o dividir els dos nombres i mostrar el resultat per pantalla.  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); var num1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); var num2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); var opcio = sc.nextInt(); if(opcio==1)System.out.println(num1 - num2); else if(opcio == 2) System.out.println(num1 * num2); else if(opcio == 3) System.out.println(num1 / num2); else System.out.println(\u0026quot;Opcio no correcta.\u0026quot;);  System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); var operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); var operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); var codi = sc.nextInt(); var resultat=0; if(codi==1) { resultat = operand1 - operand2; }else if(codi==2){ resultat = operand1 * operand2; }else if(codi==3){ resultat = operand1 / operand2; }else{ System.out.println(\u0026quot;Codi erroni\u0026quot;); } if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat);  El mateix exemple anterior però ara amb un switch.  Scanner sc = new Scanner(System.in); System.out.println(\u0026quot;Introdueix el primer operand\u0026quot;); var operand1 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el segon operand\u0026quot;); var operand2 = sc.nextInt(); System.out.println(\u0026quot;Introdueix el codi: 1.restar, 2.multiplicar, 3.dividir\u0026quot;); var codi = sc.nextInt(); var resultat=0; resultat = switch(codi) { case 1 -\u0026gt; operand1 - operand2; case 2 -\u0026gt; operand1 * operand2; case 3 -\u0026gt; operand1 / operand2; default -\u0026gt; throw new IllegalStateException(\u0026quot;Unexpected value: \u0026quot; + codi); }; if(codi == 1 || codi == 2 || codi == 3) System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot;+ resultat); switch(codi) { case 1, 2, 3 -\u0026gt; System.out.println(\u0026quot;El resultat de l'operacio és: \u0026quot; + resultat); }  Crea un programa que donats 4 números indiqui si els números són iguals i quin d\u0026rsquo;ells és el menor i major nombre de tots ells. El programa a més haurà de mostrar per pantalla el resultat de restar el major pel menor d\u0026rsquo;ells i el resultat de multiplicar els altres dos.  int num1 = sc.nextInt(); int num2 = sc.nextInt(); int num3 = sc.nextInt(); int num4 = sc.nextInt(); int max = num1; int min = num1; int mult; /** * * Són iguals?? */ if(num1 == num2 \u0026amp;\u0026amp; num1 == num3 \u0026amp;\u0026amp; num1 == num4) System.out.println(\u0026quot;Són iguals\u0026quot;); else System.out.println(\u0026quot;No són iguals\u0026quot;); /** * PROBLEMA DEL MAJOR MENOR 5 OPCIONS * */ //OPCIO 1 força bruta if(num2\u0026gt;num1 \u0026amp;\u0026amp; num2\u0026gt;num3 \u0026amp;\u0026amp; num2\u0026gt;num4)max = num2; else if(num3\u0026gt;num1 \u0026amp;\u0026amp; num3\u0026gt;num2 \u0026amp;\u0026amp; num3\u0026gt;num4) max = num3; else if(num4\u0026gt;num1 \u0026amp;\u0026amp; num4\u0026gt;num2 \u0026amp;\u0026amp; num4\u0026gt;num3) max = num4; if(num2\u0026lt;num1 \u0026amp;\u0026amp; num2\u0026lt;num3 \u0026amp;\u0026amp; num2\u0026lt;num4)min = num2; else if(num3\u0026lt;num1 \u0026amp;\u0026amp; num3\u0026lt;num2 \u0026amp;\u0026amp; num3\u0026lt;num4) min = num3; else if(num4\u0026lt;num1 \u0026amp;\u0026amp; num4\u0026lt;num2 \u0026amp;\u0026amp; num4\u0026lt;num3) min = num4; //OPCIO 2 comparem el max amb tots i el min amb tots individualment max = num1; if(num2\u0026gt;max) max = num2; if(num3\u0026gt;max) max = num3; if(num4\u0026gt;max) max = num4; min = num1; if(num2\u0026lt;min) min = num2; if(num3\u0026lt;min) min = num3; if(num4\u0026lt;min) min = num4; //OPCIO 3 a Semifinals comparant! int max1,max2, min1,min2; if(num1\u0026gt; num2)max1 = num1; else max1 = num2; if(num3 \u0026gt; num4) max2 = num3; else max2=num4; if(max1 \u0026gt; max2) max = max1; else max=max2; if(num1 \u0026lt; num2)min1 = num1; else min1 = num2; if(num3 \u0026lt; num4) min2 = num3; else min2=num4; if(min1 \u0026gt; min2) min = min1; else min=min2; //OPCIO 4 semifinals math.max math.min max1 = Math.max(num1,num2); max2 = Math.max(num3,num4); max = Math.max(max1,max2); min1 = Math.min(num1,num2); min2 = Math.min(num3,num4); min = Math.min(min1,min2); //OPCIO 5 math.max i math.min max = Math.max (Math.max(num1,num2), Math.max(num3,num4)); min = Math.min (Math.min(num1,num2), Math.min(num3,num4)); System.out.println(max-min); //Segona part de l'activitat on es realitza la multiplicacio amb els que no són major i menor if( (max==num1 \u0026amp;\u0026amp; min==num2) || (max==num2 \u0026amp;\u0026amp; min==num1))mult=num3 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num1))mult=num2 * num4; else if( (max==num1 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num1))mult=num2 * num3; else if( (max==num2 \u0026amp;\u0026amp; min==num3) || (max==num3 \u0026amp;\u0026amp; min==num2))mult=num1 * num4; else if( (max==num2 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num2))mult=num1 * num3; else if( (max==num3 \u0026amp;\u0026amp; min==num4) || (max==num4 \u0026amp;\u0026amp; min==num3))mult=num1 * num2; //Solució utilitzant Math.mix i Math.max per extreure valors que no siguin ni màxim ni mínim. int min3 = Math.min (Math.max(num1,num2), Math.max(num3,num4)); int max3 = Math.max (Math.min(num1,num2), Math.min(num3,num4)); int mult2 = min3 * max3;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2poo/7llibreries/",
	"title": "Llibreries",
	"tags": [],
	"description": "",
	"content": "Definició En el context de la programació una llibreria es un conjunt de codi re-utilitzable, encapsulat (paquets, classes, moduls, dll, \u0026hellip;) i documentat adequadament.\n En el cas de Java tenim llibreries de classes i les seves propietats. Per exemple podriem considerar la classe Math, que ens proporciona un conjunt de funcions matematiques, una llibreria en si mateixa. Ex:  int x = -15; int y = Math.abs(x);   Tambe tenim paquets com java.util que agrupen de forma organitzada un conjunt de classes amb unes funcionalitats comunes (utilitats). Veieu més exemples de les llibreries del SDK.  import java.util.Scanner;  Llibreries de classes: paquets  Una llibreria de classes, o package (paquet) en Java, es un conjunt de classes vinculades entre elles d’acord a algun criteri tematic o d’organitzacio del seu codi. Els paquets s\u0026rsquo;organitzen de forma jeràrquica, de manera que podem crear sub-paquets dins d\u0026rsquo;altres paquets: paquet1.paquet2.paquetn Els noms dels packages s’escriuen tots en minúscula i separant paquets i sub-paquets per un punt. (Naming Conventions) Totes les classes de Java pertanyen a algun package. En cas de no incloure cap sentència package, es considera que aquella classe pertany a un package especial anomenat per defecte (default package). Donada una classe, aquesta únicament pot pertanyer a un paquet. Donat un paquet, a dins seu mai hi poden haver dues classes amb el mateix nom.  Inclusio de classes dins d\u0026rsquo;un paquet  Per incloure una classe dins d\u0026rsquo;un paquet nomes cal incloure la següent sentencia al inici del fitxer de codi font, abans de qualsevol altra instrucció: package nomdelpaquet  Ús de classes d\u0026rsquo;altres paquets  Per usar classes definides en altres paquets cal usar la sentencia import:  import nomdelpaquet.Classe; import nomdelpaquet.*; package dam.uf2; import java.util.*; public class ComptaChar { ...  Estructura dels fitxers dins dels paquets  Els arxius .class pertanyents a paquets i subpaquets han d\u0026rsquo;estar organitzats de manera adequada perquè tant el compilador com la màquina virtual de Java puguin utilitzar-los. Cada paquet es situa en un directori. Cada sub-paquet s\u0026rsquo;ubica en un directori de nivell inferior, i així successivament. El nom de cada directori ha de ser el del propi paquet.  Paquets bàsics del JDK (Java Development Kit)  java.lang: es el paquet principal i el compilador l’incorpora de manera automatica (no cal importar-lo). Conté les classes bàsiques de Java, incloent-hi el tractament de cadenes de caràcters, el maneig de nombres i funcions matemàtiques, l’accés als recursos del sistema, i la programació multiarea. java.io: controla les operacions d’entrada i sortida i els arxius. java.util: conte classes i metodes de propòsits molt diversos, com ara generació de nombres aleatoris (Random), tractament d\u0026rsquo;arrays (Arrays), propietats del sistema, etc. java.net: dona suport a les comunicacions TCP/IP. Inclou les classes que fan referència a la comunicació en xarxa. java.applet: conté només la classe applet que permet el desenvolupament d’aplicacions incrustades en pàgines HTML. java.awt: conté les classes i els mètodes de l’Abstract Windows Toolkit, independents del sistema, per al maneig de la interfície d’usuari. java.awt.image: conté classes i mètodes independents del sistema, necessaris pel maneig de gràfics i imatges. java.awt.peer: com que les classes i els mètodes són específics de cada sistema, java.awt.peer conté les classes necessàries per connectar els components definits en el paquet java.awt amb els components correctes de cada sistema.  Exemple Si tenim un projecte amb el següent arbre de fitxers:\nL\u0026rsquo;estructura que necessitem en cada fitxer per poder veure la resta de fitxers és la següent:\n En el Main.java principal necessitem importar els dos fitxers que no tenim al mateix directori:  import classes.classes2.Funcions2; import classes.Funcions;   Per emprar Funcions3 desde Main no ens cal indicar-hi res ja que es troba al mateix directori i per tant ja és visible per Main.\n  Funcions es troba dins el package classes, per això en el Main cal importar-lo i en Funcions.java cal indicar-li a quin package pertany:\n  package classes;  De la mateixa manera Funcions2 es troba dins el package classes.classes2, per això en el Main cal importar-lo i en Funcions3.java cal indicar-li a quin package pertany:  package classes.classes2;  Aquí teniu l'enllaç al projecte: Projecte imports/package\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/8iteratiu/",
	"title": "Estructura repetició i salt",
	"tags": [],
	"description": "",
	"content": "Estructura iterativa L\u0026rsquo;estructura de control iterativa permet reproduir un bloc d\u0026rsquo;instruccions un nombre de vegades determinat.\nMentre es compleixi una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet executar un bloc d\u0026rsquo;instruccions determinat. Anomenarem bucle el bloc d\u0026rsquo;instruccions que es repeteixen i iteració a cadascuna de les vegades que es repeteix.\n Característiques generals:  Tots els bucles tenen:\n Una precondició: Estat abans d\u0026rsquo;entrar al bucle Una postcondició: Estat al sortir de bucle Una expressió booleana: mentre es compleixi l\u0026rsquo;expressió booleana s\u0026rsquo;itera el bucle, un cop l\u0026rsquo;expressió booleana s\u0026rsquo;avalua a fals es \u0026ldquo;surt\u0026rdquo; del bucle i es continua amb l\u0026rsquo;execució de les instruccions següents. Variable de control: Ens serveix per controlar el nombre d\u0026rsquo;iteracions. Aquesta variable pot estar englobada en un dels següents grups:  acumulador: guardem en una variable una operació concreta. comptador: augmentem o disminuïm una variable \u0026ldquo;comptant\u0026rdquo; iteracions. booleana: pot ser simplement una variable booleana que es manipuli dins el bucle.     Un bucle necessita:\n1. Una condició de sortida: cal que l\u0026rsquo;expressió booleana s\u0026rsquo;avaluï a fals per sortir del bucle, sinó provocarem un bucle infinit.\n2. La variable de control ens ha d\u0026rsquo;acostar pas a pas a complir amb la condició de sortida del bucle.\n3. Dins el bucle a d\u0026rsquo;haver instruccions amb l\u0026rsquo;objectiu de buscar el resultat que dóna origen al bucle.\n Existeixen diferents estructures iteratives.\n While For Do while Combinació d\u0026rsquo;estructures Instruccions de salt  1. While L\u0026rsquo;estructura bàsica d\u0026rsquo;un bucle while en Java és:\nwhile(expressió booleana){ Instruccions del bucle }  Com ja s\u0026rsquo;ha explicat, mentre s\u0026rsquo;avaluï l\u0026rsquo;expressió booleana a cert s\u0026rsquo;executaran totes les instruccions contingudes en les claus {}. Quan es deixi de complir l\u0026rsquo;expressió booleana el fil d\u0026rsquo;execució sortirà del bucle i continuarà amb la següent instrucció que hi hagi després.\nConsideracions:\n Si l\u0026rsquo;expressió no avalua a una expressió booleana donarà un error de compilació. Si no s\u0026rsquo;apliquen mecanismes que modifiquen el comportament de l\u0026rsquo;expressió booleana aconseguirem un bucle infinit.     Codi Diagrama de flux     Acció1;\nwhile ( cond ) {\nAcció2;\n}\nAcció4;     //Exemple. Objectiu: Imprimim de 1 a 10. int i = 1; //Acció 1 (variable de control) while(i \u0026lt;=10){ //cond System.out.println(i); //Acció 2 (Resultat que estem buscant) i++; //Acció 3 (Ens asseegurem que acaba el bucle ja que incrementem i) }  2. For El for és una estructura que permet realitzar recorreguts a un conjunt de dades de forma simple. Ens permet condensar la funcionalitat de bucle en una sola línia. Per exemple, si agafem l\u0026rsquo;exemple anterior, podem recorre els nombres del 1 al 10 de la següent manera:\nfor(int i=1; i \u0026lt;= 10; i++){ System.out.println(i); }  Com s\u0026rsquo;observa, dins dels parèntesi \u0026ldquo;()\u0026rdquo; tenim tres instruccions separades per \u0026ldquo;;\u0026rdquo; :\n Inicialització d\u0026rsquo;una variable iteradora abans d\u0026rsquo;entrar al bucle (int i=1). Després tenim l\u0026rsquo;expressió booleana igual com posaríem en un bucle while (i\u0026lt;=10). Finalment tenim el pas que ens assegura que el bucle acaba (i++).  Així doncs\nfor (inicialització Iterador; Expressió booleana; Modificació Iterador)\nCom s\u0026rsquo;ha observat amb els dos exemples anteriors: Qualsevol bucle while es pot transformar en un bucle for i viceversa.\n 3. Do while Aquesta estructura no és tan utilitzada i és similar a l\u0026rsquo;estructura while. La diferència és que en el while abans de realitzar cap iteració es comprova l\u0026rsquo;expressió booleana, en canvi amb el do while primer es realitzar una iteracio i després es comprova l\u0026rsquo;expressió booleana. A efectes pràctics si estem segurs que existeix almenys una iteració es pot usar aquesta estructura.\nEl cas anterior fet en do while seria:\nint i=1; //Inicialització variable do { System.out.println(i); // Resultat i++; //Modificació instrucció iteradora }while( i \u0026lt;= 10 ); //Expressió booleana     Codi Diagrama de flux     Acció1;\ndo {\nAcció2;\n} while ( cond );\nAcció3;     4. Combinació d\u0026rsquo;estructures Moltes vegades els nostres programes requereixen de més d\u0026rsquo;un bucle encadenat, per exemple quan resseguim una matriu de dades. Imagineu-vos un programa que escanegi un tauler d\u0026rsquo;escacs, no només ha de llegir files, sinó que també ha de llegir columnes, així doncs l\u0026rsquo;estructura seria la següent:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } }  En l\u0026rsquo;exemple anterior per cada posició ièssima es recorre el bucle 8 vegades per cada j. Així per cada fila recorrem totes les columnes. Si mirem l\u0026rsquo;execució del bucle obtenim:\nPosició 1 1 Posició 1 2 Posició 1 3 Posició 1 4 Posició 1 5 Posició 1 6 Posició 1 7 Posició 1 8 Posició 2 1 Posició 2 2 Posició 2 3 Posició 2 4 Posició 2 5 Posició 2 6 Posició 2 7 Posició 2 8 Posició 3 1 Posició 3 2 Posició 3 3 ... Posició 8 8  En aquest cas estem parlant de dos bucles que són independents entre ells. Ja que per cada bucle interior no té afectació en l\u0026rsquo;exterior.\nPerò a vegades és necessari que els bucles siguin dependents, en aquest cas sí que hi hauria afectació. Modifiquem el programa anterior perquè, per exemple, enlloc de mostrar tot el tauler de posicions només vull mostrar aquelles que es troben per sobre de la diagonal:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=1; j \u0026lt;= 8; j++){ if(i \u0026lt; j) { System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } } }  En aquest cas, si executeu veureu que només mostra la meitat superior de posicions. Això és així perquè en el bucle interior realitzem una operació que DEPÈN de la variable i que pertany al primer bucle, per tant el bucle interior depèn de l\u0026rsquo;exterior.\nEn el cas anterior, fixeu-vos que es realitzen 8 x 8 iteracions, sempre es realitzen totes 64 iteracions, quan el que volem és mostrar NOMÉS la meitat del tauler, una manera d\u0026rsquo;optimitzar el codi anterior seria la següent:\nfor(int i=1; i \u0026lt;= 8; i++){ for(int j=i; j \u0026lt;= 8; j++){ System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); } }  D\u0026rsquo;aquesta manera, observeu que s\u0026rsquo;ha eliminat la condició, però ja només es realitzen aquelles iteracions necessàries (la meitat respecte el cas anterior) per obtenir el mateix resultat: mostrar les caselles superiors de la diagonal del tauler d\u0026rsquo;escacs.\n5. Instruccions de Salt break La sentencia break té dos usos. El primer ús l\u0026rsquo;hem vist a l\u0026rsquo;apartat anterior quan serveix per acabar un case del switch. El segon ús és forçar l\u0026rsquo;acabament immediat d\u0026rsquo;un cicle, saltantla prova condicional normal del bucle o la sentència de selecció.\nPer exemple quan s\u0026rsquo;arribi a 10 es vol que es surti del bucle\nfor(int i=1; i \u0026lt;= 20; i++){ if(i == 10){ break; } System.out.println(\u0026quot;Posició \u0026quot; + i + \u0026quot; \u0026quot; + j); }  continue En aquest cas, la sentencia continue, a diferència del break, el que fa és saltar la iteració actual però continua iterant dins el bucle sense tenir en compte la iteració on s\u0026rsquo;executa el continue;.\nVolem imprimir tots els nombres del 1 al 20, a excepció del 10.\nfor(int i=1; i \u0026lt;= 20; i++){ if(i == 10){ continue; } System.out.println(i); }  Exemples  Fer un programa que llegeixi dos nombre enters n1 i n2 amb n1 \u0026lt; n2 i escrigui tots els nombres enters dins l’interval [n1, n2] en ordre creixent. Aquest és un exemple de recorregut on la variable n1 fa de comptador.  var n1 = sc.nextInt(); var n2 = sc.nextInt(); while(n1 \u0026lt;= n2) { System.out.println(n1); n1++; }  Fer un programa que llegeixi dos nombre enters n1 i n2 amb n1 \u0026lt; n2 i escrigui els nombres enters parells que hi ha dins l’interval [n1, n2] en ordre creixent. El nombre zero es considera parell.  int n1 = sc.nextInt(); int n2 = sc.nextInt(); for(int i=n1; i \u0026lt;= n2; i++) { if(i%2 == 0) System.out.println(i); } //2naOpcio (meitat d'iteracions) if(n1%2 != 0)n1++; while(n1\u0026lt;=n2) { System.out.println(n1); n1 = n1+2; }  Fer un programa que llegeixi el valor de la base, un nombre enter i l’exponent, un nombre enter no negatiu, i escrigui el valor de la potència a b . No emprar la funció Math.pow(). En aquest cas resultat fa d' acumulador d\u0026rsquo;un resultat que es mostra al final.  int base = sc.nextInt(); int exponent = sc.nextInt(); int i = 0; int resultat = 1; while(i \u0026lt; exponent) { resultat = resultat * base; i++; } System.out.println(resultat);  Fer un programa que llegeixi un nombre enter i escrigui si és un nombre primer o no. Un nombre enter és primer si es més gran que 1 i només és divisible per 1 i per ell mateix.  /* Fixeu-vos amb l'expressió booleana del bucle, en aquest cas es fa ús d'una variable booleana per sortir del bucle i no continuar iterant, en cas que ja haguem descobert la solució i no sigui necessari continuar iterant. */ System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); int n = sc.nextInt(); //inicialitzo variables,index=n/2 i analitzem tots els possibles divisors de n/2 fins a 1. boolean esPrimer = true; int index = n/2; //En la condició del bucle,si trobem un divisor ja no cal que continuem buscant i acabem while(index \u0026gt; 1 \u0026amp;\u0026amp; esPrimer){ if(n % index == 0) esPrimer = false; index--; } //Escrivim solucio String sol = (!esPrimer)? \u0026quot;NO és primer\u0026quot; : \u0026quot;És primer\u0026quot; ; System.out.println(sol);  Una altra manera de realitzar el cas anterior utilitzant el break seria la següent:\nSystem.out.println(\u0026quot;Llegeix nombre: \u0026quot;); var n = sc.nextInt(); var index = n/2; while(index \u0026gt; 1){ if(n % index == 0) { break; } index--; } //Escrivim solucio System.out.println((index == 1)? \u0026quot;És primer\u0026quot; : \u0026quot;NO és primer\u0026quot;);  Fer un programa que llegeixi un nombre enter i escrigui si és capicua o no.Considerarem també capicues els nombres enters d\u0026rsquo;una xifra.  System.out.println(\u0026quot;Llegeix nombre: \u0026quot;); var n = sc.nextInt(); var valorInicial = n; var capicua = 0; while(n\u0026gt;0){ capicua = capicua*10; capicua = capicua + n%10; System.out.println(capicua); n = n/10; } System.out.println(capicua); if(valorInicial == capicua) System.out.println(n+ \u0026quot;és un nombre capicua\u0026quot;);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/9excepcions/",
	"title": "Excepcions",
	"tags": [],
	"description": "",
	"content": "L\u0026rsquo;API de Java s\u0026rsquo;organitza per paquets que agrupen diferents funcionalitats. Entre elles trobem el tractament de les excepcions. En Java es distingeix una excepció d\u0026rsquo;un error, per això també tenen les seves pròpies classes Exception i Error.\nEls Errors corresponen a situacions irrecuperables que no depenen del programador i que per tant no tenim mecanismes per poder tractar-les. Quan apareix un error provoca la finalització del programa.\n Les Excepcions són casuístiques que es produeixen en temps d\u0026rsquo;execució i que poden provocar problemes en el desenvolupament normal del nostre programa, aquestes sí que Java pot preveure-les i realitzar-ne un codi per tractar-les.\n Existeixen dos tipus d\u0026rsquo;excepcions:\n Implícites: són aquelles casuístiques pròpies de la JVM i que estan incloses dins la classe RuntimeError. Normalment tenen a veure amb errors de programació. Explícites: són aquelles que no tenen a veure amb RuntimeError i que el programador les pot tractar allà on tenen lloc.  Per tal de tractar les excepcions quan es produeixen Java ofereix el mecanisme de try-catch-finally.\ntry{ //bloc de codi que provoca l'excepció }catch(nomClasse Excepcio e){ //tractament de l'excepció }finally{ //encara que hi hagi excepció codi que s'executarà sempre }  El codi que trobem dins el bloc try és aquell que estem \u0026ldquo;vigilant\u0026rdquo; o és sospitós de llançar una excepció, per exemple quan obrim un fitxer que no existeix, tenim una ruta que està malament o intentem dividir entre 0.\nEn casos com els anteriors la JVM genera una Excepció que pot ser tractada dins el bloc catch. Un cop es detecta l\u0026rsquo;existència d\u0026rsquo;una excepció el que fa Java és comprovar si existeix algun bloc catch (poden haver-ne més d\u0026rsquo;un, els escriurem del més específic al més genèric), entra en el primer que coincideixi l\u0026rsquo;Exception i n\u0026rsquo;executa el codi de dins el bloc.\nSi no existeix cap bloc catch que \u0026ldquo;capturi\u0026rdquo; el tipus d\u0026rsquo;excepció, aquesta és llançada al bloc de codi que ha cridat aquest mètode i funció, de forma que serà el responsable de tractar-la.\nSi es dóna el cas que aquesta excepció no es controla, ni tan sols en el main, es produeix una finalització anormal de l\u0026rsquo;execució del programa.\nEl codi contingut en el bloc finally s\u0026rsquo;executa sempre, hi hagi o no una excepció. Això ens pot anar molt bé quan hi ha codi que sempre s\u0026rsquo;ha d\u0026rsquo;executar independentment de l\u0026rsquo;existència o no d\u0026rsquo;una excepció, per exemple el tancament d\u0026rsquo;una base de dades o el tancament d\u0026rsquo;un descriptor de fitxer.\nResumint, quan dins un bloc try es produeix una excepció, la JVM llança (throw) una excepció que serà capturada (catch) per un bloc catch o per un codi superior que hagi cridat aquest mètode/funció.\nExemples d\u0026rsquo;error:\n Ens quedem sense memòria. Falla el canal d\u0026rsquo;E/S. Falla el servei d\u0026rsquo;algun proveïdor.  Exemples d\u0026rsquo;excepcions:\n Fitxer que no té permisos. Fitxer inexistent. Operació aritmètica errònia (dividir per zero). Accés a una posició d\u0026rsquo;una taula inexistent. Accés a una referència a un objecte inexistent.  Exemples d\u0026rsquo;excepcions\nIllegalArgumentException\nEn el cas del switch vist en l\u0026rsquo;apartat d\u0026rsquo;estructura de selecció hem vist aquest tipus d\u0026rsquo;excepció, es produïa quan s\u0026rsquo;intentava accedir a un element de l\u0026rsquo;enum (Enumeració) que no existia. En l\u0026rsquo;exemple veureu com es realitza el try catch.\nIllegalStateException\nTambé en els exemples de l\u0026rsquo;estructura de selecció, en l\u0026rsquo;exemple 4, s\u0026rsquo;observa com es pot tractar l\u0026rsquo;error inesperat de rebre un valor de l\u0026rsquo;argument del switch inesperat, una opció és que el propi default \u0026ldquo;llançi\u0026rdquo; una excepció si s\u0026rsquo;hi arriba. (throw new Exception).\nInputMismatchException\nIntroducció d\u0026rsquo;un valor a una variable que NO és del mateix tipus.\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int n; do{ try{ System.out.print(\u0026quot;Introdueix un nombre \u0026gt; 0:\u0026quot;; n = sc.nextInt(); System.out.println(\u0026quot;Nombre introduït: \u0026quot; + n); }catch(InputMismatchException e){ sc.nextLine(); n = 0; System.out.println(\u0026quot;Has d'introduir un nombre enter: \u0026quot; + e.toString()); } }while(n\u0026lt;=0); }  ArithmeticException\nOperació aritmètica errònia.\npublic static void main(String[] args) { int numerador = 10; int denominador = 0; try{ int n = numerador / denominador; }catch(ArithmeticException e){ System.out.println(\u0026quot;Has volgut dividir entre 0 : \u0026quot; + e.toString()); n = 0; } }  En tots els casos anteriors haguessis pogut substituir el tipus de l\u0026rsquo;Excepció per Exception ja que tots són de tipus Exception només que estan especialitzats pel tipus d\u0026rsquo;error que capturen.\nFins el moment les excepcions han estat generades per la JVM quan s\u0026rsquo;ha detectat una casuística inesperada, però les excepcions es poden generar manualment emprant throw new Exception. Per exemple:\npublic static void main(String[] args) { Scanner sc = new Scanner(System.in); int numerador = sc.nextInt(); int denominador = sc.nextInt(); int n; try{ if (denominador == 0) throw new ArithmeticException(); else n = numerador / denominador; }catch(ArithmeticException e){ System.out.println(\u0026quot;Has volgut dividir entre 0 : \u0026quot; + e); n = 0; }finally{ System.out.println(n); } }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/10depuracioassercions/",
	"title": "Depuració i assercions",
	"tags": [],
	"description": "",
	"content": "Depuració de codi La depuració de codi ens ajudarà a corregir el nostre codi per tal que tingui el comportament que n\u0026rsquo;esperem. Normalment cal classificar dues problemàtiques diferents: existeixen error en la compilació, o no existeixen errors en la compilació però el resultat esperat no és el que hauria de ser.\nErrors de compilació Els errors venen perquè un cop compilem el codi, aquest té errors sintàtics i/o semàntics que no permeten crear el .class a partir del qual executem. Quan això passa veurem imprès per línia de comandes quin tipus d\u0026rsquo;error tinc i en quina línia és detectat. És necessari entendre molt bé els tipus d\u0026rsquo;error més comuns per tal de saber on està la solució al problema. Cal aprendre a llegir errors i a documentar-se sobre els errors, són molt variats i de moltes tipologies diferents, tot seguit, un recull dels més comuns al principi:\nErrors típics  En aquest cas apreciem que la instrucció index\u0026ndash; li falta \u0026ldquo;;\u0026rdquo; de finalització. En l\u0026rsquo;error ens indica la línia 25, i el caràcter 20 des de l\u0026rsquo;inici de la línia.    El següent error ens indica que l\u0026rsquo;operador relacional de comparació d\u0026rsquo;iguals és el \u0026ldquo;==\u0026rdquo;, no el \u0026ldquo;=\u0026rdquo; com hem posat. En Java \u0026ldquo;=\u0026rdquo; és l\u0026rsquo;assignació d\u0026rsquo;una valor a una variable, mentre que \u0026ldquo;==\u0026rdquo; realitza la comparació entre dues variables del mateix tipus. Per això el que passa dins l\u0026rsquo;expressió index = 1 és que s\u0026rsquo;assigna el valor 1 a index i després no es troba un valor booleà necessari per avaluar la condició.    L\u0026rsquo;error en aquest cas es deu a que a la variable var n se li assigna un String ja que la lectura prové de sc.next(); Per tant no és un enter com es demana alhora de realitzar la divisió a la següent instrucció.    Aquest error es deu a que falta \u0026ldquo;()\u0026rdquo; a la funció sc.nextInt. Sense \u0026ldquo;()\u0026rdquo; no es detecta que és una funció de lectura d\u0026rsquo;enters de la classe Scanner com s\u0026rsquo;indica en l\u0026rsquo;error.  El resultat no és l\u0026rsquo;esperat. En aquests casos és necessari aprendre a depurar bé el codi ja que necessitem entedre en quin punt de l\u0026rsquo;execució divergeix del que teníem planificat. Per tal de depurar el codi existeixen diferents tècniques.\n \u0026ldquo;System.out.println\u0026rdquo;. Aquesta tècnica s\u0026rsquo;aplica, sobretot, en codis senzills o curts, que no necessitin de molta infraestructura. Consisteix en observar el valor de certes variables en certs punts per descobrir si:   El programa arriba a entrar en aquell punt i per tant s\u0026rsquo;observa el que s\u0026rsquo;imprimeix. (Si no és així cal investigar anteriorment quin és el camí que segueix fins on hauria hagut d\u0026rsquo;arribar) Les variables tenen els valors esperats en aquell/s punt/s concret/s.  Breakpoint - debugger de Intellij Idea Una eina més potent és la que ens ofereix el propi IDE de desenvolupament. Consisteix en determinar punts exactes del nostre codi i parar l\u0026rsquo;execució de forma intermitent per comprovar TOTS els valors de totes les variables que es guarden en memòria, això ens ajuda a descobrir si en un determinat punt el comportament que s\u0026rsquo;espera del programa és l\u0026rsquo;esperat.  Mitjançant aquesta tècnica es permet determinar tants punts com volguem en l\u0026rsquo;execució del codi. Quan s\u0026rsquo;arriba a aquests punts el programa es queda en un estat latent, i ens permet a nosaltres, avançar instrucció a instrucció, o bé avançar fins al següent breakpoint que tinguem definit. Per exemple, si tenim un bucle i posem un sol breakpoint en el bloc on s\u0026rsquo;itera, permetrà en cada iteració visualitzar el valor de les variables que es van modificant.\nPer tal d\u0026rsquo;utilitzar aquesta tècnica cal que:\n Marquem aquelles línies on volem aturar l\u0026rsquo;execució, això ho realitzem marcant la rodoneta vermella que ens apareix al costat de cada instrucció on volem realitzar una parada.  A continuació anem a executar el fil del codi com a debugger, és l\u0026rsquo;element de color verd que tenim al costat del triangle verd:  El que farà el codi a continuació és continuar la seva execució normal fins que trobi la instrucció que hem fixat amb el breakpoint. En aquest punt, s\u0026rsquo;aturarà l\u0026rsquo;execució i permetrà veure els valors que tenen les variables fins al moment (imatge inferior). El següent pas és determinar si el comportament és l\u0026rsquo;esperat i a partir d\u0026rsquo;aquí podem anar al següent breakpoint (Mayus + F8 - step out) o executar el codi línia a línia (F7 - step into), dependrà del que ens interessi.  Assercions Les assercions en Java serveixen per comprovar que els blocs de codi que estem implementant estan donant els resultats esperats a partir d\u0026rsquo;una sèrie de tests que implementem. Existeixen llibreries molt complertes pel maneig d\u0026rsquo;assercions en Java: JUnit, Mockito, Selenium, etc.\nNo és objecte d\u0026rsquo;aquesta primera part configurar una d\u0026rsquo;aquestes llibreries, senzillament ensenyem com configurar en Intellij Idea l\u0026rsquo;habilitació d\u0026rsquo;assercions i comprovar com utilitzar-les.\nPer fer-ho, cal que:\n Aneu al menú superior, en Run-\u0026gt;Edit Configurations. En Modify Options afegiu VM options com a paràmetre dels elements de configuració de l\u0026rsquo;execució del programa. En aquest camp cal que hi poseu -ea (Enable Assertions), per defecte estan \u0026ldquo;disabled\u0026rdquo; i per tant encara que escrivíssim asserts no en veuríem el resultat. Un cop heu escrit -ea cal que li doneu a Apply.  Ara sí ja podem escriure asserts en el nostre codi.\nEls asserts ens són útils per comprovar els valors que prenen les nostres variables i llançar excepcions quan no compleixen amb els nostres requisits o valors esperats.\nPer exemple, retornant a l\u0026rsquo;exemple de les notes que havíem fet durant l\u0026rsquo;estructura de selecció, aplicarem un assert quan la nota introduïda no estigui continguda entre 0 i 10.\nScanner sc = new Scanner(System.in); var nota = sc.nextInt(); assert nota \u0026gt;= 0 \u0026amp;\u0026amp; nota \u0026lt;= 10 : \u0026quot;La nota ha d'estar entre 0 i 10\u0026quot;; if (nota \u0026lt; 5) { System.out.println(\u0026quot;Suspès\u0026quot;); else if (nota \u0026lt; 6) { System.out.println(\u0026quot;Aprovat\u0026quot;); } else if (nota \u0026lt; 8) { System.out.println(\u0026quot;Bé\u0026quot;); } else if (nota \u0026lt; 9) { System.out.println(\u0026quot;Notable\u0026quot;); } else{ System.out.println(\u0026quot;Excel·lent\u0026quot;); }  Com s\u0026rsquo;observa, si la nota no està entre 0 i 10 el programa llançarà una excepció on s\u0026rsquo;indica que s\u0026rsquo;espera una nota entre 0 i 10.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/zzz_gesti%C3%B3-bbddor/",
	"title": "Introducció a la Persistència en BBDDs",
	"tags": [],
	"description": "",
	"content": "Java ofereix la interfície de programació JDBC (Java DataBase Connectivity) per a l’accés a bases de dades. L’API JDBC conté una gran quantitat de interfícies que permeten desenvolupar aplicacions que interactuen amb bases de dades, facilitant-ne la connexió i la consulta.\nAmb JDBC escrivim aplicacions usant les seves interfícies i els seus mètodes definits, de manera independent a com són realment implementats per les classes reals que les implementen. Els fabricants de les diferents bases de dades són els encarregats de proporcionar aquestes classes que implementen la interfície JDBC.\nAquests conjunt de classes que implementen JDBC són els controladors o drivers proporcionats pels fabricants per a poder interactuar amb la seva base de dades des de Java.\nPassos de connexió i consulta amb JDBC Passos habituals en una aplicació que usa JDBC per a l\u0026rsquo;accés a una base de dades:\n Creació d’una instància del controlador o driver JDBC, usant el nom de la classe Java del driver  private static Connection con; public static Connection getConnection() { if (con == null ) { try { //Creació d’una instància del controlador JDBC //(es creen els objectes en carregar-se la classe) Class.forName(\u0026quot;org.sqlite.JDBC\u0026quot;);  Crear una connexió a la base de dades amb un objecte Connection, a partir de la URL de connexió a la base de dades. La sintaxis de la URL és jdbc:subprotocol:paràmetres  //Crear una connexió a la base de dades amb un objecte Connection con = DriverManager.getConnection(\u0026quot;jdbc:sqlite:Chinook_Sqlite.sqlite\u0026quot;); } catch (ClassNotFoundException | SQLException e) { System.err.println(e.getClass().getName() + \u0026quot;: \u0026quot; + e.getMessage()); System.exit(0); } System.out.println(\u0026quot;Opened database successfully\u0026quot;); } return con; }  Crear una consulta / query amb un objecte Statement  public void seleccionaAlbums() { Statement stmt = null; try { //Crear una consulta / query amb un object Statement stmt = con.createStatement();  Executar la consulta  //Executar la consulta ResultSet rs = stmt.executeQuery( \u0026quot;SELECT * FROM Album;\u0026quot; );  Si la consulta ha de retornar resultats, com un select, usem executeQuery, que retorna un ResultSet amb les dades resultants de la consulta. Si la consulta no ha de retornar resultats, com un insert, update o delete, usem executeUpdate, que retorna el número de registres afectats.\nProcesar el resultat amb l’objecte ResultSet  //Procesar el resultat amb l’objecte ResultSet while ( rs.next() ) { int albumId = rs.getInt(\u0026quot;AlbumId\u0026quot;); String title = rs.getString(\u0026quot;Title\u0026quot;); int artistId = rs.getInt(\u0026quot;ArtistId\u0026quot;); System.out.println( \u0026quot;albumId : \u0026quot; + albumId ); System.out.println( \u0026quot;title : \u0026quot; + title ); System.out.println( \u0026quot;artistId : \u0026quot; + artistId ); System.out.println(); } rs.close(); stmt.close(); } catch ( Exception e ) { System.err.println( e.getClass().getName() + \u0026quot;: \u0026quot; + e.getMessage() ); System.exit(0); } System.out.println(\u0026quot;Operation done successfully\u0026quot;); }  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/",
	"title": "M03 Programació DAM",
	"tags": [],
	"description": "",
	"content": "M03 Programació DAM En aquesta pàgina web trobareu els apunts del M03.Programació DAM. La web està realitzada utilitzant un Framework Web(Hugo), hostatjada a Github i es fa ús de Github Pages.\nTot seguit es mostra la calendarització i l\u0026rsquo;assignació d\u0026rsquo;hores per cada RA que s\u0026rsquo;imparteix en aquest mòdul de 1r de DAM.\n   UF dates hores     RA1 Reconeix l\u0026rsquo;estructura d\u0026rsquo;un programa informàtic, identificant i relacionant els elements propis del llenguatge de programació utilitzat. 12/09/24 - 25/09/24 10h   RA3 Escriu i depura codi, analitzant i utilitzant les estructures de control del llenguatge. 26/09/24 - 11/11/24 40h   RA2 Escriu i prova programes senzills, reconeixent i aplicant els fonaments de la programació orientada a objectes. 12/11/24 - 27/11/24 10h   RA4 Desenvolupa programes organitzats en classes analitzant i aplicant els principis de la programació orientada a objectes. 28/11/24 - 16/12/25 20h   RA6 Escriu programes que manipulin informació seleccionant i utilitzant tipus avançats de dades. 17/12/24 - 17/02/25 40h   RA7 Desenvolupa programes aplicant característiques avançades dels llenguatges orientats a objectes i de l\u0026rsquo;entorn de programació. 18/02/25 - 02/04/25 40h   RA5 Realitza operacions d\u0026rsquo;entrada i sortida d\u0026rsquo;informació, utilitzant procediments específics del llenguatge i llibreries de classes. 03/04/25 - 02/05/25 20h   RA9 Gestiona informació emmagatzemada en bases de dades mantenint la integritat i consistència de les dades. 03/05/25 - 14/05/25 10h   RA8 Utilitza bases de dades orientades a objectes, analitzant-ne les característiques i aplicant tècniques per mantenir la persistència de la informació. 15/05/25 - 23/05/25 8h    L\u0026rsquo;índex de continguts que veurem és:\nAEA1: Programació estructurada\n Programació estructurada  Introducció a la programació Entorn Java Algorisme Tipus de dades i variables  Primer programa Operadors aritmètics, lògics i relacionals Conversions de tipus   Què és la programació estructurada? Estructura sequencial Estructures de selecció Estructures de repetició i de salt Excepcions Depuració de codi i assercions    AEA2: Introducció a la Programació Orientada a Objectes (POO)\n Introducció a la POO  Funcions i pas de paràmetres Definicions i exemple Instanciació d\u0026rsquo;objectes Estructura de classe i mètodes  Visibilitat Mètodes estàtics   Construcció i destrucció d\u0026rsquo;objectes Ús de mètodes i propietats Concepte d\u0026rsquo;herència i ús Llibreries    AEA3: Estructura de dades\n Estructures de dades  Estructures estàtiques i dinàmiques Arrays Unidimensionals Arrays Bidimensionals Tractament cadena de caràcters  Operacions Regulars StringBuilder   Col·leccions  Llistes: ArrayList Conjunts: Hashset Diccionaris: HashMap Genericitat   Operacions Agregades    AEA4: POO Avançada\n POO Avançat  Herència i polimorfisme  Sealed classes Col·leccions i funcions polimòrfiques Protected   Classes abstractes i finals Interfícies Bones pràctiques en POO  Defensive Copy Tractament de les Excepcions   Principis SOLID    AEA5: E/S Dades\n E/S Dades  Fluxos de dades: byte, character Gestió File Manipulació fitxers  Text Binari Accés aleatori   Interfícies gràfiques d\u0026rsquo;usuari (GUI)    AEA6: Gestió de BBDDs\n Gestió de BBDDs  Accés a BBDDOO  Estàndards Característiques Connexió   Accés a BBDDOO  Lectura Emmagatzematge Actualització Esborrat   Tipus de dades objecte Tipus de dades col·leccions    "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]