[
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arrayunidimensional/",
	"title": "Arrays Unidimensionals",
	"tags": [],
	"description": "",
	"content": "Global site parameters On top of Hugo global configuration, Hugo-theme-learn lets you define the following parameters in your config.toml (here, values are default).\nNote that some of these parameters are explained in details in other sections of this documentation.\n[params] # Prefix URL to edit current page. Will display an \u0026quot;Edit this page\u0026quot; button on top right hand corner of every page. # Useful to give opportunity to people to create merge request for your doc. # See the config.toml file from this documentation site to have an example. editURL = \u0026quot;\u0026quot; # Author of the site, will be used in meta information author = \u0026quot;\u0026quot; # Description of the site, will be used in meta information description = \u0026quot;\u0026quot; # Shows a checkmark for visited pages on the menu showVisitedLinks = false # Disable search function. It will hide search bar disableSearch = false # Javascript and CSS cache are automatically busted when new version of site is generated. # Set this to true to disable this behavior (some proxies don't handle well this optimization) disableAssetsBusting = false # Set this to true to disable copy-to-clipboard button for inline code. disableInlineCopyToClipBoard = false # A title for shortcuts in menu is set by default. Set this to true to disable it. disableShortcutsTitle = false # When using mulitlingual website, disable the switch language button. disableLanguageSwitchingButton = false # Hide breadcrumbs in the header and only show the current page title disableBreadcrumb = true # Hide Next and Previous page buttons normally displayed full height beside content disableNextPrev = true # Order sections in menu by \u0026quot;weight\u0026quot; or \u0026quot;title\u0026quot;. Default to \u0026quot;weight\u0026quot; ordersectionsby = \u0026quot;weight\u0026quot; # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;\u0026quot; # Provide a list of custom css files to load relative from the `static/` folder in the site root. custom_css = [\u0026quot;css/foo.css\u0026quot;, \u0026quot;css/bar.css\u0026quot;]  Activate search If not already present, add the follow lines in the same config.toml file.\n[outputs] home = [ \u0026quot;HTML\u0026quot;, \u0026quot;RSS\u0026quot;, \u0026quot;JSON\u0026quot;]  Learn theme uses the last improvement available in hugo version 20+ to generate a json index file ready to be consumed by lunr.js javascript search engine.\n Hugo generate lunrjs index.json at the root of public folder. When you build the site with hugo server, hugo generates it internally and of course it doesn’t show up in the filesystem\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/",
	"title": "Estructura d’un programa",
	"tags": [],
	"description": "",
	"content": "Chapter 1 1.Estructura d’un programa informàtic En aquest apartat veurem Propòsits i Blocs.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/1propositiblocs/",
	"title": "Propòsit i Blocs d&#39;un programa",
	"tags": [],
	"description": "",
	"content": "Què és l\u0026rsquo;enginyeria del software? De l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria a l\u0026rsquo;programari sorgeixen els processos de desenvolupament de programari. Aquest procés es defineix com \u0026ldquo;aquell en què les necessitats de l\u0026rsquo;usuari són traduïdes en requisits de programari, aquests requisits transformats en disseny, i el disseny implementat en codi, que és provat, documentat i certificat pel seu ús operatiu\u0026rdquo; [Jacobson, 1998].\n aracterístiques del software  S\u0026rsquo;ha invertit la demanda i el preu respecte al HW. El Software es un producte lògic que es desenvolupa, no es construeix com la resta de productes. La gestió de costos es centra en l\u0026rsquo;enginyeria, amb la qual difereix d\u0026rsquo;altres projectes d\u0026rsquo;enginyeria. El Software no es deteriora amb el temps, però sí és necessari un manteniment. La reutilització de productes software creixent. Existeixen restriccions de recursos en el desenvolupament de software, de forma que és necessari assegurar-ne la qualitat per obtenir un software: documentat, fiable, eficient i amb una bona interfície gràfica.  On top of Hugo global configuration, Hugo-theme-learn lets you define the following parameters in your config.toml (here, values are default).\nNote that some of these parameters are explained in details in other sections of this documentation.\n[params] # Prefix URL to edit current page. Will display an \u0026quot;Edit this page\u0026quot; button on top right hand corner of every page. # Useful to give opportunity to people to create merge request for your doc. # See the config.toml file from this documentation site to have an example. editURL = \u0026quot;\u0026quot; # Author of the site, will be used in meta information author = \u0026quot;\u0026quot; # Description of the site, will be used in meta information description = \u0026quot;\u0026quot; # Shows a checkmark for visited pages on the menu showVisitedLinks = false # Disable search function. It will hide search bar disableSearch = false # Javascript and CSS cache are automatically busted when new version of site is generated. # Set this to true to disable this behavior (some proxies don't handle well this optimization) disableAssetsBusting = false # Set this to true to disable copy-to-clipboard button for inline code. disableInlineCopyToClipBoard = false # A title for shortcuts in menu is set by default. Set this to true to disable it. disableShortcutsTitle = false # When using mulitlingual website, disable the switch language button. disableLanguageSwitchingButton = false # Hide breadcrumbs in the header and only show the current page title disableBreadcrumb = true # Hide Next and Previous page buttons normally displayed full height beside content disableNextPrev = true # Order sections in menu by \u0026quot;weight\u0026quot; or \u0026quot;title\u0026quot;. Default to \u0026quot;weight\u0026quot; ordersectionsby = \u0026quot;weight\u0026quot; # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;\u0026quot; # Provide a list of custom css files to load relative from the `static/` folder in the site root. custom_css = [\u0026quot;css/foo.css\u0026quot;, \u0026quot;css/bar.css\u0026quot;]  Activate search If not already present, add the follow lines in the same config.toml file.\n[outputs] home = [ \u0026quot;HTML\u0026quot;, \u0026quot;RSS\u0026quot;, \u0026quot;JSON\u0026quot;]  Learn theme uses the last improvement available in hugo version 20+ to generate a json index file ready to be consumed by lunr.js javascript search engine.\n Hugo generate lunrjs index.json at the root of public folder. When you build the site with hugo server, hugo generates it internally and of course it doesn’t show up in the filesystem\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/arraybidimensional/",
	"title": "Arrays Bidimensionals",
	"tags": [],
	"description": "",
	"content": "Hugo-theme-learn has been built to be as configurable as possible by defining multiple partials\nIn themes/hugo-theme-learn/layouts/partials/, you will find all the partials defined for this theme. If you need to overwrite something, don\u0026rsquo;t change the code directly. Instead follow this page. You\u0026rsquo;d create a new partial in the layouts/partials folder of your local project. This partial will have the priority.\nThis theme defines the following partials :\n header: the header of the content page (contains the breadcrumbs). Not meant to be overwritten custom-header: custom headers in page. Meant to be overwritten when adding CSS imports. Don\u0026rsquo;t forget to include style HTML tag directive in your file footer: the footer of the content page (contains the arrows). Not meant to be overwritten custom-footer: custom footer in page. Meant to be overwritten when adding Javacript. Don\u0026rsquo;t forget to include javascript HTML tag directive in your file favicon: the favicon logo: the logo, on top left hand corner. meta: HTML meta tags, if you want to change default behavior menu: left menu. Not meant to be overwritten menu-footer: footer of the the left menu search: search box toc: table of contents  Change the logo Create a new file in layouts/partials/ named logo.html. Then write any HTML you want. You could use an img HTML tag and reference an image created under the static folder, or you could paste a SVG definition !\nThe size of the logo will adapt automatically\n Change the favicon If your favicon is a png, just drop off your image in your local static/images/ folder and name it favicon.png\nIf you need to change this default behavior, create a new file in layouts/partials/ named favicon.html. Then write something like this:\n\u0026lt;link rel=\u0026quot;shortcut icon\u0026quot; href=\u0026quot;/images/favicon.png\u0026quot; type=\u0026quot;image/x-icon\u0026quot; /\u0026gt;  Change default colors Hugo Learn theme let you choose between 3 native color scheme variants, but feel free to add one yourself ! Default color scheme is based on Grav Learn Theme.\nRed variant [params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;red\u0026quot;  Blue variant [params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;blue\u0026quot;  Green variant [params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;green\u0026quot;  \u0026lsquo;Yours‘ variant First, create a new CSS file in your local static/css folder prefixed by theme (e.g. with mine theme static/css/theme-mine.css). Copy the following content and modify colors in CSS variables.\n:root{ --MAIN-TEXT-color:#323232; /* Color of text by default */ --MAIN-TITLES-TEXT-color: #5e5e5e; /* Color of titles h2-h3-h4-h5 */ --MAIN-LINK-color:#1C90F3; /* Color of links */ --MAIN-LINK-HOVER-color:#167ad0; /* Color of hovered links */ --MAIN-ANCHOR-color: #1C90F3; /* color of anchors on titles */ --MENU-HEADER-BG-color:#1C90F3; /* Background color of menu header */ --MENU-HEADER-BORDER-color:#33a1ff; /*Color of menu header border */ --MENU-SEARCH-BG-color:#167ad0; /* Search field background color (by default borders + icons) */ --MENU-SEARCH-BOX-color: #33a1ff; /* Override search field border color */ --MENU-SEARCH-BOX-ICONS-color: #a1d2fd; /* Override search field icons color */ --MENU-SECTIONS-ACTIVE-BG-color:#20272b; /* Background color of the active section and its childs */ --MENU-SECTIONS-BG-color:#252c31; /* Background color of other sections */ --MENU-SECTIONS-LINK-color: #ccc; /* Color of links in menu */ --MENU-SECTIONS-LINK-HOVER-color: #e6e6e6; /* Color of links in menu, when hovered */ --MENU-SECTION-ACTIVE-CATEGORY-color: #777; /* Color of active category text */ --MENU-SECTION-ACTIVE-CATEGORY-BG-color: #fff; /* Color of background for the active category (only) */ --MENU-VISITED-color: #33a1ff; /* Color of 'page visited' icons in menu */ --MENU-SECTION-HR-color: #20272b; /* Color of \u0026lt;hr\u0026gt; separator in menu */ } body { color: var(--MAIN-TEXT-color) !important; } textarea:focus, input[type=\u0026quot;email\u0026quot;]:focus, input[type=\u0026quot;number\u0026quot;]:focus, input[type=\u0026quot;password\u0026quot;]:focus, input[type=\u0026quot;search\u0026quot;]:focus, input[type=\u0026quot;tel\u0026quot;]:focus, input[type=\u0026quot;text\u0026quot;]:focus, input[type=\u0026quot;url\u0026quot;]:focus, input[type=\u0026quot;color\u0026quot;]:focus, input[type=\u0026quot;date\u0026quot;]:focus, input[type=\u0026quot;datetime\u0026quot;]:focus, input[type=\u0026quot;datetime-local\u0026quot;]:focus, input[type=\u0026quot;month\u0026quot;]:focus, input[type=\u0026quot;time\u0026quot;]:focus, input[type=\u0026quot;week\u0026quot;]:focus, select[multiple=multiple]:focus { border-color: none; box-shadow: none; } h2, h3, h4, h5 { color: var(--MAIN-TITLES-TEXT-color) !important; } a { color: var(--MAIN-LINK-color); } .anchor { color: var(--MAIN-ANCHOR-color); } a:hover { color: var(--MAIN-LINK-HOVER-color); } #sidebar ul li.visited \u0026gt; a .read-icon { color: var(--MENU-VISITED-color); } #body a.highlight:after { display: block; content: \u0026quot;\u0026quot;; height: 1px; width: 0%; -webkit-transition: width 0.5s ease; -moz-transition: width 0.5s ease; -ms-transition: width 0.5s ease; transition: width 0.5s ease; background-color: var(--MAIN-LINK-HOVER-color); } #sidebar { background-color: var(--MENU-SECTIONS-BG-color); } #sidebar #header-wrapper { background: var(--MENU-HEADER-BG-color); color: var(--MENU-SEARCH-BOX-color); border-color: var(--MENU-HEADER-BORDER-color); } #sidebar .searchbox { border-color: var(--MENU-SEARCH-BOX-color); background: var(--MENU-SEARCH-BG-color); } #sidebar ul.topics \u0026gt; li.parent, #sidebar ul.topics \u0026gt; li.active { background: var(--MENU-SECTIONS-ACTIVE-BG-color); } #sidebar .searchbox * { color: var(--MENU-SEARCH-BOX-ICONS-color); } #sidebar a { color: var(--MENU-SECTIONS-LINK-color); } #sidebar a:hover { color: var(--MENU-SECTIONS-LINK-HOVER-color); } #sidebar ul li.active \u0026gt; a { background: var(--MENU-SECTION-ACTIVE-CATEGORY-BG-color); color: var(--MENU-SECTION-ACTIVE-CATEGORY-color) !important; } #sidebar hr { border-color: var(--MENU-SECTION-HR-color); }  Then, set the themeVariant value with the name of your custom theme file. That\u0026rsquo;s it !\n[params] # Change default color scheme with a variant one. Can be \u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;green\u0026quot;. themeVariant = \u0026quot;mine\u0026quot;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/sequencial/",
	"title": "Estructura seqüencial",
	"tags": [],
	"description": "",
	"content": "Estructura seqüencial En l\u0026rsquo;estructura seqüencial permet descomposar un problema en instruccions que s\u0026rsquo;executaran de la primera a la última seguint un ordre de forma incondicional.\n L\u0026rsquo; assignació consisteix en donar un valor a una variable. \u0026ldquo;Guardar\u0026rdquo; una informació en una variable, que segurament serà tractada i/o consultada més endavant.\n    Codi Diagrama de flux     Acció1;\nAcció2;\nAcció3;\nAcció4;     Exemples  Llegeix dos nombres reals i escriu la seva suma, resta, producte i quocient.  float operand1 = sc.nextFloat(); float operand2 = sc.nextFloat(); float suma = operand1 + operand2; float resta = operand1 - operand2; float multiplicacio = operand1 * operand2; float divisio = operand1 / operand2; float modul = operand1 % operand2;  Llegeix el preu d\u0026rsquo;un producte, l\u0026rsquo;IVA (en %) i el descompte (en %) a aplicar. Escriu el preu final del producte.  float preu = sc.nextFloat(); int iva = sc.nextInt(); int descompte = sc.nextInt(); float preuAmbIva = preu + preu * iva / 100; float preuAmbIvaIDescompte = preuAmbIva - preuAmbIva * descompte / 100; System.out.println(\u0026quot;Preu final:\u0026quot; + preuAmbIvaIDescompte);  Calcula l\u0026rsquo;àrea lateral i el volum d\u0026rsquo;un cilindre recte, introduint per teclat els valors del radi i l\u0026rsquo;altura. V =pi⋅r2⋅h AL=2⋅pi⋅r⋅h  float radi = sc.nextFloat(); float altura = sc.nextFloat(); double areaLateral = 2 * Math.PI * radi * altura; double volum = Math.PI * Math.pow(radi,2) * altura; System.out.println(\u0026quot;Area lateral:\u0026quot; + areaLateral + \u0026quot; Volum:\u0026quot; + volum);  Llegeix un nombre enter no negatiu i un altre nombre enter no negatiu que indica la posició de les seves xifres i escriu la xifra que ocupa aquesta posició. Les unitats estan a la posició 1, les desenes a la posició 2, etc.  int nombre = sc.nextInt(); int posicio = sc.nextInt(); double potencia = Math.pow(10,posicio-1); double nombreRetallat = nombre / potencia; int nombreBuscat = (int)nombreRetallat % 10; System.out.println(\u0026quot;el dígit \u0026quot; +posicio+ \u0026quot; del nombre \u0026quot; + nombre + \u0026quot; és: \u0026quot;+ nombreBuscat);  Llegeix un nombre enter de segons i escriu el nombre d’hores, minuts i segons equivalents en format h:m:s.  int segonsTotals = sc.nextInt(); int hores = segonsTotals / 3600; int segonsRestants = segonsTotals % 3600; int minuts = segonsRestants / 60; int segons = segonsRestants % 60; System.out.println(hores + \u0026quot;:\u0026quot; + minuts + \u0026quot;:\u0026quot; + segons);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/2metodologiessoftware/",
	"title": "Metodologies de Software",
	"tags": [],
	"description": "",
	"content": "El programari no es fabrica com qualsevol altre producte clàssic, sinó que es desenvolupa seguint una sèrie d\u0026rsquo;etapes. D\u0026rsquo;aquí sorgeix el concepte d\u0026rsquo;enginyeria de programari, que consisteix en l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria per obtenir desenvolupaments que optimitzin l\u0026rsquo;efectivitat i els costos.\nEls processos d\u0026rsquo;enginyeria de programari comprenen per tant, diverses etapes, que constitueixen el que s\u0026rsquo;anomena el cicle de vida del programari. Per dur a terme aquestes fases és necessari partir d\u0026rsquo;un enfocament amb el qual iniciar el procés de enginyeria. Un cop iniciat, s\u0026rsquo;ha d\u0026rsquo;utilitzar una metodologia amb unes eines que permetin completar les diferents etapes de l\u0026rsquo;cicle.\nEn l\u0026rsquo;actualitat, l\u0026rsquo;enfocament més estandaritzat és l\u0026rsquo;orientació a objectes. la creació el 1998 de l\u0026rsquo;estàndard UML (Unified Modeling Language) per a la definició de problemes i el desenvolupament de llenguatges de programació com Java o C ++ pel desenvolupament i integració de solucions, són els principals causants que aquest enfocament s\u0026rsquo;estigui consolidant.\nQuè és l\u0026rsquo;enginyeria del software? De l\u0026rsquo;aplicació de l\u0026rsquo;enginyeria a l\u0026rsquo;programari sorgeixen els processos de desenvolupament de programari. Aquest procés es defineix com \u0026ldquo;aquell en què les necessitats de l\u0026rsquo;usuari són traduïdes en requisits de programari, aquests requisits transformats en disseny, i el disseny implementat en codi, que és provat, documentat i certificat pel seu ús operatiu\u0026rdquo; [Jacobson, 1998].\n aracterístiques del software  S\u0026rsquo;ha invertit la demanda i el preu respecte al HW. El Software es un producte lògic que es desenvolupa, no es construeix com la resta de productes. La gestió de costos es centra en l\u0026rsquo;enginyeria, amb la qual difereix d\u0026rsquo;altres projectes d\u0026rsquo;enginyeria. El Software no es deteriora amb el temps, però sí és necessari un manteniment. La reutilització de productes software creixent. Existeixen restriccions de recursos en el desenvolupament de software, de forma que és necessari assegurar-ne la qualitat per obtenir un software: documentat, fiable, eficient i amb una bona interfície gràfica.  Cicles de desenvolupament del software. Tipus de cicles Anomenem cicle de vida del software al temps necessari per la producció d\u0026rsquo;un projecte software desde la recopilació de requisits fins a l\u0026rsquo;entrega final del producte. El cicle de vida inclou una sèrie d\u0026rsquo;etapes que pot canviar en funció del model, la metodologia i l\u0026rsquo;autor. Existeixen varis tipus de cicles de vida que passem a comentar.\nModel en cascada o lineal Es tracta d\u0026rsquo;un model molt genèric i que estableix una sèrie de fases o etapes, que han de ser seguides en un ordre seqüencial, ja que cada fase genera entrades i documentació per a la següent fase. Les fases d\u0026rsquo;un cicle de vida en cascada segueixen el següent esquema:\nLes característiques del model són:\n Cada etapa s\u0026rsquo;inicia un cop acabada l\u0026rsquo;anterior. Ajuda a la planificació temporal i el càlcul de costos, a causa de la seqüencialitat i estructura lògica de les etapes. Hi ha una realimentació en el manteniment.  Quant als inconvenients que s\u0026rsquo;han detectat, aquests són:\n Es tracta d\u0026rsquo;un model rígid, sense robustesa ni adaptabilitat als problemes a resoldre. Hi ha dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials, ja que aquests solen venir donats per persones alienes al coneixement del cicle de desenvolupament de programari. Els errors solen detectar-se molt tard, el que implica que el cost per solucionar l\u0026rsquo;error sigui molt més gran. El manteniment es realitza mitjançant petites actualitzacions o \u0026ldquo;pegats\u0026rdquo;. Torna a aplicar cadascuna de les fases del cicle al programari ja existent, sense crear un de nou.  Fases:\n Anàlisi de sistema: el sistema de programari forma part sobre un sistema major amb el qual es relaciona. S\u0026rsquo;analitza el sistema en el seu conjunt per treure objectius que han de ser abordables pel programari. Anàlisi de requisits: definint funcions a realitzar, dades, comportament, i interacció entre elements funcionals. Disseny: a partir de requisits dissenyem els components de programari, estructures de dades, mòduls, procediments, algoritmes i interfícies\u0026hellip; Codificació: a partir d\u0026rsquo;informació generada implementem sistema, codifiquem procediments en un llenguatge de programació. Prova: validem i verifiquem que els requisits establerts pel client es realitzen correctament. Manteniment: la producció de programari no finalitza amb el lliurament, ha de ser revisat i reajustat quan això sigui necessari.  Cicle de vida prototipat Aquest model tracta de solucionar problemes del model en cascada, en concret les dificultats a l\u0026rsquo;hora d\u0026rsquo;establir els requisits inicials. El client sol definir els objectius generals del programari, però no acostuma a tenir en compte tots els requisits reals que ha de tenir una aplicació. Al mateix temps, el desenvolupador pot no arribar a entendre què vol el client. Per tal de solucionar això, un cicle basat en prototips pot ser un millor enfocament.\nLes característiques d\u0026rsquo;aquest model són:\n Client i desenvolupador defineixen una sèrie d\u0026rsquo;objectius globals, dels quals s\u0026rsquo;identifiquen els requisits, amb els quals es realitza un disseny ràpid, i amb aquest, la creació d\u0026rsquo;un prototip. El prototip és avaluat per l\u0026rsquo;usuari, qui pot veure les deficiències del prototip, a partir de les quals es redefineixen els requisits. Es van construint nous prototips, amb els quals el client pot anar polint els requisits de programari, al mateix temps que el desenvolupador pot comprendre millor el que ha de fer. Aquestes interaccions finalitzen quan el prototip satisfà les necessitats del client.  Inconvenients d\u0026rsquo;aquest tipus de cicle de vida:\n És un procés molt lent. Si es desitja generar un programari de qualitat no n\u0026rsquo;hi ha prou que un prototip sigui com l\u0026rsquo;anterior amb uns petits ajustos, sinó que es requereix crear el producte de nou. això succeeix fonamentalment amb els primers prototips de cada desenvolupament. El client veu cada prototip com una versió de programari final, sense prendre consciència que cada prototip únicament ajuda a aclarir els requisits, i per tant, és generat des del principi, per aconseguir una robustesa en el desenvolupament. Els primers prototips que es rebutgen suposen un cost addicional, ja que amb prou feines poden emprar-se per al mateix desenvolupament ni poden ser reutilitzats per a altres.  Cicles de vida evolutius El programari és un producte que va evolucionant per això els desenvolupadors necessiten un nou model de cicle de vida, que permeti que les funcionalitats del programari puguin anar canviant amb el temps. El model en cascada assumeix que es lliura un producte una vegada acabades totes les fases del procés, sense considerar possibles evolucions. Tampoc es té en compte l\u0026rsquo;evolució en el model de prototips, en que aquests es dissenyen per ajudar al client a comprendre els requisits, però no per disposar de versions a millorar.\nLa solució la presenten els cicles de vida evolutius, que amb una estructura iterativa, permeten als enginyers desenvolupar versions cada vegada més completes del programari.\nCicle de vida incremental Aquest model combina el model lineal seqüencial amb la filosofia de creació de prototips. Per a això, va generant seqüències lineals de desenvolupament al mateix temps que cada seqüència lineal produeix un \u0026ldquo;increment\u0026rdquo; en el programari, el qual va progressant.\nEl primer increment sol ser un desenvolupament que tan sols incorpora els requisits i funcionalitats més bàsiques. Les versions successives consisteixen en modificacions de cada versió anterior, a la qual s\u0026rsquo;afegeixen noves funcionalitats i modificacions, es van lliurant les diferents versions o increments d\u0026rsquo;acord es van acabant. A diferència del prototipat, cada increment aprofita la versió anterior, i és una versió del producte final a falta d\u0026rsquo;algunes funcionalitats. L\u0026rsquo;esquema que segueix aquest tipus de cicle de vida és el següent:\nAquest tipus de cicle de vida és molt avantatjós des del punt de vista de costos temporals i flexibilitat en la planificació del projecte. Els primers increments no requereixen molt personal, mentre que per als següents es poden anar afegint més o menys funcionalitats segons la quantitat de personal de què es disposi o bé segons que es disposi o no de determinats recursos.\nCicle de vida en espiral És un procés evolutiu que combina la interactivitat del prototipat amb els aspectes sistemàtics del model en cascada. Cada volta de l\u0026rsquo;espiral consta de les mateixes fases que el cicle en cascada:\n Planificació: determina objectius, requisits i restriccions de el projecte. Anàlisi de risc: analitza alternatives, identifica i resol riscos Enginyeria: desenvolupament del producte. Avaluació de client: es valoren els resultats obtinguts.  Segueix les directrius del model PDCA (Plan Develop Check Act) de Demming, i segueix la filosofia del moviment Agile resumit en el Manifiesto Agile, una de les seves implementacions més conegudes és SCRUM.\nEl principal avantatge del model en espiral és que és el més adequat per projectes amb riscs. Com el programari va evolucionant, el desenvolupador i client poden anar comprenent cada vegada millor els riscos conforme es va passant per diferents nivells d\u0026rsquo;evolució. El mecanisme utilitzat per minimitzar riscos es basa en poder incorporar el prototipat en qualsevol etapa d\u0026rsquo;evolució del producte.\nDavant d\u0026rsquo;aquest avantatge, es troba l\u0026rsquo;inconvenient de requerir una alta habilitat en els enginyers per avaluar riscos. L\u0026rsquo;èxit depèn molt d\u0026rsquo;ella, ja que un risc no descobert pot donar lloc a problemes.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/2tipusdades/",
	"title": "Tipus de dades i operadors",
	"tags": [],
	"description": "",
	"content": "Tipus de dades En el llenguatge Java incorpora tipus de dades diferents d\u0026rsquo;acord amb la seva naturalesa: no és el mateix un nombre, que un text o un valor verdader/fals per exemple. Aquests tipus de dades els classifiquem en tipus de dades primitius i tipus de dades de classe:\n Primitius: són les dades simples que coneixem com a nombres, text, etc. i que ens defineix de forma primitiva el llenguatge. Classe: són tipus de dades més complexos que es creen a partir dels mateixos tipus de classe o de tipus primitius.  Tipus Primitius En Java podem diferenciar els següents tipus de dades primitius:\n Numèrics:  Enters: byte, short, int i long Reals: float, double   Textuals:  chars   Lògics:  boolean    La diferència entre els nombres enters i reals és que els nombres enters no contenen decimals (ex: 2 | 3 | 25) i els nombres reals reserven espai pels decimals (ex: 4,45 | 6,82 | 3,141592). Tot seguit us mostro una taula de rangs:\n   Nom Longitud Rangs de valors     byte 8 bits De -27 a 27 -1   short 16 bits De -215 a 215 -1   int 32 bits De -231 a 231 -1   long 64 bits De -263 a 263 -1   float 32 bits    double 64 bits    char 16 bits     Els valors que admet una variable de tipus booleà és: true o false. Un valor booleà és molt comú en el camp informàtic on moltes vegades cal prendre una decisió que es pot avaluar en \u0026ldquo;veritat\u0026rdquo; o \u0026ldquo;fals\u0026rdquo;.\nExemple d\u0026rsquo;assignació de valors Declarem i assignem un valor a les variables:\nboolean valorBoolea = true; int valorEnter = 50; float valorDecimal = 50.3; char lletra =’v’;  En aquest cas primer declarem les variables i després li assignem un valor:\nboolean valorBoolea; valorBoolea = true; int valorEnter; valorEnter = 50; float valorDecimal; valorDecimal = 50.3; char lletra; lletra =’v’;  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/1estructura/3tipusllenguatges/",
	"title": "Tipus de Llenguatges",
	"tags": [],
	"description": "",
	"content": "Els llenguatges de programació es poden classificar a partir de diferents criteris\n Segons la proximitat al nucli. Segons el paradigma de programació. Segons la traducció a codi màquina. Segons la generació.  1. Segons la proximitat al nucli La proximitat al nucli queda determinat per saber en quin moment s\u0026rsquo;executa aquest llenguatge. Poden ser llenguatges d\u0026rsquo;alt nivell, dins el sistema de capes, molt allunyat del nucli, o llenguatges de baix nivell propers al nucli.\n Els llenguatges de programació es poden classificar segons la seva proximitat al llenguatge màquina:\n   Llenguatges de baix nivell     Llenguatge de programació pròxim al nucli de la màquina i que només entén la màquina.   Es composa per codi binari (símbols 0 i 1).   És el llenguatge més bàsic i també més difícil d\u0026rsquo;entendre pels humans ja que totes les instruccions són tires de 0s i 1s.   És un llenguatge molt lligat a l\u0026rsquo;arquitectura de la màquina.   S\u0026rsquo;utilitzen adreces de memòria per fer referència a les dades.   Les instruccions tenen un format rígid.       Llenguatges ensambladors     Separen les característiques del maquinari de la tasca de programació.   Es substitueixen els codis numèrics per representacions textuals equivalents a les instruccions màquina que representen.   Segueixen tenint una forta relació amb els llenguatges màquina però permeten utilitzar adreces simbòliques i incloure línies de comentaris.       Llenguatges d\u0026rsquo;alt nivell     Alliberen el programador de tasques tedioses i complexes que frenen la productivitat i l\u0026rsquo;eficiència.   Tenen un gran nivell d\u0026rsquo;abstracció que fa innecessari el coneixement de l\u0026rsquo;arquitectura de la màquina.   Les instruccions s\u0026rsquo;expressen per caràcters alfanumèrics; permeten definir variables; disposen d\u0026rsquo;instruccions molt ponents de tipus aritmètic, lògiques, tractament de caràcters, etc .; són fàcils de corregir i actualitzar i fàcils d\u0026rsquo;aprendre.   Per contra, no són tant conscients en quant a consum de recursos.    2. Segons el paradigma de programació Un paradigma de programació és un enfoc particular/filosofia pel disseny i construcció de codi. Depenent de cada context resulta més idoni utilitzar-ne un o altre\n A grans trets diferenciarem entre\n  Llenguatges imperatius: - Descriu la programació com una seqüència instruccions o ordres que canvien l\u0026rsquo;estat d\u0026rsquo;un programa. - Formen part d\u0026rsquo;aquest tipus molts llenguatges d\u0026rsquo;alt nivell i d\u0026rsquo;ús general: python, c, java, c++ etc. - Es fixen en el COM es desenvolupa el codi (com s\u0026rsquo;aconsegueix un objectiu pas a pas). - En aquest paradigma s\u0026rsquo;inclouen altres paradigmes com el modular, orientació a objectes, concurrent, etc.\n  Llenguatges declaratius: - Es fixen en QUÈ descriu (declara la solució), es basa en les propietats de la solució buscada. - No es coneix l\u0026rsquo;algorisme usat per trobar aquesta solució. - No es coneix el rendiment i/o eficiència del codi a priori - Molt útil en la resolució de problemes i situacions determinades. - En aquest paradigma s\u0026rsquo;inclouen els paradigmes funcional, lògic i no procedimental.\n  Com a subtipus dels anteriors destaquem:\n   Programació estructurada   Utilitza únicament seqüències, instruccions condicionals i instruccions repetitives. Es tracta en la UF1 de M03 Programació.\n    Programació modular   El programa es dissenya per parts(mòduls). Es tracta en la UF2 de M03 Programació.\n    Programació orientada a objectes   Programació basada en la comunicació i el pas de missatges entre objectes (estructures amb atributs i mètodes). Es tracta en la UF4 de M03 Programació.\n    Programació concurrent   Útil quan hem de realitzar diverses accions a la vegada i utilitzant recursos compartits. Es tracta en M09 Programació de serveis.\n    Programació funcional   Tot el codi es basa en funcions, des de l\u0026rsquo;expressió mínima a qualsevol estructura complexa. Exemple d\u0026rsquo;aquest paradigma és el llenguatge Lisp o Haskel.\n    Programació lògica   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog.\n \n3. Segons la traducció a codi màquina Els llenguatges de programació poden tenir diferents tractaments fins a ser executats, així diferenciem els llenguatges interpretats, compilats i els híbrids.\n Desde que un programa és escrit i és executat per la màquina hi ha un seguit de passos que cal tenir presents:\n Anàlisi (lèxic, sintàtic i semàntic) Traducció(generació i optimització de codi)  Depenent de com es realitza aquesta traducció tenim llenguatges compilats i interpretats:\n   Llenguatges compilats     Una vegada el codi és analitzat es genera el codi objecte d\u0026rsquo;acord amb les característiques del compilador del llenguatge. Depenent del tipus de compilador l\u0026rsquo;objecte pot ser directament executable o necessita altres passos previs com l\u0026rsquo;acoblament, l\u0026rsquo;enllaçat i la càrrega (Com per exemple el llenguatge C).   Per tal de flexibilitzar el codi, els compiladors treballen amb biblioteques de mòduls objecte. Per incloure-les en el codi màquina final s\u0026rsquo;ha d\u0026rsquo;usar un enllaçador que retorna un únic programa executable.   Els programes objecte s\u0026rsquo;executen molt més ràpidament que els interpretats ja que estan optimitzats per uns determinats recursos HW, però no permet transportar codi objecte entre diferents plataformes d\u0026rsquo;execució.   Exemples de llenguatges els traductors són compiladors són FORTRAN, COBOL, C, PASCAL, ADA \u0026hellip;       Llenguatges interpretats     En aquest cas es duu a la vegada el procés de traducció i el d\u0026rsquo;execució. La seva forma de treball és anar analitzant instruccions de codi del programa font, generant el codi màquina corresponent i executant.   Són més lents que els compilats, per contra, són fàcilment transportables entre diferents màquines, ja que és el propi programa font el que es mou.   Exemples de llenguatge interpretat són PROLOG, i SQL, Javascript, Python, etc.       Llenguatges híbrids     Aprofiten el millor d\u0026rsquo;ambdós mons com Java o Visual Studio .NET. Són capaços de compilar el codi a un llenguatge intermedi denominat bytecode en JAVA i MSI en .NET, que després són interpretats per una màquina virtual (MVJ o .NET Framework), així aconsegueixen una substancial millora en el rendiment i mantenen la característica de transportabilitat entre diferents plataformes    4. Segons la generació Depenent de quan es va crear el llenguatge s\u0026rsquo;emmarca en unes necessitats i usos concrets que han donat lloc a generacions. Són seqüencials en el temps.\n    Primera generació   Són els que corresponen als llenguatges ja vistos de baix nivell o llenguatges màquina.\n    Segona generació   Són aquells que pertanyen als llenguatges assembladors.\n    Tercera generació   A la tercera generació pertanyen aquells llenguatges estructurats que seguien un ordre alhora d\u0026rsquo;executar les instruccions. Llenguatges com C, pascal, cobol, etc.\n    Quarta generació   A partir d\u0026rsquo;una sèrie de predicats i una base de coneixement es desenvolupa aquest paradigma de relacions lògiques. Exemple d\u0026rsquo;aquest paradigma és el llenguatge de programació Prolog. Els llenguatges de quarta generació, són els més propers a la sintaxi de la llengua humana, i s\u0026rsquo;acostumen a utilitzar en les creacions de bases de dades o com a llenguatges de programació dels llenguatges o sistemes d\u0026rsquo;autor. Són llenguages no procedimentals com SQL que permeten definir quins seran els resultats finals sense necessitat de preocupar-se per saber com fer-ho.\n    Cinquena generació   Amb la incorporació i expansió dels llenguatges orientats a objectes i amb la generalització de l\u0026rsquo;ús de les GUI, és possible abarca problemes de major abstracció. Alguns exemples són Java, C++, etc. S\u0026rsquo;ha generalitzat tant els IDEs de desenvolupament com els CLIs per cada servei/llenguatge.\n \n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/3algor%C3%ADsmia/",
	"title": "Algorísmia",
	"tags": [],
	"description": "",
	"content": "Què és un algorisme? Un algorisme és un mètode per resoldre un PROBLEMA, són un conjunt d\u0026rsquo;operacions finites i ordenades que s\u0026rsquo;han de seguir per a la resolució d\u0026rsquo;un problema.\n Característiques dels algorismes\nLes característiques bàsiques d\u0026rsquo;un algorisme són:\n Ordenat. Cada instrucció té una posició dins el conjunt. Precís. Cada instrucció és unívoca i obeeix a un objectiu. Definit. Si es segueix un algorisme dues vegades, s\u0026rsquo;ha d\u0026rsquo;obtenir el mateix resultat cada vegada. Finit. L\u0026rsquo;algorisme ha d\u0026rsquo;acabar en algun moment, per tant, tindrà un nombre finit de passos. Un bon disseny algorítmic contindrà tres parts: Entrada (Input), Procés (Tractament de la informació) i Sortida (Output).  Pseudocodi El pseudocodi és un llenguatge informal d’alt nivell que usa les convencions i l’estructura d’un llenguatge de programació, però que està orientat a ser entès pels humans.\n Diagrama de flux Un diagrama de flux de control consisteix en una subdivisió de passes seqüencials, d’acord amb les sentències i estructures de control d’un programa, que mostra els diferents camins que pot seguir un programa a l’hora d’executar les seves instruccions. Cada passa s’associa a una figura geomètrica específica.\n Complexitat ciclomàtica La Complexitat ciclomàtica (en anglès, Cyclomatic Complexity) és una mètrica de programari en enginyeria de programari que proporciona una mesura quantitativa de la complexitat lògica d\u0026rsquo;un programa. Consisteix en comptar el nombre de camins necessaris per tal d\u0026rsquo;anar de la primera a la última instrucció passant per tots els camins possibles i cobrint tots els casos.\n "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/condicional/",
	"title": "Estructura condicional",
	"tags": [],
	"description": "",
	"content": "Estructura condicional L\u0026rsquo;estructura de control condicional o alternativa permet prendre una decisió en un moment determinat sobre quines instruccions s\u0026rsquo;han d\u0026rsquo;executar. Donada una expressió booleana (una expressió lògica que s\u0026rsquo;avalua a veritat \u0026ldquo;true\u0026rdquo; o fals \u0026ldquo;false\u0026rdquo;) permet decidir entre un o varis camins d\u0026rsquo;execució.\n Existeixen diferents tipus d\u0026rsquo;estructura condicional.\n Estructura simple (if) Estructura composta (if/else) Estructura encadenada (if/else if/else) Sentència switch (switch) Combinació d\u0026rsquo;estructures  Estructura simple (if) Aquesta és la forma bàsica. Consisteix en una estructura en la qual si l\u0026rsquo; avaluació lògica és certa s\u0026rsquo;executen una sèrie d\u0026rsquo;instruccions, en cas contrari s\u0026rsquo;ometen aquestes instruccions. Consideracions:\n L\u0026rsquo;expressió lògica ha d\u0026rsquo;anar seguida de la paraula if i entre parèntesi (). Les instruccions que s\u0026rsquo;han d\u0026rsquo;executar es situen a continuació dins de les claus {}.  Exemples  Llegeix dos nombres reals i escriu la seva suma, resta, producte i quocient.  float operand1 = sc.nextFloat(); float operand2 = sc.nextFloat(); float suma = operand1 + operand2; float resta = operand1 - operand2; float multiplicacio = operand1 * operand2; float divisio = operand1 / operand2; float modul = operand1 % operand2;  Llegeix el preu d\u0026rsquo;un producte, l\u0026rsquo;IVA (en %) i el descompte (en %) a aplicar. Escriu el preu final del producte.  float preu = sc.nextFloat(); int iva = sc.nextInt(); int descompte = sc.nextInt(); float preuAmbIva = preu + preu * iva / 100; float preuAmbIvaIDescompte = preuAmbIva - preuAmbIva * descompte / 100; System.out.println(\u0026quot;Preu final:\u0026quot; + preuAmbIvaIDescompte);  Calcula l\u0026rsquo;àrea lateral i el volum d\u0026rsquo;un cilindre recte, introduint per teclat els valors del radi i l\u0026rsquo;altura. V =pi⋅r2⋅h AL=2⋅pi⋅r⋅h  float radi = sc.nextFloat(); float altura = sc.nextFloat(); double areaLateral = 2 * Math.PI * radi * altura; double volum = Math.PI * Math.pow(radi,2) * altura; System.out.println(\u0026quot;Area lateral:\u0026quot; + areaLateral + \u0026quot; Volum:\u0026quot; + volum);  Llegeix un nombre enter no negatiu i un altre nombre enter no negatiu que indica la posició de les seves xifres i escriu la xifra que ocupa aquesta posició. Les unitats estan a la posició 1, les desenes a la posició 2, etc.  int nombre = sc.nextInt(); int posicio = sc.nextInt(); double potencia = Math.pow(10,posicio-1); double nombreRetallat = nombre / potencia; int nombreBuscat = (int)nombreRetallat % 10; System.out.println(\u0026quot;el dígit \u0026quot; +posicio+ \u0026quot; del nombre \u0026quot; + nombre + \u0026quot; és: \u0026quot;+ nombreBuscat);  Llegeix un nombre enter de segons i escriu el nombre d’hores, minuts i segons equivalents en format h:m:s.  int segonsTotals = sc.nextInt(); int hores = segonsTotals / 3600; int segonsRestants = segonsTotals % 3600; int minuts = segonsRestants / 60; int segons = segonsRestants % 60; System.out.println(hores + \u0026quot;:\u0026quot; + minuts + \u0026quot;:\u0026quot; + segons);  "
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/iteratiu/",
	"title": "Estructura iterativa",
	"tags": [],
	"description": "",
	"content": "Thanks to the simplicity of Hugo, this page is as empty as this theme needs requirements.\nJust download latest version of Hugo binary (\u0026gt; 0.25) for your OS (Windows, Linux, Mac) : it\u0026rsquo;s that simple.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/cadenescaracters/",
	"title": "Tractament cadena de caràcters",
	"tags": [],
	"description": "",
	"content": "Thanks to the simplicity of Hugo, this page is as empty as this theme needs requirements.\nJust download latest version of Hugo binary (\u0026gt; 0.25) for your OS (Windows, Linux, Mac) : it\u0026rsquo;s that simple.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/4programacioestructurada/",
	"title": "Programació estructuada",
	"tags": [],
	"description": "",
	"content": "Què és la programació estructurada? La programació estructurada és un paradigma de programació en el qual les instruccions de codi s\u0026rsquo;executen de forma ordenada utilitzant només tres estructures: seqüencial, condicional i repetitiva.\n S\u0026rsquo;anomena estructura a la manera en què diferents parts es combinen per construir un tot. Un programa tindrà l\u0026rsquo;estructura corresponent a la forma en què les diferents accions individuals o avaluacions parcials es combinen per construir el programa en el seu conjunt.\nEls fonaments de l\u0026rsquo;anomenada programació estructurada es van establir a principis dels anys seixanta i es van consolidar amb els treballs de Dijkstra, Bohm.. El resum dels seus postulats és el següent: \u0026ldquo;es diu que un programa és estructurat si s\u0026rsquo;expressa únicament mitjançant combinacions de les estructures bàsiques\u0026rdquo;:\n seqüencial condicional iterativa  Estructura bàsica: Totes les estructures de control tenen un únic punt d\u0026rsquo;entrada i un únic punt de sortida.\nTot seguit repassarem les tres estructures de control: seqüencials, condicionals i iteratives en Java.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/5dadescompostes/",
	"title": "Estructures compostes",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Basics Discover what this Hugo theme is all about and the core-concepts behind it.\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/",
	"title": "M03 Programació DAM",
	"tags": [],
	"description": "",
	"content": "M03 Programació DAM En aquesta pàgina web trobareu els apunts del M03. Programació DAM. La web està realitzada utilitzant un Framework Web(Hugo), hostatjada a Github i es fa ús de Github Pages.\nTot seguit es mostra la calendarització i les hores de les UFs que s\u0026rsquo;imparteixen en aquest mòdul de 1r de DAM. Fixeu-vos que l\u0026rsquo;ordre de realització de les UFs és: UF1, UF2, UF4 i UF3. La UF4 segueix a la UF2, ja que pedagògicament té més sentit realitzar-la després d\u0026rsquo;aquesta UF.\n   UF dates hores     UF1: Programació estructurada 15/09/20 - 11/12/20 85h   UF2: Disseny modular 14/12/20 - 05/02/21 50h   UF4: Programació orientada a objectes (POO) 06/02/21 - 23/04/21 68h   UF3: Fonaments de fitxers 24/04/21 - 25/05/21 30h    L\u0026rsquo;índex de continguts que veurem és:\n UF1: Programació estructurada  Estructura d\u0026rsquo;un programa  Propòsit i Blocs d\u0026rsquo;un programa Metodologies de Software Tipus de Llenguatges   Tipus de dades Algorísmia Programació estructurada  Estructura sequencial Estructura condicional Estructura iterativa   Estructures compostes  Arrays Unidimensionals Arrays Bidimensionals Tractament cadena de caràcters      UF2: Disseny modular\nUF4: Programació orientada a objectes (POO)\nUF3: Fonaments de fitxers\n"
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pepbea.github.io/m03programacio/continguts/public/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]